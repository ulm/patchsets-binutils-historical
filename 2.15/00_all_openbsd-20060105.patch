http://bugs.gentoo.org/115676

--- binutils-2.15.orig/bfd/Makefile.am
+++ binutils-2.15/bfd/Makefile.am
@@ -279,6 +279,7 @@
 	m68klynx.lo \
 	m68knetbsd.lo \
 	m88kmach3.lo \
+	m88kopenbsd.lo \
 	mach-o.lo \
 	mipsbsd.lo \
 	newsos3.lo \
@@ -443,6 +444,7 @@
 	m68klynx.c \
 	m68knetbsd.c \
 	m88kmach3.c \
+	m88kopenbsd.c \
 	mach-o.c \
 	mipsbsd.c \
 	newsos3.c \
@@ -796,7 +798,7 @@
 aout-params.h: gen-aout
 	./gen-aout host > aout-params.h
 gen-aout: $(srcdir)/gen-aout.c Makefile
-	$(CC) -o gen-aout $(CFLAGS) $(LFLAGS) $(srcdir)/gen-aout.c
+	$(CC) -o gen-aout $(CSEARCH) $(CFLAGS) $(LFLAGS) $(srcdir)/gen-aout.c
 
 $(BFD_H): stmp-bfd-h ; @true
 
@@ -1383,6 +1385,9 @@
 m88kmach3.lo: m88kmach3.c $(INCDIR)/filenames.h libaout.h \
   $(INCDIR)/bfdlink.h aout-target.h $(INCDIR)/aout/aout64.h \
   $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
+m88kopenbsd.lo: m88kopenbsd.c netbsd.h $(INCDIR)/filenames.h libaout.h \
+  $(INCDIR)/bfdlink.h aout-target.h $(INCDIR)/aout/aout64.h \
+  $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
 mach-o.lo: mach-o.c mach-o.h $(INCDIR)/filenames.h \
   $(INCDIR)/libiberty.h mach-o-target.c
 mipsbsd.lo: mipsbsd.c $(INCDIR)/filenames.h libaout.h \
--- binutils-2.15.orig/bfd/Makefile.in
+++ binutils-2.15/bfd/Makefile.in
@@ -409,6 +409,7 @@
 	m68klynx.lo \
 	m68knetbsd.lo \
 	m88kmach3.lo \
+	m88kopenbsd.lo \
 	mach-o.lo \
 	mipsbsd.lo \
 	newsos3.lo \
@@ -574,6 +575,7 @@
 	m68klynx.c \
 	m68knetbsd.c \
 	m88kmach3.c \
+	m88kopenbsd.c \
 	mach-o.c \
 	mipsbsd.c \
 	newsos3.c \
@@ -968,6 +970,7 @@
 	rev=''; list='$(SUBDIRS)'; for subdir in $$list; do \
 	  rev="$$subdir $$rev"; \
 	  test "$$subdir" != "." || dot_seen=yes; \
+	  true; \
 	done; \
 	test "$$dot_seen" = "no" && rev=". $$rev"; \
 	target=`echo $@ | sed s/-recursive//`; \
@@ -1348,7 +1351,7 @@
 aout-params.h: gen-aout
 	./gen-aout host > aout-params.h
 gen-aout: $(srcdir)/gen-aout.c Makefile
-	$(CC) -o gen-aout $(CFLAGS) $(LFLAGS) $(srcdir)/gen-aout.c
+	$(CC) -o gen-aout $(CSEARCH) $(CFLAGS) $(LFLAGS) $(srcdir)/gen-aout.c
 
 $(BFD_H): stmp-bfd-h ; @true
 
@@ -1920,6 +1923,9 @@
 m88kmach3.lo: m88kmach3.c $(INCDIR)/filenames.h libaout.h \
   $(INCDIR)/bfdlink.h aout-target.h $(INCDIR)/aout/aout64.h \
   $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
+m88kopenbsd.lo: m88kopenbsd.c netbsd.h $(INCDIR)/filenames.h libaout.h \
+  $(INCDIR)/bfdlink.h aout-target.h $(INCDIR)/aout/aout64.h \
+  $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
 mach-o.lo: mach-o.c mach-o.h $(INCDIR)/filenames.h \
   $(INCDIR)/libiberty.h mach-o-target.c
 mipsbsd.lo: mipsbsd.c $(INCDIR)/filenames.h libaout.h \
--- binutils-2.15.orig/bfd/aoutx.h
+++ binutils-2.15/bfd/aoutx.h
@@ -831,6 +831,10 @@
 	arch_flags = M_CRIS;
       break;
 
+    case bfd_arch_m88k:
+      *unknown = FALSE;
+      break;
+
     default:
       arch_flags = M_UNKNOWN;
     }
--- binutils-2.15.orig/bfd/bfd-in.h
+++ binutils-2.15/bfd/bfd-in.h
@@ -308,7 +308,8 @@
 #define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
 #define bfd_get_section_alignment(bfd, ptr) ((ptr)->alignment_power + 0)
 #define bfd_section_name(bfd, ptr) ((ptr)->name)
-#define bfd_section_size(bfd, ptr) (bfd_get_section_size_before_reloc(ptr))
+#define bfd_section_size(bfd, ptr) ((ptr)->_raw_size)
+#define bfd_get_section_size(ptr) ((ptr)->_raw_size)
 #define bfd_section_vma(bfd, ptr) ((ptr)->vma)
 #define bfd_section_lma(bfd, ptr) ((ptr)->lma)
 #define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)
@@ -505,6 +506,8 @@
   (bfd *abfd);
 /* NB: This declaration should match the autogenerated one in libbfd.h.  */
 
+extern bfd_boolean bfd_cache_close_all (void);
+
 extern bfd_boolean bfd_record_phdr
   (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
    bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
--- binutils-2.15.orig/bfd/bfd-in2.h
+++ binutils-2.15/bfd/bfd-in2.h
@@ -315,7 +315,8 @@
 #define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
 #define bfd_get_section_alignment(bfd, ptr) ((ptr)->alignment_power + 0)
 #define bfd_section_name(bfd, ptr) ((ptr)->name)
-#define bfd_section_size(bfd, ptr) (bfd_get_section_size_before_reloc(ptr))
+#define bfd_section_size(bfd, ptr) ((ptr)->_raw_size)
+#define bfd_get_section_size(ptr) ((ptr)->_raw_size)
 #define bfd_section_vma(bfd, ptr) ((ptr)->vma)
 #define bfd_section_lma(bfd, ptr) ((ptr)->lma)
 #define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)
@@ -512,6 +513,8 @@
   (bfd *abfd);
 /* NB: This declaration should match the autogenerated one in libbfd.h.  */
 
+extern bfd_boolean bfd_cache_close_all (void);
+
 extern bfd_boolean bfd_record_phdr
   (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
    bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
--- binutils-2.15.orig/bfd/cache.c
+++ binutils-2.15/bfd/cache.c
@@ -237,6 +237,33 @@
 }
 
 /*
+FUNCTION
+	bfd_cache_close_all
+
+SYNOPSIS
+	bfd_boolean bfd_cache_close_all (void);
+
+DESCRIPTION
+	Remove all BFDs from the cache. If the attached file is open,
+	then close it too.
+
+RETURNS
+	<<FALSE>> is returned if closing one of the file fails, <<TRUE>> is
+	returned if all is well.
+*/
+
+bfd_boolean
+bfd_cache_close_all ()
+{
+  bfd_boolean ret = TRUE;
+
+  while (bfd_last_cache != NULL)
+    ret &= bfd_cache_close (bfd_last_cache);
+
+  return ret;
+}
+
+/*
 INTERNAL_FUNCTION
 	bfd_open_file
 
--- binutils-2.15.orig/bfd/config.bfd
+++ binutils-2.15/bfd/config.bfd
@@ -213,7 +213,7 @@
     targ_defvec=bfd_elf32_littlearm_vec
     targ_selvecs=bfd_elf32_bigarm_vec
     ;;
-  armeb-*-elf | arm*b-*-linux-gnu*)
+  armeb-*-elf | arm*b-*-linux-gnu* | armeb-*-openbsd*)
     targ_defvec=bfd_elf32_bigarm_vec
     targ_selvecs=bfd_elf32_littlearm_vec
     ;;
@@ -222,7 +222,7 @@
     targ_selvecs=bfd_elf32_bigarm_vec
     ;;
   arm-*-elf | arm-*-freebsd* | arm*-*-linux-gnu* | arm*-*-conix* | \
-  arm*-*-uclinux* | arm-*-kfreebsd*-gnu | arm-*-vxworks)
+  arm*-*-uclinux* | arm-*-kfreebsd*-gnu | arm-*-vxworks | arm-*-openbsd*)
     targ_defvec=bfd_elf32_littlearm_vec
     targ_selvecs=bfd_elf32_bigarm_vec
     ;;
@@ -360,6 +360,10 @@
     ;;
 
 #ifdef BFD64
+  hppa64*-*-openbsd*)
+    targ_defvec=bfd_elf64_hppa_vec
+    targ_selvecs=bfd_elf64_hppa_linux_vec
+    ;;
   hppa*64*-*-linux-gnu*)
     targ_defvec=bfd_elf64_hppa_linux_vec
     targ_selvecs=bfd_elf64_hppa_vec
@@ -504,10 +508,14 @@
     targ_defvec=bfd_elf64_x86_64_vec
     targ_selvecs="bfd_elf32_i386_vec i386coff_vec bfd_efi_app_ia32_vec"
     ;;
-  x86_64-*-netbsd* | x86_64-*-openbsd*)
+  x86_64-*-netbsd*)
     targ_defvec=bfd_elf64_x86_64_vec
     targ_selvecs="bfd_elf32_i386_vec i386netbsd_vec i386coff_vec bfd_efi_app_ia32_vec"
     ;;
+  x86_64-*-openbsd*)
+    targ_defvec=bfd_elf64_x86_64_vec
+    targ_selvecs="bfd_elf32_i386_vec i386coff_vec bfd_efi_app_ia32_vec"
+    ;;
   x86_64-*-linux-gnu*)
     targ_defvec=bfd_elf64_x86_64_vec
     targ_selvecs="bfd_elf32_i386_vec i386linux_vec bfd_efi_app_ia32_vec"
@@ -746,6 +754,10 @@
     targ_defvec=m88kmach3_vec
     targ_cflags=-DSTAT_FOR_EXEC
     ;;
+  m88k-*-openbsd*)
+    targ_defvec=m88kopenbsd_vec
+    targ_underscore=yes
+    ;;
   m88*-*-*)
     targ_defvec=m88kbcs_vec
     targ_underscore=yes
@@ -764,11 +776,21 @@
     targ_defvec=ecoff_big_vec
     targ_selvecs=ecoff_little_vec
     ;;
-  mips*el-*-netbsd*)
+#ifdef BFD64
+  mips64*el-*-openbsd*)
+    targ_defvec=bfd_elf64_tradlittlemips_vec
+    targ_selvecs="bfd_elf32_ntradlittlemips_vec bfd_elf32_ntradbigmips_vec bfd_elf32_tradlittlemips_vec bfd_elf32_tradbigmips_vec bfd_elf64_tradbigmips_vec"
+    ;;
+  mips64*-*-openbsd*)
+    targ_defvec=bfd_elf64_tradbigmips_vec
+    targ_selvecs="bfd_elf32_ntradlittlemips_vec bfd_elf32_ntradbigmips_vec bfd_elf32_tradlittlemips_vec bfd_elf32_tradbigmips_vec bfd_elf64_tradlittlemips_vec"
+    ;;
+#endif
+  mips*el-*-netbsd* | mipsel-*-openbsd*)
     targ_defvec=bfd_elf32_littlemips_vec
     targ_selvecs="bfd_elf32_bigmips_vec bfd_elf64_bigmips_vec bfd_elf64_littlemips_vec ecoff_little_vec ecoff_big_vec"
     ;;
-  mips*-*-netbsd*)
+  mips*-*-netbsd* | mips-*-openbsd*)
     targ_defvec=bfd_elf32_bigmips_vec
     targ_selvecs="bfd_elf32_littlemips_vec bfd_elf64_bigmips_vec bfd_elf64_littlemips_vec ecoff_big_vec ecoff_little_vec"
     ;;
@@ -818,14 +840,6 @@
     targ_defvec=bfd_elf32_bigmips_vec
     targ_selvecs="bfd_elf32_littlemips_vec bfd_elf64_bigmips_vec bfd_elf64_littlemips_vec"
     ;;
-  mips*el-*-openbsd*)
-    targ_defvec=bfd_elf32_littlemips_vec
-    targ_selvecs="bfd_elf32_bigmips_vec bfd_elf64_bigmips_vec bfd_elf64_littlemips_vec ecoff_little_vec ecoff_big_vec"
-    ;;
-  mips*-*-openbsd*)
-    targ_defvec=bfd_elf32_bigmips_vec
-    targ_selvecs="bfd_elf32_littlemips_vec bfd_elf64_bigmips_vec bfd_elf64_littlemips_vec ecoff_big_vec ecoff_little_vec"
-    ;;
 #ifdef BFD64
   mips64*el-*-linux*)
     targ_defvec=bfd_elf32_ntradlittlemips_vec
@@ -869,7 +883,7 @@
     targ_defvec=pc532machaout_vec
     targ_underscore=yes
     ;;
-  ns32k-*-netbsd* | ns32k-*-lites* | ns32k-*-openbsd*)
+  ns32k-*-netbsd* | ns32k-*-lites*)
     targ_defvec=pc532netbsd_vec
     targ_underscore=yes
     ;;
--- binutils-2.15.orig/bfd/configure
+++ binutils-2.15/bfd/configure
@@ -5288,13 +5288,16 @@
   alpha*-*-*)		COREFILE=osf-core.lo ;;
   arm-*-freebsd* | arm-*-kfreebsd*-gnu)
 			COREFILE='' ;;
-  arm-*-netbsd*)	COREFILE=netbsd-core.lo ;;
+  arm-*-netbsd* | arm-*-openbsd*)
+			COREFILE=netbsd-core.lo ;;
   arm-*-riscix)		COREFILE=trad-core.lo ;;
   hppa*-*-hpux*)	COREFILE=hpux-core.lo ;;
   hppa*-*-hiux*)	COREFILE=hpux-core.lo ;;
   hppa*-*-mpeix*)	COREFILE=hpux-core.lo ;;
   hppa*-*-bsd*)		COREFILE="hpux-core.lo hppabsd-core.lo"
 			COREFLAG="-DHPUX_CORE -DHPPABSD_CORE" ;;
+  hppa*-*-openbsd*)	COREFILE="netbsd-core.lo" ;;
+
   i370-*-*)
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/i370linux.h"'
@@ -5404,11 +5407,14 @@
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/m88kmach3.h"'
 	;;
+  m88*-*-openbsd*)
+	COREFILE=netbsd-core.lo
+	;;
   ns32k-pc532-mach)
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/pc532mach.h"'
 	;;
-  ns32k-*-netbsd* | ns32k-*-openbsd*)
+  ns32k-*-netbsd*)
 	COREFILE=netbsd-core.lo
 	;;
   rs6000-*-lynx*)
@@ -6430,6 +6436,7 @@
     m68ksysvcoff_vec)		tb="$tb coff-svm68k.lo cofflink.lo" ;;
     m88kbcs_vec)		tb="$tb coff-m88k.lo" ;;
     m88kmach3_vec)		tb="$tb m88kmach3.lo aout32.lo" ;;
+    m88kopenbsd_vec)		tb="$tb m88kopenbsd.lo aout32.lo" ;;
     mach_o_be_vec)              tb="$tb mach-o.lo" ;;
     mach_o_le_vec)              tb="$tb mach-o.lo" ;;
     mach_o_fat_vec)             tb="$tb mach-o.lo" ;;
--- binutils-2.15.orig/bfd/configure.in
+++ binutils-2.15/bfd/configure.in
@@ -188,13 +188,16 @@
   alpha*-*-*)		COREFILE=osf-core.lo ;;
   arm-*-freebsd* | arm-*-kfreebsd*-gnu)
 			COREFILE='' ;;
-  arm-*-netbsd*)	COREFILE=netbsd-core.lo ;;
+  arm-*-netbsd* | arm-*-openbsd*)
+			COREFILE=netbsd-core.lo ;;
   arm-*-riscix)		COREFILE=trad-core.lo ;;
   hppa*-*-hpux*)	COREFILE=hpux-core.lo ;;
   hppa*-*-hiux*)	COREFILE=hpux-core.lo ;;
   hppa*-*-mpeix*)	COREFILE=hpux-core.lo ;;
   hppa*-*-bsd*)		COREFILE="hpux-core.lo hppabsd-core.lo"
 			COREFLAG="-DHPUX_CORE -DHPPABSD_CORE" ;;
+  hppa*-*-openbsd*)	COREFILE=netbsd-core.lo ;;
+
   i370-*-*)
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/i370linux.h"'
@@ -328,11 +331,14 @@
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/m88kmach3.h"'
 	;;
+  m88*-*-openbsd*)
+	COREFILE=netbsd-core.lo
+	;;
   ns32k-pc532-mach)
 	COREFILE=trad-core.lo
 	TRAD_HEADER='"hosts/pc532mach.h"'
 	;;
-  ns32k-*-netbsd* | ns32k-*-openbsd*)
+  ns32k-*-netbsd*)
 	COREFILE=netbsd-core.lo
 	;;
   rs6000-*-lynx*)
@@ -739,6 +745,7 @@
     m68ksysvcoff_vec)		tb="$tb coff-svm68k.lo cofflink.lo" ;;
     m88kbcs_vec)		tb="$tb coff-m88k.lo" ;;
     m88kmach3_vec)		tb="$tb m88kmach3.lo aout32.lo" ;;
+    m88kopenbsd_vec)		tb="$tb m88kopenbsd.lo aout32.lo" ;;
     mach_o_be_vec)              tb="$tb mach-o.lo" ;;
     mach_o_le_vec)              tb="$tb mach-o.lo" ;;
     mach_o_fat_vec)             tb="$tb mach-o.lo" ;;
--- binutils-2.15.orig/bfd/elf.c
+++ binutils-2.15/bfd/elf.c
@@ -4103,9 +4103,12 @@
       return elf_tdata (abfd)->program_header_size;
     }
 
-  /* Assume we will need exactly two PT_LOAD segments: one for text
-     and one for data.  */
-  segs = 2;
+  /* We used to assume that two PT_LOAD segments would be enough,
+     code and data, with the change to pad the PLT and GOT, this is no
+     longer true. Now there can be several PT_LOAD sections. 7 seems
+     to be enough with BSS_PLT and .rodata-X, where we have text, data,
+     GOT, dynamic, PLT, bss */
+  segs = 7;
 
   s = bfd_get_section_by_name (abfd, ".interp");
   if (s != NULL && (s->flags & SEC_LOAD) != 0)
@@ -4318,6 +4321,8 @@
     bfd_big_endian (abfd) ? ELFDATA2MSB : ELFDATA2LSB;
   i_ehdrp->e_ident[EI_VERSION] = bed->s->ev_current;
 
+  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_OPENBSD;
+
   if ((abfd->flags & DYNAMIC) != 0)
     i_ehdrp->e_type = ET_DYN;
   else if ((abfd->flags & EXEC_P) != 0)
--- binutils-2.15.orig/bfd/elf32-arm.h
+++ binutils-2.15/bfd/elf32-arm.h
@@ -3092,6 +3092,7 @@
   asymbol *func;
   bfd_vma low_func;
   asymbol **p;
+  int binding;
 
   if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
 				     filename_ptr, functionname_ptr,
@@ -3114,6 +3115,7 @@
   filename = NULL;
   func = NULL;
   low_func = 0;
+  binding = -1;
 
   for (p = symbols; *p != NULL; p++)
     {
@@ -3138,8 +3140,14 @@
 	      && q->symbol.value >= low_func
 	      && q->symbol.value <= offset)
 	    {
-	      func = (asymbol *) q;
-	      low_func = q->symbol.value;
+	      /* Prefer a global symbol rather than $a/$d/$t local symbols */
+	      if (ELF_ST_BIND (q->internal_elf_sym.st_info) != STB_LOCAL
+		  || binding == -1)
+		{
+		  func = (asymbol *) q;
+		  low_func = q->symbol.value;
+		  binding = ELF_ST_BIND (q->internal_elf_sym.st_info);
+		}
 	    }
 	  break;
 	}
--- binutils-2.15.orig/bfd/elflink.c
+++ binutils-2.15/bfd/elflink.c
@@ -2918,8 +2918,6 @@
 	    {
 	      char *msg;
 	      bfd_size_type sz;
-	      bfd_size_type prefix_len;
-	      const char * gnu_warning_prefix = _("warning: ");
 
 	      name += sizeof ".gnu.warning." - 1;
 
@@ -2953,16 +2951,14 @@
 		}
 
 	      sz = bfd_section_size (abfd, s);
-	      prefix_len = strlen (gnu_warning_prefix);
-	      msg = bfd_alloc (abfd, prefix_len + sz + 1);
+	      msg = bfd_alloc (abfd, sz + 1);
 	      if (msg == NULL)
 		goto error_return;
 
-	      strcpy (msg, gnu_warning_prefix);
-	      if (! bfd_get_section_contents (abfd, s, msg + prefix_len, 0, sz))
+	      if (! bfd_get_section_contents (abfd, s, msg, 0, sz))
 		goto error_return;
 
-	      msg[prefix_len + sz] = '\0';
+	      msg[sz] = '\0';
 
 	      if (! (_bfd_generic_link_add_one_symbol
 		     (info, abfd, name, BSF_WARNING, s, 0, msg,
--- binutils-2.15.orig/bfd/elflink.h
+++ binutils-2.15/bfd/elflink.h
@@ -0,0 +1,8745 @@
+/* ELF linker support.
+   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* ELF linker code.  */
+
+/* This struct is used to pass information to routines called via
+   elf_link_hash_traverse which must return failure.  */
+
+struct elf_info_failed
+{
+  bfd_boolean failed;
+  struct bfd_link_info *info;
+  struct bfd_elf_version_tree *verdefs;
+};
+
+static bfd_boolean is_global_data_symbol_definition
+  PARAMS ((bfd *, Elf_Internal_Sym *));
+static bfd_boolean elf_link_is_defined_archive_symbol
+  PARAMS ((bfd *, carsym *));
+static bfd_boolean elf_link_add_object_symbols
+  PARAMS ((bfd *, struct bfd_link_info *));
+static bfd_boolean elf_link_add_archive_symbols
+  PARAMS ((bfd *, struct bfd_link_info *));
+static bfd_boolean elf_merge_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, const char *,
+	   Elf_Internal_Sym *, asection **, bfd_vma *,
+	   struct elf_link_hash_entry **, bfd_boolean *, bfd_boolean *,
+	   bfd_boolean *, bfd_boolean *, bfd_boolean));
+static bfd_boolean elf_add_default_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
+	   const char *, Elf_Internal_Sym *, asection **, bfd_vma *,
+	   bfd_boolean *, bfd_boolean, bfd_boolean));
+static bfd_boolean elf_export_symbol
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static bfd_boolean elf_finalize_dynstr
+  PARAMS ((bfd *, struct bfd_link_info *));
+static bfd_boolean elf_fix_symbol_flags
+  PARAMS ((struct elf_link_hash_entry *, struct elf_info_failed *));
+static bfd_boolean elf_adjust_dynamic_symbol
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static bfd_boolean elf_link_find_version_dependencies
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static bfd_boolean elf_link_assign_sym_version
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static bfd_boolean elf_collect_hash_codes
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static bfd_boolean elf_link_read_relocs_from_section
+  PARAMS ((bfd *, Elf_Internal_Shdr *, PTR, Elf_Internal_Rela *));
+static size_t compute_bucket_count
+  PARAMS ((struct bfd_link_info *));
+static bfd_boolean elf_link_output_relocs
+  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *));
+static bfd_boolean elf_link_size_reloc_section
+  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
+static void elf_link_adjust_relocs
+  PARAMS ((bfd *, Elf_Internal_Shdr *, unsigned int,
+	   struct elf_link_hash_entry **));
+static int elf_link_sort_cmp1
+  PARAMS ((const void *, const void *));
+static int elf_link_sort_cmp2
+  PARAMS ((const void *, const void *));
+static size_t elf_link_sort_relocs
+  PARAMS ((bfd *, struct bfd_link_info *, asection **));
+static bfd_boolean elf_section_ignore_discarded_relocs
+  PARAMS ((asection *));
+
+/* Given an ELF BFD, add symbols to the global hash table as
+   appropriate.  */
+
+bfd_boolean
+elf_bfd_link_add_symbols (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  switch (bfd_get_format (abfd))
+    {
+    case bfd_object:
+      return elf_link_add_object_symbols (abfd, info);
+    case bfd_archive:
+      return elf_link_add_archive_symbols (abfd, info);
+    default:
+      bfd_set_error (bfd_error_wrong_format);
+      return FALSE;
+    }
+}
+
+/* Return TRUE iff this is a non-common, definition of a non-function symbol.  */
+static bfd_boolean
+is_global_data_symbol_definition (abfd, sym)
+     bfd * abfd ATTRIBUTE_UNUSED;
+     Elf_Internal_Sym * sym;
+{
+  /* Local symbols do not count, but target specific ones might.  */
+  if (ELF_ST_BIND (sym->st_info) != STB_GLOBAL
+      && ELF_ST_BIND (sym->st_info) < STB_LOOS)
+    return FALSE;
+
+  /* Function symbols do not count.  */
+  if (ELF_ST_TYPE (sym->st_info) == STT_FUNC)
+    return FALSE;
+
+  /* If the section is undefined, then so is the symbol.  */
+  if (sym->st_shndx == SHN_UNDEF)
+    return FALSE;
+
+  /* If the symbol is defined in the common section, then
+     it is a common definition and so does not count.  */
+  if (sym->st_shndx == SHN_COMMON)
+    return FALSE;
+
+  /* If the symbol is in a target specific section then we
+     must rely upon the backend to tell us what it is.  */
+  if (sym->st_shndx >= SHN_LORESERVE && sym->st_shndx < SHN_ABS)
+    /* FIXME - this function is not coded yet:
+
+       return _bfd_is_global_symbol_definition (abfd, sym);
+
+       Instead for now assume that the definition is not global,
+       Even if this is wrong, at least the linker will behave
+       in the same way that it used to do.  */
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Search the symbol table of the archive element of the archive ABFD
+   whose archive map contains a mention of SYMDEF, and determine if
+   the symbol is defined in this element.  */
+static bfd_boolean
+elf_link_is_defined_archive_symbol (abfd, symdef)
+     bfd * abfd;
+     carsym * symdef;
+{
+  Elf_Internal_Shdr * hdr;
+  bfd_size_type symcount;
+  bfd_size_type extsymcount;
+  bfd_size_type extsymoff;
+  Elf_Internal_Sym *isymbuf;
+  Elf_Internal_Sym *isym;
+  Elf_Internal_Sym *isymend;
+  bfd_boolean result;
+
+  abfd = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
+  if (abfd == (bfd *) NULL)
+    return FALSE;
+
+  if (! bfd_check_format (abfd, bfd_object))
+    return FALSE;
+
+  /* If we have already included the element containing this symbol in the
+     link then we do not need to include it again.  Just claim that any symbol
+     it contains is not a definition, so that our caller will not decide to
+     (re)include this element.  */
+  if (abfd->archive_pass)
+    return FALSE;
+
+  /* Select the appropriate symbol table.  */
+  if ((abfd->flags & DYNAMIC) == 0 || elf_dynsymtab (abfd) == 0)
+    hdr = &elf_tdata (abfd)->symtab_hdr;
+  else
+    hdr = &elf_tdata (abfd)->dynsymtab_hdr;
+
+  symcount = hdr->sh_size / sizeof (Elf_External_Sym);
+
+  /* The sh_info field of the symtab header tells us where the
+     external symbols start.  We don't care about the local symbols.  */
+  if (elf_bad_symtab (abfd))
+    {
+      extsymcount = symcount;
+      extsymoff = 0;
+    }
+  else
+    {
+      extsymcount = symcount - hdr->sh_info;
+      extsymoff = hdr->sh_info;
+    }
+
+  if (extsymcount == 0)
+    return FALSE;
+
+  /* Read in the symbol table.  */
+  isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
+				  NULL, NULL, NULL);
+  if (isymbuf == NULL)
+    return FALSE;
+
+  /* Scan the symbol table looking for SYMDEF.  */
+  result = FALSE;
+  for (isym = isymbuf, isymend = isymbuf + extsymcount; isym < isymend; isym++)
+    {
+      const char *name;
+
+      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
+					      isym->st_name);
+      if (name == (const char *) NULL)
+	break;
+
+      if (strcmp (name, symdef->name) == 0)
+	{
+	  result = is_global_data_symbol_definition (abfd, isym);
+	  break;
+	}
+    }
+
+  free (isymbuf);
+
+  return result;
+}
+
+/* Add symbols from an ELF archive file to the linker hash table.  We
+   don't use _bfd_generic_link_add_archive_symbols because of a
+   problem which arises on UnixWare.  The UnixWare libc.so is an
+   archive which includes an entry libc.so.1 which defines a bunch of
+   symbols.  The libc.so archive also includes a number of other
+   object files, which also define symbols, some of which are the same
+   as those defined in libc.so.1.  Correct linking requires that we
+   consider each object file in turn, and include it if it defines any
+   symbols we need.  _bfd_generic_link_add_archive_symbols does not do
+   this; it looks through the list of undefined symbols, and includes
+   any object file which defines them.  When this algorithm is used on
+   UnixWare, it winds up pulling in libc.so.1 early and defining a
+   bunch of symbols.  This means that some of the other objects in the
+   archive are not included in the link, which is incorrect since they
+   precede libc.so.1 in the archive.
+
+   Fortunately, ELF archive handling is simpler than that done by
+   _bfd_generic_link_add_archive_symbols, which has to allow for a.out
+   oddities.  In ELF, if we find a symbol in the archive map, and the
+   symbol is currently undefined, we know that we must pull in that
+   object file.
+
+   Unfortunately, we do have to make multiple passes over the symbol
+   table until nothing further is resolved.  */
+
+static bfd_boolean
+elf_link_add_archive_symbols (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  symindex c;
+  bfd_boolean *defined = NULL;
+  bfd_boolean *included = NULL;
+  carsym *symdefs;
+  bfd_boolean loop;
+  bfd_size_type amt;
+
+  if (! bfd_has_map (abfd))
+    {
+      /* An empty archive is a special case.  */
+      if (bfd_openr_next_archived_file (abfd, (bfd *) NULL) == NULL)
+	return TRUE;
+      bfd_set_error (bfd_error_no_armap);
+      return FALSE;
+    }
+
+  /* Keep track of all symbols we know to be already defined, and all
+     files we know to be already included.  This is to speed up the
+     second and subsequent passes.  */
+  c = bfd_ardata (abfd)->symdef_count;
+  if (c == 0)
+    return TRUE;
+  amt = c;
+  amt *= sizeof (bfd_boolean);
+  defined = (bfd_boolean *) bfd_zmalloc (amt);
+  included = (bfd_boolean *) bfd_zmalloc (amt);
+  if (defined == (bfd_boolean *) NULL || included == (bfd_boolean *) NULL)
+    goto error_return;
+
+  symdefs = bfd_ardata (abfd)->symdefs;
+
+  do
+    {
+      file_ptr last;
+      symindex i;
+      carsym *symdef;
+      carsym *symdefend;
+
+      loop = FALSE;
+      last = -1;
+
+      symdef = symdefs;
+      symdefend = symdef + c;
+      for (i = 0; symdef < symdefend; symdef++, i++)
+	{
+	  struct elf_link_hash_entry *h;
+	  bfd *element;
+	  struct bfd_link_hash_entry *undefs_tail;
+	  symindex mark;
+
+	  if (defined[i] || included[i])
+	    continue;
+	  if (symdef->file_offset == last)
+	    {
+	      included[i] = TRUE;
+	      continue;
+	    }
+
+	  h = elf_link_hash_lookup (elf_hash_table (info), symdef->name,
+				    FALSE, FALSE, FALSE);
+
+	  if (h == NULL)
+	    {
+	      char *p, *copy;
+	      size_t len, first;
+
+	      /* If this is a default version (the name contains @@),
+		 look up the symbol again with only one `@' as well
+		 as without the version.  The effect is that references
+		 to the symbol with and without the version will be
+		 matched by the default symbol in the archive.  */
+
+	      p = strchr (symdef->name, ELF_VER_CHR);
+	      if (p == NULL || p[1] != ELF_VER_CHR)
+		continue;
+
+	      /* First check with only one `@'.  */
+	      len = strlen (symdef->name);
+	      copy = bfd_alloc (abfd, (bfd_size_type) len);
+	      if (copy == NULL)
+		goto error_return;
+	      first = p - symdef->name + 1;
+	      memcpy (copy, symdef->name, first);
+	      memcpy (copy + first, symdef->name + first + 1, len - first);
+
+	      h = elf_link_hash_lookup (elf_hash_table (info), copy,
+					FALSE, FALSE, FALSE);
+
+	      if (h == NULL)
+		{
+		  /* We also need to check references to the symbol
+		     without the version.  */
+
+		  copy[first - 1] = '\0';
+		  h = elf_link_hash_lookup (elf_hash_table (info),
+					    copy, FALSE, FALSE, FALSE);
+		}
+
+	      bfd_release (abfd, copy);
+	    }
+
+	  if (h == NULL)
+	    continue;
+
+	  if (h->root.type == bfd_link_hash_common)
+	    {
+	      /* We currently have a common symbol.  The archive map contains
+		 a reference to this symbol, so we may want to include it.  We
+		 only want to include it however, if this archive element
+		 contains a definition of the symbol, not just another common
+		 declaration of it.
+
+		 Unfortunately some archivers (including GNU ar) will put
+		 declarations of common symbols into their archive maps, as
+		 well as real definitions, so we cannot just go by the archive
+		 map alone.  Instead we must read in the element's symbol
+		 table and check that to see what kind of symbol definition
+		 this is.  */
+	      if (! elf_link_is_defined_archive_symbol (abfd, symdef))
+		continue;
+	    }
+	  else if (h->root.type != bfd_link_hash_undefined)
+	    {
+	      if (h->root.type != bfd_link_hash_undefweak)
+		defined[i] = TRUE;
+	      continue;
+	    }
+
+	  /* We need to include this archive member.  */
+	  element = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
+	  if (element == (bfd *) NULL)
+	    goto error_return;
+
+	  if (! bfd_check_format (element, bfd_object))
+	    goto error_return;
+
+	  /* Doublecheck that we have not included this object
+	     already--it should be impossible, but there may be
+	     something wrong with the archive.  */
+	  if (element->archive_pass != 0)
+	    {
+	      bfd_set_error (bfd_error_bad_value);
+	      goto error_return;
+	    }
+	  element->archive_pass = 1;
+
+	  undefs_tail = info->hash->undefs_tail;
+
+	  if (! (*info->callbacks->add_archive_element) (info, element,
+							 symdef->name))
+	    goto error_return;
+	  if (! elf_link_add_object_symbols (element, info))
+	    goto error_return;
+
+	  /* If there are any new undefined symbols, we need to make
+	     another pass through the archive in order to see whether
+	     they can be defined.  FIXME: This isn't perfect, because
+	     common symbols wind up on undefs_tail and because an
+	     undefined symbol which is defined later on in this pass
+	     does not require another pass.  This isn't a bug, but it
+	     does make the code less efficient than it could be.  */
+	  if (undefs_tail != info->hash->undefs_tail)
+	    loop = TRUE;
+
+	  /* Look backward to mark all symbols from this object file
+	     which we have already seen in this pass.  */
+	  mark = i;
+	  do
+	    {
+	      included[mark] = TRUE;
+	      if (mark == 0)
+		break;
+	      --mark;
+	    }
+	  while (symdefs[mark].file_offset == symdef->file_offset);
+
+	  /* We mark subsequent symbols from this object file as we go
+	     on through the loop.  */
+	  last = symdef->file_offset;
+	}
+    }
+  while (loop);
+
+  free (defined);
+  free (included);
+
+  return TRUE;
+
+ error_return:
+  if (defined != (bfd_boolean *) NULL)
+    free (defined);
+  if (included != (bfd_boolean *) NULL)
+    free (included);
+  return FALSE;
+}
+
+/* This function is called when we want to define a new symbol.  It
+   handles the various cases which arise when we find a definition in
+   a dynamic object, or when there is already a definition in a
+   dynamic object.  The new symbol is described by NAME, SYM, PSEC,
+   and PVALUE.  We set SYM_HASH to the hash table entry.  We set
+   OVERRIDE if the old symbol is overriding a new definition.  We set
+   TYPE_CHANGE_OK if it is OK for the type to change.  We set
+   SIZE_CHANGE_OK if it is OK for the size to change.  By OK to
+   change, we mean that we shouldn't warn if the type or size does
+   change. DT_NEEDED indicates if it comes from a DT_NEEDED entry of
+   a shared object.  */
+
+static bfd_boolean
+elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash, skip,
+		  override, type_change_ok, size_change_ok, dt_needed)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     const char *name;
+     Elf_Internal_Sym *sym;
+     asection **psec;
+     bfd_vma *pvalue;
+     struct elf_link_hash_entry **sym_hash;
+     bfd_boolean *skip;
+     bfd_boolean *override;
+     bfd_boolean *type_change_ok;
+     bfd_boolean *size_change_ok;
+     bfd_boolean dt_needed;
+{
+  asection *sec;
+  struct elf_link_hash_entry *h;
+  struct elf_link_hash_entry *flip;
+  int bind;
+  bfd *oldbfd;
+  bfd_boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
+  bfd_boolean newweakdef, oldweakdef, newweakundef, oldweakundef;
+
+  *skip = FALSE;
+  *override = FALSE;
+
+  sec = *psec;
+  bind = ELF_ST_BIND (sym->st_info);
+
+  if (! bfd_is_und_section (sec))
+    h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, FALSE, FALSE);
+  else
+    h = ((struct elf_link_hash_entry *)
+	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, FALSE, FALSE));
+  if (h == NULL)
+    return FALSE;
+  *sym_hash = h;
+
+  /* This code is for coping with dynamic objects, and is only useful
+     if we are doing an ELF link.  */
+  if (info->hash->creator != abfd->xvec)
+    return TRUE;
+
+  /* For merging, we only care about real symbols.  */
+
+  while (h->root.type == bfd_link_hash_indirect
+	 || h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* If we just created the symbol, mark it as being an ELF symbol.
+     Other than that, there is nothing to do--there is no merge issue
+     with a newly defined symbol--so we just return.  */
+
+  if (h->root.type == bfd_link_hash_new)
+    {
+      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
+      return TRUE;
+    }
+
+  /* OLDBFD is a BFD associated with the existing symbol.  */
+
+  switch (h->root.type)
+    {
+    default:
+      oldbfd = NULL;
+      break;
+
+    case bfd_link_hash_undefined:
+    case bfd_link_hash_undefweak:
+      oldbfd = h->root.u.undef.abfd;
+      break;
+
+    case bfd_link_hash_defined:
+    case bfd_link_hash_defweak:
+      oldbfd = h->root.u.def.section->owner;
+      break;
+
+    case bfd_link_hash_common:
+      oldbfd = h->root.u.c.p->section->owner;
+      break;
+    }
+
+  /* In cases involving weak versioned symbols, we may wind up trying
+     to merge a symbol with itself.  Catch that here, to avoid the
+     confusion that results if we try to override a symbol with
+     itself.  The additional tests catch cases like
+     _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a
+     dynamic object, which we do want to handle here.  */
+  if (abfd == oldbfd
+      && ((abfd->flags & DYNAMIC) == 0
+	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
+    return TRUE;
+
+  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
+     respectively, is from a dynamic object.  */
+
+  if ((abfd->flags & DYNAMIC) != 0)
+    newdyn = TRUE;
+  else
+    newdyn = FALSE;
+
+  if (oldbfd != NULL)
+    olddyn = (oldbfd->flags & DYNAMIC) != 0;
+  else
+    {
+      asection *hsec;
+
+      /* This code handles the special SHN_MIPS_{TEXT,DATA} section
+	 indices used by MIPS ELF.  */
+      switch (h->root.type)
+	{
+	default:
+	  hsec = NULL;
+	  break;
+
+	case bfd_link_hash_defined:
+	case bfd_link_hash_defweak:
+	  hsec = h->root.u.def.section;
+	  break;
+
+	case bfd_link_hash_common:
+	  hsec = h->root.u.c.p->section;
+	  break;
+	}
+
+      if (hsec == NULL)
+	olddyn = FALSE;
+      else
+	olddyn = (hsec->symbol->flags & BSF_DYNAMIC) != 0;
+    }
+
+  /* NEWDEF and OLDDEF indicate whether the new or old symbol,
+     respectively, appear to be a definition rather than reference.  */
+
+  if (bfd_is_und_section (sec) || bfd_is_com_section (sec))
+    newdef = FALSE;
+  else
+    newdef = TRUE;
+
+  if (h->root.type == bfd_link_hash_undefined
+      || h->root.type == bfd_link_hash_undefweak
+      || h->root.type == bfd_link_hash_common)
+    olddef = FALSE;
+  else
+    olddef = TRUE;
+
+  /* We need to rememeber if a symbol has a definition in a dynamic
+     object or is weak in all dynamic objects. Internal and hidden
+     visibility will make it unavailable to dynamic objects.  */
+  if (newdyn && (h->elf_link_hash_flags & ELF_LINK_DYNAMIC_DEF) == 0)
+    {
+      if (!bfd_is_und_section (sec))
+	h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_DEF;
+      else
+	{
+	  /* Check if this symbol is weak in all dynamic objects. If it
+	     is the first time we see it in a dynamic object, we mark
+	     if it is weak. Otherwise, we clear it.  */
+	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
+	    { 
+	      if (bind == STB_WEAK)
+		h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_WEAK;
+	    }
+	  else if (bind != STB_WEAK)
+	    h->elf_link_hash_flags &= ~ELF_LINK_DYNAMIC_WEAK;
+	}
+    }
+
+  /* If the old symbol has non-default visibility, we ignore the new
+     definition from a dynamic object.  */
+  if (newdyn
+      && ELF_ST_VISIBILITY (h->other)
+      && !bfd_is_und_section (sec))
+    {
+      *skip = TRUE;
+      /* Make sure this symbol is dynamic.  */
+      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
+      /* A protected symbol has external availability. Make sure it is
+	 recorded as dynamic.
+
+	 FIXME: Should we check type and size for protected symbol?  */
+      if (ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
+	return _bfd_elf_link_record_dynamic_symbol (info, h);
+      else
+	return TRUE;
+    }
+  else if (!newdyn
+	   && ELF_ST_VISIBILITY (sym->st_other)
+	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
+    {
+      /* If the new symbol with non-default visibility comes from a
+	 relocatable file and the old definition comes from a dynamic
+	 object, we remove the old definition.  */
+      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
+	h = *sym_hash;
+      h->root.type = bfd_link_hash_new;
+      h->root.u.undef.abfd = NULL;
+      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
+	{
+	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
+	  h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_DYNAMIC
+				     | ELF_LINK_DYNAMIC_DEF);
+	}
+      /* FIXME: Should we check type and size for protected symbol?  */
+      h->size = 0;
+      h->type = 0;
+      return TRUE;
+    }
+
+  /* We need to treat weak definiton right, depending on if there is a
+     definition from a dynamic object.  */
+  if (bind == STB_WEAK)
+    {
+      if (olddef)
+	{
+	   newweakdef = TRUE;
+	   newweakundef = FALSE;
+	}
+      else
+	{
+	   newweakdef = FALSE;
+	   newweakundef = TRUE;
+	}
+    }
+  else
+    newweakdef = newweakundef = FALSE;
+
+  /* If the new weak definition comes from a relocatable file and the
+     old symbol comes from a dynamic object, we treat the new one as
+     strong.  */
+  if (newweakdef && !newdyn && olddyn)
+    newweakdef = FALSE;
+
+  if (h->root.type == bfd_link_hash_defweak)
+    {
+      oldweakdef = TRUE;
+      oldweakundef = FALSE;
+    }
+  else if (h->root.type == bfd_link_hash_undefweak)
+    {
+      oldweakdef = FALSE;
+      oldweakundef = TRUE;
+    }
+  else
+    oldweakdef = oldweakundef = FALSE;
+
+  /* If the old weak definition comes from a relocatable file and the
+     new symbol comes from a dynamic object, we treat the old one as
+     strong.  */
+  if (oldweakdef && !olddyn && newdyn)
+    oldweakdef = FALSE;
+
+  /* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old
+     symbol, respectively, appears to be a common symbol in a dynamic
+     object.  If a symbol appears in an uninitialized section, and is
+     not weak, and is not a function, then it may be a common symbol
+     which was resolved when the dynamic object was created.  We want
+     to treat such symbols specially, because they raise special
+     considerations when setting the symbol size: if the symbol
+     appears as a common symbol in a regular object, and the size in
+     the regular object is larger, we must make sure that we use the
+     larger size.  This problematic case can always be avoided in C,
+     but it must be handled correctly when using Fortran shared
+     libraries.
+
+     Note that if NEWDYNCOMMON is set, NEWDEF will be set, and
+     likewise for OLDDYNCOMMON and OLDDEF.
+
+     Note that this test is just a heuristic, and that it is quite
+     possible to have an uninitialized symbol in a shared object which
+     is really a definition, rather than a common symbol.  This could
+     lead to some minor confusion when the symbol really is a common
+     symbol in some regular object.  However, I think it will be
+     harmless.  */
+
+  if (newdyn
+      && newdef
+      && (sec->flags & SEC_ALLOC) != 0
+      && (sec->flags & SEC_LOAD) == 0
+      && sym->st_size > 0
+      && !newweakdef
+      && !newweakundef
+      && ELF_ST_TYPE (sym->st_info) != STT_FUNC)
+    newdyncommon = TRUE;
+  else
+    newdyncommon = FALSE;
+
+  if (olddyn
+      && olddef
+      && h->root.type == bfd_link_hash_defined
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
+      && (h->root.u.def.section->flags & SEC_LOAD) == 0
+      && h->size > 0
+      && h->type != STT_FUNC)
+    olddyncommon = TRUE;
+  else
+    olddyncommon = FALSE;
+
+  /* It's OK to change the type if either the existing symbol or the
+     new symbol is weak unless it comes from a DT_NEEDED entry of
+     a shared object, in which case, the DT_NEEDED entry may not be
+     required at the run time.  */
+
+  if ((! dt_needed && oldweakdef)
+      || oldweakundef
+      || newweakdef
+      || newweakundef)
+    *type_change_ok = TRUE;
+
+  /* It's OK to change the size if either the existing symbol or the
+     new symbol is weak, or if the old symbol is undefined.  */
+
+  if (*type_change_ok
+      || h->root.type == bfd_link_hash_undefined)
+    *size_change_ok = TRUE;
+
+  /* If both the old and the new symbols look like common symbols in a
+     dynamic object, set the size of the symbol to the larger of the
+     two.  */
+
+  if (olddyncommon
+      && newdyncommon
+      && sym->st_size != h->size)
+    {
+      /* Since we think we have two common symbols, issue a multiple
+	 common warning if desired.  Note that we only warn if the
+	 size is different.  If the size is the same, we simply let
+	 the old symbol override the new one as normally happens with
+	 symbols defined in dynamic objects.  */
+
+      if (! ((*info->callbacks->multiple_common)
+	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
+	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
+	return FALSE;
+
+      if (sym->st_size > h->size)
+	h->size = sym->st_size;
+
+      *size_change_ok = TRUE;
+    }
+
+  /* If we are looking at a dynamic object, and we have found a
+     definition, we need to see if the symbol was already defined by
+     some other object.  If so, we want to use the existing
+     definition, and we do not want to report a multiple symbol
+     definition error; we do this by clobbering *PSEC to be
+     bfd_und_section_ptr.
+
+     We treat a common symbol as a definition if the symbol in the
+     shared library is a function, since common symbols always
+     represent variables; this can cause confusion in principle, but
+     any such confusion would seem to indicate an erroneous program or
+     shared library.  We also permit a common symbol in a regular
+     object to override a weak symbol in a shared object.
+
+     We prefer a non-weak definition in a shared library to a weak
+     definition in the executable unless it comes from a DT_NEEDED
+     entry of a shared object, in which case, the DT_NEEDED entry
+     may not be required at the run time.  */
+
+  if (newdyn
+      && newdef
+      && (olddef
+	  || (h->root.type == bfd_link_hash_common
+	      && (newweakdef
+		  || newweakundef
+		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC)))
+      && (!oldweakdef
+	  || dt_needed
+	  || newweakdef
+	  || newweakundef))
+    {
+      *override = TRUE;
+      newdef = FALSE;
+      newdyncommon = FALSE;
+
+      *psec = sec = bfd_und_section_ptr;
+      *size_change_ok = TRUE;
+
+      /* If we get here when the old symbol is a common symbol, then
+	 we are explicitly letting it override a weak symbol or
+	 function in a dynamic object, and we don't want to warn about
+	 a type change.  If the old symbol is a defined symbol, a type
+	 change warning may still be appropriate.  */
+
+      if (h->root.type == bfd_link_hash_common)
+	*type_change_ok = TRUE;
+    }
+
+  /* Handle the special case of an old common symbol merging with a
+     new symbol which looks like a common symbol in a shared object.
+     We change *PSEC and *PVALUE to make the new symbol look like a
+     common symbol, and let _bfd_generic_link_add_one_symbol will do
+     the right thing.  */
+
+  if (newdyncommon
+      && h->root.type == bfd_link_hash_common)
+    {
+      *override = TRUE;
+      newdef = FALSE;
+      newdyncommon = FALSE;
+      *pvalue = sym->st_size;
+      *psec = sec = bfd_com_section_ptr;
+      *size_change_ok = TRUE;
+    }
+
+  /* If the old symbol is from a dynamic object, and the new symbol is
+     a definition which is not from a dynamic object, then the new
+     symbol overrides the old symbol.  Symbols from regular files
+     always take precedence over symbols from dynamic objects, even if
+     they are defined after the dynamic object in the link.
+
+     As above, we again permit a common symbol in a regular object to
+     override a definition in a shared object if the shared object
+     symbol is a function or is weak.
+
+     As above, we permit a non-weak definition in a shared object to
+     override a weak definition in a regular object.  */
+
+  flip = NULL;
+  if (! newdyn
+      && (newdef
+	  || (bfd_is_com_section (sec)
+	      && (oldweakdef || h->type == STT_FUNC)))
+      && olddyn
+      && olddef
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+      && ((!newweakdef && !newweakundef) || oldweakdef))
+    {
+      /* Change the hash table entry to undefined, and let
+	 _bfd_generic_link_add_one_symbol do the right thing with the
+	 new definition.  */
+
+      h->root.type = bfd_link_hash_undefined;
+      h->root.u.undef.abfd = h->root.u.def.section->owner;
+      *size_change_ok = TRUE;
+
+      olddef = FALSE;
+      olddyncommon = FALSE;
+
+      /* We again permit a type change when a common symbol may be
+	 overriding a function.  */
+
+      if (bfd_is_com_section (sec))
+	*type_change_ok = TRUE;
+
+      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
+	flip = *sym_hash;
+      else
+	/* This union may have been set to be non-NULL when this symbol
+	   was seen in a dynamic object.  We must force the union to be
+	   NULL, so that it is correct for a regular symbol.  */
+	h->verinfo.vertree = NULL;
+    }
+
+  /* Handle the special case of a new common symbol merging with an
+     old symbol that looks like it might be a common symbol defined in
+     a shared object.  Note that we have already handled the case in
+     which a new common symbol should simply override the definition
+     in the shared library.  */
+
+  if (! newdyn
+      && bfd_is_com_section (sec)
+      && olddyncommon)
+    {
+      /* It would be best if we could set the hash table entry to a
+	 common symbol, but we don't know what to use for the section
+	 or the alignment.  */
+      if (! ((*info->callbacks->multiple_common)
+	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
+	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
+	return FALSE;
+
+      /* If the predumed common symbol in the dynamic object is
+	 larger, pretend that the new symbol has its size.  */
+
+      if (h->size > *pvalue)
+	*pvalue = h->size;
+
+      /* FIXME: We no longer know the alignment required by the symbol
+	 in the dynamic object, so we just wind up using the one from
+	 the regular object.  */
+
+      olddef = FALSE;
+      olddyncommon = FALSE;
+
+      h->root.type = bfd_link_hash_undefined;
+      h->root.u.undef.abfd = h->root.u.def.section->owner;
+
+      *size_change_ok = TRUE;
+      *type_change_ok = TRUE;
+
+      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
+	flip = *sym_hash;
+      else
+	h->verinfo.vertree = NULL;
+    }
+
+  if (flip != NULL)
+    {
+      /* Handle the case where we had a versioned symbol in a dynamic
+	 library and now find a definition in a normal object.  In this
+	 case, we make the versioned symbol point to the normal one.  */
+      struct elf_backend_data *bed = get_elf_backend_data (abfd);
+      flip->root.type = h->root.type;
+      h->root.type = bfd_link_hash_indirect;
+      h->root.u.i.link = (struct bfd_link_hash_entry *) flip;
+      (*bed->elf_backend_copy_indirect_symbol) (bed, flip, h);
+      flip->root.u.undef.abfd = h->root.u.undef.abfd;
+      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
+	{
+	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
+	  flip->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
+	}
+    }
+
+  /* Handle the special case of a weak definition in a regular object
+     followed by a non-weak definition in a shared object.  In this
+     case, we prefer the definition in the shared object unless it
+     comes from a DT_NEEDED entry of a shared object, in which case,
+     the DT_NEEDED entry may not be required at the run time.  */
+  if (olddef
+      && ! dt_needed
+      && oldweakdef
+      && newdef
+      && newdyn
+      && !newweakdef
+      && !newweakundef)
+    {
+      /* To make this work we have to frob the flags so that the rest
+	 of the code does not think we are using the regular
+	 definition.  */
+      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
+	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
+      else if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
+	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
+      h->elf_link_hash_flags &= ~ (ELF_LINK_HASH_DEF_REGULAR
+				   | ELF_LINK_HASH_DEF_DYNAMIC);
+
+      /* If H is the target of an indirection, we want the caller to
+	 use H rather than the indirect symbol.  Otherwise if we are
+	 defining a new indirect symbol we will wind up attaching it
+	 to the entry we are overriding.  */
+      *sym_hash = h;
+    }
+
+  /* Handle the special case of a non-weak definition in a shared
+     object followed by a weak definition in a regular object.  In
+     this case we prefer the definition in the shared object.  To make
+     this work we have to tell the caller to not treat the new symbol
+     as a definition.  */
+  if (olddef
+      && olddyn
+      && !oldweakdef
+      && newdef
+      && ! newdyn
+      && (newweakdef || newweakundef))
+    *override = TRUE;
+
+  return TRUE;
+}
+
+/* This function is called to create an indirect symbol from the
+   default for the symbol with the default version if needed. The
+   symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We
+   set DYNSYM if the new indirect symbol is dynamic. DT_NEEDED
+   indicates if it comes from a DT_NEEDED entry of a shared object.  */
+
+static bfd_boolean
+elf_add_default_symbol (abfd, info, h, name, sym, psec, value,
+			dynsym, override, dt_needed)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *h;
+     const char *name;
+     Elf_Internal_Sym *sym;
+     asection **psec;
+     bfd_vma *value;
+     bfd_boolean *dynsym;
+     bfd_boolean override;
+     bfd_boolean dt_needed;
+{
+  bfd_boolean type_change_ok;
+  bfd_boolean size_change_ok;
+  bfd_boolean skip;
+  char *shortname;
+  struct elf_link_hash_entry *hi;
+  struct bfd_link_hash_entry *bh;
+  struct elf_backend_data *bed;
+  bfd_boolean collect;
+  bfd_boolean dynamic;
+  char *p;
+  size_t len, shortlen;
+  asection *sec;
+
+  /* If this symbol has a version, and it is the default version, we
+     create an indirect symbol from the default name to the fully
+     decorated name.  This will cause external references which do not
+     specify a version to be bound to this version of the symbol.  */
+  p = strchr (name, ELF_VER_CHR);
+  if (p == NULL || p[1] != ELF_VER_CHR)
+    return TRUE;
+
+  if (override)
+    {
+      /* We are overridden by an old defition. We need to check if we
+	 need to create the indirect symbol from the default name.  */
+      hi = elf_link_hash_lookup (elf_hash_table (info), name, TRUE,
+				 FALSE, FALSE);
+      BFD_ASSERT (hi != NULL);
+      if (hi == h)
+	return TRUE;
+      while (hi->root.type == bfd_link_hash_indirect
+	     || hi->root.type == bfd_link_hash_warning)
+	{
+	  hi = (struct elf_link_hash_entry *) hi->root.u.i.link;
+	  if (hi == h)
+	    return TRUE;
+	}
+    }
+
+  bed = get_elf_backend_data (abfd);
+  collect = bed->collect;
+  dynamic = (abfd->flags & DYNAMIC) != 0;
+
+  shortlen = p - name;
+  shortname = bfd_hash_allocate (&info->hash->table, shortlen + 1);
+  if (shortname == NULL)
+    return FALSE;
+  memcpy (shortname, name, shortlen);
+  shortname[shortlen] = '\0';
+
+  /* We are going to create a new symbol.  Merge it with any existing
+     symbol with this name.  For the purposes of the merge, act as
+     though we were defining the symbol we just defined, although we
+     actually going to define an indirect symbol.  */
+  type_change_ok = FALSE;
+  size_change_ok = FALSE;
+  sec = *psec;
+  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
+			  &hi, &skip, &override, &type_change_ok,
+			  &size_change_ok, dt_needed))
+    return FALSE;
+
+  if (skip)
+    goto nondefault;
+
+  if (! override)
+    {
+      bh = &hi->root;
+      if (! (_bfd_generic_link_add_one_symbol
+	     (info, abfd, shortname, BSF_INDIRECT, bfd_ind_section_ptr,
+	      (bfd_vma) 0, name, FALSE, collect, &bh)))
+	return FALSE;
+      hi = (struct elf_link_hash_entry *) bh;
+    }
+  else
+    {
+      /* In this case the symbol named SHORTNAME is overriding the
+	 indirect symbol we want to add.  We were planning on making
+	 SHORTNAME an indirect symbol referring to NAME.  SHORTNAME
+	 is the name without a version.  NAME is the fully versioned
+	 name, and it is the default version.
+
+	 Overriding means that we already saw a definition for the
+	 symbol SHORTNAME in a regular object, and it is overriding
+	 the symbol defined in the dynamic object.
+
+	 When this happens, we actually want to change NAME, the
+	 symbol we just added, to refer to SHORTNAME.  This will cause
+	 references to NAME in the shared object to become references
+	 to SHORTNAME in the regular object.  This is what we expect
+	 when we override a function in a shared object: that the
+	 references in the shared object will be mapped to the
+	 definition in the regular object.  */
+
+      while (hi->root.type == bfd_link_hash_indirect
+	     || hi->root.type == bfd_link_hash_warning)
+	hi = (struct elf_link_hash_entry *) hi->root.u.i.link;
+
+      h->root.type = bfd_link_hash_indirect;
+      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
+      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
+	{
+	  h->elf_link_hash_flags &=~ ELF_LINK_HASH_DEF_DYNAMIC;
+	  hi->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
+	  if (hi->elf_link_hash_flags
+	      & (ELF_LINK_HASH_REF_REGULAR
+		 | ELF_LINK_HASH_DEF_REGULAR))
+	    {
+	      if (! _bfd_elf_link_record_dynamic_symbol (info, hi))
+		return FALSE;
+	    }
+	}
+
+      /* Now set HI to H, so that the following code will set the
+	 other fields correctly.  */
+      hi = h;
+    }
+
+  /* If there is a duplicate definition somewhere, then HI may not
+     point to an indirect symbol.  We will have reported an error to
+     the user in that case.  */
+
+  if (hi->root.type == bfd_link_hash_indirect)
+    {
+      struct elf_link_hash_entry *ht;
+
+      /* If the symbol became indirect, then we assume that we have
+	 not seen a definition before.  */
+      BFD_ASSERT ((hi->elf_link_hash_flags
+		   & (ELF_LINK_HASH_DEF_DYNAMIC
+		      | ELF_LINK_HASH_DEF_REGULAR)) == 0);
+
+      ht = (struct elf_link_hash_entry *) hi->root.u.i.link;
+      (*bed->elf_backend_copy_indirect_symbol) (bed, ht, hi);
+
+      /* See if the new flags lead us to realize that the symbol must
+	 be dynamic.  */
+      if (! *dynsym)
+	{
+	  if (! dynamic)
+	    {
+	      if (info->shared
+		  || ((hi->elf_link_hash_flags
+		       & ELF_LINK_HASH_REF_DYNAMIC) != 0))
+		*dynsym = TRUE;
+	    }
+	  else
+	    {
+	      if ((hi->elf_link_hash_flags
+		   & ELF_LINK_HASH_REF_REGULAR) != 0)
+		*dynsym = TRUE;
+	    }
+	}
+    }
+
+  /* We also need to define an indirection from the nondefault version
+     of the symbol.  */
+
+nondefault:
+  len = strlen (name);
+  shortname = bfd_hash_allocate (&info->hash->table, len);
+  if (shortname == NULL)
+    return FALSE;
+  memcpy (shortname, name, shortlen);
+  memcpy (shortname + shortlen, p + 1, len - shortlen);
+
+  /* Once again, merge with any existing symbol.  */
+  type_change_ok = FALSE;
+  size_change_ok = FALSE;
+  sec = *psec;
+  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
+			  &hi, &skip, &override, &type_change_ok,
+			  &size_change_ok, dt_needed))
+    return FALSE;
+
+  if (skip)
+    return TRUE;
+
+  if (override)
+    {
+      /* Here SHORTNAME is a versioned name, so we don't expect to see
+	 the type of override we do in the case above unless it is
+	 overridden by a versioned definiton.  */
+      if (hi->root.type != bfd_link_hash_defined
+	  && hi->root.type != bfd_link_hash_defweak)
+	(*_bfd_error_handler)
+	  (_("%s: warning: unexpected redefinition of indirect versioned symbol `%s'"),
+	   bfd_archive_filename (abfd), shortname);
+    }
+  else
+    {
+      bh = &hi->root;
+      if (! (_bfd_generic_link_add_one_symbol
+	     (info, abfd, shortname, BSF_INDIRECT,
+	      bfd_ind_section_ptr, (bfd_vma) 0, name, FALSE, collect, &bh)))
+	return FALSE;
+      hi = (struct elf_link_hash_entry *) bh;
+
+      /* If there is a duplicate definition somewhere, then HI may not
+	 point to an indirect symbol.  We will have reported an error
+	 to the user in that case.  */
+
+      if (hi->root.type == bfd_link_hash_indirect)
+	{
+	  /* If the symbol became indirect, then we assume that we have
+	     not seen a definition before.  */
+	  BFD_ASSERT ((hi->elf_link_hash_flags
+		       & (ELF_LINK_HASH_DEF_DYNAMIC
+			  | ELF_LINK_HASH_DEF_REGULAR)) == 0);
+
+	  (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
+
+	  /* See if the new flags lead us to realize that the symbol
+	     must be dynamic.  */
+	  if (! *dynsym)
+	    {
+	      if (! dynamic)
+		{
+		  if (info->shared
+		      || ((hi->elf_link_hash_flags
+			   & ELF_LINK_HASH_REF_DYNAMIC) != 0))
+		    *dynsym = TRUE;
+		}
+	      else
+		{
+		  if ((hi->elf_link_hash_flags
+		       & ELF_LINK_HASH_REF_REGULAR) != 0)
+		    *dynsym = TRUE;
+		}
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* Add symbols from an ELF object file to the linker hash table.  */
+
+static bfd_boolean
+elf_link_add_object_symbols (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  bfd_boolean (*add_symbol_hook)
+    PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
+	     const char **, flagword *, asection **, bfd_vma *));
+  bfd_boolean (*check_relocs)
+    PARAMS ((bfd *, struct bfd_link_info *, asection *,
+	     const Elf_Internal_Rela *));
+  bfd_boolean collect;
+  Elf_Internal_Shdr *hdr;
+  bfd_size_type symcount;
+  bfd_size_type extsymcount;
+  bfd_size_type extsymoff;
+  struct elf_link_hash_entry **sym_hash;
+  bfd_boolean dynamic;
+  Elf_External_Versym *extversym = NULL;
+  Elf_External_Versym *ever;
+  struct elf_link_hash_entry *weaks;
+  struct elf_link_hash_entry **nondeflt_vers = NULL;
+  bfd_size_type nondeflt_vers_cnt = 0;
+  Elf_Internal_Sym *isymbuf = NULL;
+  Elf_Internal_Sym *isym;
+  Elf_Internal_Sym *isymend;
+  struct elf_backend_data *bed;
+  bfd_boolean dt_needed;
+  struct elf_link_hash_table * hash_table;
+  bfd_size_type amt;
+
+  hash_table = elf_hash_table (info);
+
+  bed = get_elf_backend_data (abfd);
+  add_symbol_hook = bed->elf_add_symbol_hook;
+  collect = bed->collect;
+
+  if ((abfd->flags & DYNAMIC) == 0)
+    dynamic = FALSE;
+  else
+    {
+      dynamic = TRUE;
+
+      /* You can't use -r against a dynamic object.  Also, there's no
+	 hope of using a dynamic object which does not exactly match
+	 the format of the output file.  */
+      if (info->relocateable || info->hash->creator != abfd->xvec)
+	{
+	  bfd_set_error (bfd_error_invalid_operation);
+	  goto error_return;
+	}
+    }
+
+  /* As a GNU extension, any input sections which are named
+     .gnu.warning.SYMBOL are treated as warning symbols for the given
+     symbol.  This differs from .gnu.warning sections, which generate
+     warnings when they are included in an output file.  */
+  if (! info->shared)
+    {
+      asection *s;
+
+      for (s = abfd->sections; s != NULL; s = s->next)
+	{
+	  const char *name;
+
+	  name = bfd_get_section_name (abfd, s);
+	  if (strncmp (name, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0)
+	    {
+	      char *msg;
+	      bfd_size_type sz;
+
+	      name += sizeof ".gnu.warning." - 1;
+
+	      /* If this is a shared object, then look up the symbol
+		 in the hash table.  If it is there, and it is already
+		 been defined, then we will not be using the entry
+		 from this shared object, so we don't need to warn.
+		 FIXME: If we see the definition in a regular object
+		 later on, we will warn, but we shouldn't.  The only
+		 fix is to keep track of what warnings we are supposed
+		 to emit, and then handle them all at the end of the
+		 link.  */
+	      if (dynamic && abfd->xvec == info->hash->creator)
+		{
+		  struct elf_link_hash_entry *h;
+
+		  h = elf_link_hash_lookup (hash_table, name,
+					    FALSE, FALSE, TRUE);
+
+		  /* FIXME: What about bfd_link_hash_common?  */
+		  if (h != NULL
+		      && (h->root.type == bfd_link_hash_defined
+			  || h->root.type == bfd_link_hash_defweak))
+		    {
+		      /* We don't want to issue this warning.  Clobber
+			 the section size so that the warning does not
+			 get copied into the output file.  */
+		      s->_raw_size = 0;
+		      continue;
+		    }
+		}
+
+	      sz = bfd_section_size (abfd, s);
+	      msg = (char *) bfd_alloc (abfd, sz + 1);
+	      if (msg == NULL)
+		goto error_return;
+
+	      if (! bfd_get_section_contents (abfd, s, msg, (file_ptr) 0, sz))
+		goto error_return;
+
+	      msg[sz] = '\0';
+
+	      if (! (_bfd_generic_link_add_one_symbol
+		     (info, abfd, name, BSF_WARNING, s, (bfd_vma) 0, msg,
+		      FALSE, collect, (struct bfd_link_hash_entry **) NULL)))
+		goto error_return;
+
+	      if (! info->relocateable)
+		{
+		  /* Clobber the section size so that the warning does
+		     not get copied into the output file.  */
+		  s->_raw_size = 0;
+		}
+	    }
+	}
+    }
+
+  dt_needed = FALSE;
+  if (! dynamic)
+    {
+      /* If we are creating a shared library, create all the dynamic
+	 sections immediately.  We need to attach them to something,
+	 so we attach them to this BFD, provided it is the right
+	 format.  FIXME: If there are no input BFD's of the same
+	 format as the output, we can't make a shared library.  */
+      if (info->shared
+	  && is_elf_hash_table (info)
+	  && ! hash_table->dynamic_sections_created
+	  && abfd->xvec == info->hash->creator)
+	{
+	  if (! elf_link_create_dynamic_sections (abfd, info))
+	    goto error_return;
+	}
+    }
+  else if (! is_elf_hash_table (info))
+    goto error_return;
+  else
+    {
+      asection *s;
+      bfd_boolean add_needed;
+      const char *name;
+      bfd_size_type oldsize;
+      bfd_size_type strindex;
+      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;
+
+      /* ld --just-symbols and dynamic objects don't mix very well.
+	 Test for --just-symbols by looking at info set up by
+	 _bfd_elf_link_just_syms.  */
+      if ((s = abfd->sections) != NULL
+	  && s->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
+	goto error_return;
+
+      /* Find the name to use in a DT_NEEDED entry that refers to this
+	 object.  If the object has a DT_SONAME entry, we use it.
+	 Otherwise, if the generic linker stuck something in
+	 elf_dt_name, we use that.  Otherwise, we just use the file
+	 name.  If the generic linker put a null string into
+	 elf_dt_name, we don't make a DT_NEEDED entry at all, even if
+	 there is a DT_SONAME entry.  */
+      add_needed = TRUE;
+      name = bfd_get_filename (abfd);
+      if (elf_dt_name (abfd) != NULL)
+	{
+	  name = elf_dt_name (abfd);
+	  if (*name == '\0')
+	    {
+	      if (elf_dt_soname (abfd) != NULL)
+		dt_needed = TRUE;
+
+	      add_needed = FALSE;
+	    }
+	}
+      s = bfd_get_section_by_name (abfd, ".dynamic");
+      if (s != NULL)
+	{
+	  Elf_External_Dyn *dynbuf = NULL;
+	  Elf_External_Dyn *extdyn;
+	  Elf_External_Dyn *extdynend;
+	  int elfsec;
+	  unsigned long shlink;
+
+	  dynbuf = (Elf_External_Dyn *) bfd_malloc (s->_raw_size);
+	  if (dynbuf == NULL)
+	    goto error_return;
+
+	  if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf,
+					  (file_ptr) 0, s->_raw_size))
+	    goto error_free_dyn;
+
+	  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
+	  if (elfsec == -1)
+	    goto error_free_dyn;
+	  shlink = elf_elfsections (abfd)[elfsec]->sh_link;
+
+	  extdyn = dynbuf;
+	  extdynend = extdyn + s->_raw_size / sizeof (Elf_External_Dyn);
+	  for (; extdyn < extdynend; extdyn++)
+	    {
+	      Elf_Internal_Dyn dyn;
+
+	      elf_swap_dyn_in (abfd, extdyn, &dyn);
+	      if (dyn.d_tag == DT_SONAME)
+		{
+		  unsigned int tagv = dyn.d_un.d_val;
+		  name = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
+		  if (name == NULL)
+		    goto error_free_dyn;
+		}
+	      if (dyn.d_tag == DT_NEEDED)
+		{
+		  struct bfd_link_needed_list *n, **pn;
+		  char *fnm, *anm;
+		  unsigned int tagv = dyn.d_un.d_val;
+
+		  amt = sizeof (struct bfd_link_needed_list);
+		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
+		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
+		  if (n == NULL || fnm == NULL)
+		    goto error_free_dyn;
+		  amt = strlen (fnm) + 1;
+		  anm = bfd_alloc (abfd, amt);
+		  if (anm == NULL)
+		    goto error_free_dyn;
+		  memcpy (anm, fnm, (size_t) amt);
+		  n->name = anm;
+		  n->by = abfd;
+		  n->next = NULL;
+		  for (pn = & hash_table->needed;
+		       *pn != NULL;
+		       pn = &(*pn)->next)
+		    ;
+		  *pn = n;
+		}
+	      if (dyn.d_tag == DT_RUNPATH)
+		{
+		  struct bfd_link_needed_list *n, **pn;
+		  char *fnm, *anm;
+		  unsigned int tagv = dyn.d_un.d_val;
+
+		  amt = sizeof (struct bfd_link_needed_list);
+		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
+		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
+		  if (n == NULL || fnm == NULL)
+		    goto error_free_dyn;
+		  amt = strlen (fnm) + 1;
+		  anm = bfd_alloc (abfd, amt);
+		  if (anm == NULL)
+		    goto error_free_dyn;
+		  memcpy (anm, fnm, (size_t) amt);
+		  n->name = anm;
+		  n->by = abfd;
+		  n->next = NULL;
+		  for (pn = & runpath;
+		       *pn != NULL;
+		       pn = &(*pn)->next)
+		    ;
+		  *pn = n;
+		}
+	      /* Ignore DT_RPATH if we have seen DT_RUNPATH.  */
+	      if (!runpath && dyn.d_tag == DT_RPATH)
+		{
+		  struct bfd_link_needed_list *n, **pn;
+		  char *fnm, *anm;
+		  unsigned int tagv = dyn.d_un.d_val;
+
+		  amt = sizeof (struct bfd_link_needed_list);
+		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
+		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
+		  if (n == NULL || fnm == NULL)
+		    goto error_free_dyn;
+		  amt = strlen (fnm) + 1;
+		  anm = bfd_alloc (abfd, amt);
+		  if (anm == NULL)
+		    {
+		    error_free_dyn:
+		      free (dynbuf);
+		      goto error_return;
+		    }
+		  memcpy (anm, fnm, (size_t) amt);
+		  n->name = anm;
+		  n->by = abfd;
+		  n->next = NULL;
+		  for (pn = & rpath;
+		       *pn != NULL;
+		       pn = &(*pn)->next)
+		    ;
+		  *pn = n;
+		}
+	    }
+
+	  free (dynbuf);
+	}
+
+      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
+	 frees all more recently bfd_alloc'd blocks as well.  */
+      if (runpath)
+	rpath = runpath;
+
+      if (rpath)
+	{
+	  struct bfd_link_needed_list **pn;
+	  for (pn = & hash_table->runpath;
+	       *pn != NULL;
+	       pn = &(*pn)->next)
+	    ;
+	  *pn = rpath;
+	}
+
+      /* We do not want to include any of the sections in a dynamic
+	 object in the output file.  We hack by simply clobbering the
+	 list of sections in the BFD.  This could be handled more
+	 cleanly by, say, a new section flag; the existing
+	 SEC_NEVER_LOAD flag is not the one we want, because that one
+	 still implies that the section takes up space in the output
+	 file.  */
+      bfd_section_list_clear (abfd);
+
+      /* If this is the first dynamic object found in the link, create
+	 the special sections required for dynamic linking.  */
+      if (! hash_table->dynamic_sections_created)
+	if (! elf_link_create_dynamic_sections (abfd, info))
+	  goto error_return;
+
+      if (add_needed)
+	{
+	  /* Add a DT_NEEDED entry for this dynamic object.  */
+	  oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
+	  strindex = _bfd_elf_strtab_add (hash_table->dynstr, name, FALSE);
+	  if (strindex == (bfd_size_type) -1)
+	    goto error_return;
+
+	  if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
+	    {
+	      asection *sdyn;
+	      Elf_External_Dyn *dyncon, *dynconend;
+
+	      /* The hash table size did not change, which means that
+		 the dynamic object name was already entered.  If we
+		 have already included this dynamic object in the
+		 link, just ignore it.  There is no reason to include
+		 a particular dynamic object more than once.  */
+	      sdyn = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
+	      BFD_ASSERT (sdyn != NULL);
+
+	      dyncon = (Elf_External_Dyn *) sdyn->contents;
+	      dynconend = (Elf_External_Dyn *) (sdyn->contents +
+						sdyn->_raw_size);
+	      for (; dyncon < dynconend; dyncon++)
+		{
+		  Elf_Internal_Dyn dyn;
+
+		  elf_swap_dyn_in (hash_table->dynobj, dyncon, & dyn);
+		  if (dyn.d_tag == DT_NEEDED
+		      && dyn.d_un.d_val == strindex)
+		    {
+		      _bfd_elf_strtab_delref (hash_table->dynstr, strindex);
+		      return TRUE;
+		    }
+		}
+	    }
+
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NEEDED, strindex))
+	    goto error_return;
+	}
+
+      /* Save the SONAME, if there is one, because sometimes the
+	 linker emulation code will need to know it.  */
+      if (*name == '\0')
+	name = basename (bfd_get_filename (abfd));
+      elf_dt_name (abfd) = name;
+    }
+
+  /* If this is a dynamic object, we always link against the .dynsym
+     symbol table, not the .symtab symbol table.  The dynamic linker
+     will only see the .dynsym symbol table, so there is no reason to
+     look at .symtab for a dynamic object.  */
+
+  if (! dynamic || elf_dynsymtab (abfd) == 0)
+    hdr = &elf_tdata (abfd)->symtab_hdr;
+  else
+    hdr = &elf_tdata (abfd)->dynsymtab_hdr;
+
+  symcount = hdr->sh_size / sizeof (Elf_External_Sym);
+
+  /* The sh_info field of the symtab header tells us where the
+     external symbols start.  We don't care about the local symbols at
+     this point.  */
+  if (elf_bad_symtab (abfd))
+    {
+      extsymcount = symcount;
+      extsymoff = 0;
+    }
+  else
+    {
+      extsymcount = symcount - hdr->sh_info;
+      extsymoff = hdr->sh_info;
+    }
+
+  sym_hash = NULL;
+  if (extsymcount != 0)
+    {
+      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
+				      NULL, NULL, NULL);
+      if (isymbuf == NULL)
+	goto error_return;
+
+      /* We store a pointer to the hash table entry for each external
+	 symbol.  */
+      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
+      sym_hash = (struct elf_link_hash_entry **) bfd_alloc (abfd, amt);
+      if (sym_hash == NULL)
+	goto error_free_sym;
+      elf_sym_hashes (abfd) = sym_hash;
+    }
+
+  if (dynamic)
+    {
+      /* Read in any version definitions.  */
+      if (! _bfd_elf_slurp_version_tables (abfd))
+	goto error_free_sym;
+
+      /* Read in the symbol versions, but don't bother to convert them
+	 to internal format.  */
+      if (elf_dynversym (abfd) != 0)
+	{
+	  Elf_Internal_Shdr *versymhdr;
+
+	  versymhdr = &elf_tdata (abfd)->dynversym_hdr;
+	  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
+	  if (extversym == NULL)
+	    goto error_free_sym;
+	  amt = versymhdr->sh_size;
+	  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0
+	      || bfd_bread ((PTR) extversym, amt, abfd) != amt)
+	    goto error_free_vers;
+	}
+    }
+
+  weaks = NULL;
+
+  ever = extversym != NULL ? extversym + extsymoff : NULL;
+  for (isym = isymbuf, isymend = isymbuf + extsymcount;
+       isym < isymend;
+       isym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL))
+    {
+      int bind;
+      bfd_vma value;
+      asection *sec;
+      flagword flags;
+      const char *name;
+      struct elf_link_hash_entry *h;
+      bfd_boolean definition;
+      bfd_boolean size_change_ok;
+      bfd_boolean type_change_ok;
+      bfd_boolean new_weakdef;
+      bfd_boolean override;
+      unsigned int old_alignment;
+      bfd *old_bfd;
+
+      override = FALSE;
+
+      flags = BSF_NO_FLAGS;
+      sec = NULL;
+      value = isym->st_value;
+      *sym_hash = NULL;
+
+      bind = ELF_ST_BIND (isym->st_info);
+      if (bind == STB_LOCAL)
+	{
+	  /* This should be impossible, since ELF requires that all
+	     global symbols follow all local symbols, and that sh_info
+	     point to the first global symbol.  Unfortunatealy, Irix 5
+	     screws this up.  */
+	  continue;
+	}
+      else if (bind == STB_GLOBAL)
+	{
+	  if (isym->st_shndx != SHN_UNDEF
+	      && isym->st_shndx != SHN_COMMON)
+	    flags = BSF_GLOBAL;
+	}
+      else if (bind == STB_WEAK)
+	flags = BSF_WEAK;
+      else
+	{
+	  /* Leave it up to the processor backend.  */
+	}
+
+      if (isym->st_shndx == SHN_UNDEF)
+	sec = bfd_und_section_ptr;
+      else if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
+	{
+	  sec = section_from_elf_index (abfd, isym->st_shndx);
+	  if (sec == NULL)
+	    sec = bfd_abs_section_ptr;
+	  else if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
+	    value -= sec->vma;
+	}
+      else if (isym->st_shndx == SHN_ABS)
+	sec = bfd_abs_section_ptr;
+      else if (isym->st_shndx == SHN_COMMON)
+	{
+	  sec = bfd_com_section_ptr;
+	  /* What ELF calls the size we call the value.  What ELF
+	     calls the value we call the alignment.  */
+	  value = isym->st_size;
+	}
+      else
+	{
+	  /* Leave it up to the processor backend.  */
+	}
+
+      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
+					      isym->st_name);
+      if (name == (const char *) NULL)
+	goto error_free_vers;
+
+      if (isym->st_shndx == SHN_COMMON
+	  && ELF_ST_TYPE (isym->st_info) == STT_TLS)
+	{
+	  asection *tcomm = bfd_get_section_by_name (abfd, ".tcommon");
+
+	  if (tcomm == NULL)
+	    {
+	      tcomm = bfd_make_section (abfd, ".tcommon");
+	      if (tcomm == NULL
+		  || !bfd_set_section_flags (abfd, tcomm, (SEC_ALLOC
+							   | SEC_IS_COMMON
+							   | SEC_LINKER_CREATED
+							   | SEC_THREAD_LOCAL)))
+		goto error_free_vers;
+	    }
+	  sec = tcomm;
+	}
+      else if (add_symbol_hook)
+	{
+	  if (! (*add_symbol_hook) (abfd, info, isym, &name, &flags, &sec,
+				    &value))
+	    goto error_free_vers;
+
+	  /* The hook function sets the name to NULL if this symbol
+	     should be skipped for some reason.  */
+	  if (name == (const char *) NULL)
+	    continue;
+	}
+
+      /* Sanity check that all possibilities were handled.  */
+      if (sec == (asection *) NULL)
+	{
+	  bfd_set_error (bfd_error_bad_value);
+	  goto error_free_vers;
+	}
+
+      if (bfd_is_und_section (sec)
+	  || bfd_is_com_section (sec))
+	definition = FALSE;
+      else
+	definition = TRUE;
+
+      size_change_ok = FALSE;
+      type_change_ok = get_elf_backend_data (abfd)->type_change_ok;
+      old_alignment = 0;
+      old_bfd = NULL;
+
+      if (info->hash->creator->flavour == bfd_target_elf_flavour)
+	{
+	  Elf_Internal_Versym iver;
+	  unsigned int vernum = 0;
+	  bfd_boolean skip;
+
+	  if (ever != NULL)
+	    {
+	      _bfd_elf_swap_versym_in (abfd, ever, &iver);
+	      vernum = iver.vs_vers & VERSYM_VERSION;
+
+	      /* If this is a hidden symbol, or if it is not version
+		 1, we append the version name to the symbol name.
+		 However, we do not modify a non-hidden absolute
+		 symbol, because it might be the version symbol
+		 itself.  FIXME: What if it isn't?  */
+	      if ((iver.vs_vers & VERSYM_HIDDEN) != 0
+		  || (vernum > 1 && ! bfd_is_abs_section (sec)))
+		{
+		  const char *verstr;
+		  size_t namelen, verlen, newlen;
+		  char *newname, *p;
+
+		  if (isym->st_shndx != SHN_UNDEF)
+		    {
+		      if (vernum > elf_tdata (abfd)->dynverdef_hdr.sh_info)
+			{
+			  (*_bfd_error_handler)
+			    (_("%s: %s: invalid version %u (max %d)"),
+			     bfd_archive_filename (abfd), name, vernum,
+			     elf_tdata (abfd)->dynverdef_hdr.sh_info);
+			  bfd_set_error (bfd_error_bad_value);
+			  goto error_free_vers;
+			}
+		      else if (vernum > 1)
+			verstr =
+			  elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
+		      else
+			verstr = "";
+		    }
+		  else
+		    {
+		      /* We cannot simply test for the number of
+			 entries in the VERNEED section since the
+			 numbers for the needed versions do not start
+			 at 0.  */
+		      Elf_Internal_Verneed *t;
+
+		      verstr = NULL;
+		      for (t = elf_tdata (abfd)->verref;
+			   t != NULL;
+			   t = t->vn_nextref)
+			{
+			  Elf_Internal_Vernaux *a;
+
+			  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+			    {
+			      if (a->vna_other == vernum)
+				{
+				  verstr = a->vna_nodename;
+				  break;
+				}
+			    }
+			  if (a != NULL)
+			    break;
+			}
+		      if (verstr == NULL)
+			{
+			  (*_bfd_error_handler)
+			    (_("%s: %s: invalid needed version %d"),
+			     bfd_archive_filename (abfd), name, vernum);
+			  bfd_set_error (bfd_error_bad_value);
+			  goto error_free_vers;
+			}
+		    }
+
+		  namelen = strlen (name);
+		  verlen = strlen (verstr);
+		  newlen = namelen + verlen + 2;
+		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
+		      && isym->st_shndx != SHN_UNDEF)
+		    ++newlen;
+
+		  newname = (char *) bfd_alloc (abfd, (bfd_size_type) newlen);
+		  if (newname == NULL)
+		    goto error_free_vers;
+		  memcpy (newname, name, namelen);
+		  p = newname + namelen;
+		  *p++ = ELF_VER_CHR;
+		  /* If this is a defined non-hidden version symbol,
+		     we add another @ to the name.  This indicates the
+		     default version of the symbol.  */
+		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
+		      && isym->st_shndx != SHN_UNDEF)
+		    *p++ = ELF_VER_CHR;
+		  memcpy (p, verstr, verlen + 1);
+
+		  name = newname;
+		}
+	    }
+
+	  if (! elf_merge_symbol (abfd, info, name, isym, &sec, &value,
+				  sym_hash, &skip, &override,
+				  &type_change_ok, &size_change_ok,
+				  dt_needed))
+	    goto error_free_vers;
+
+	  if (skip)
+	    continue;
+
+	  if (override)
+	    definition = FALSE;
+
+	  h = *sym_hash;
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+	  /* Remember the old alignment if this is a common symbol, so
+	     that we don't reduce the alignment later on.  We can't
+	     check later, because _bfd_generic_link_add_one_symbol
+	     will set a default for the alignment which we want to
+	     override. We also remember the old bfd where the existing
+	     definition comes from.  */
+	  switch (h->root.type)
+	    {
+	    default:
+	      break;
+
+	    case bfd_link_hash_defined:
+	    case bfd_link_hash_defweak:
+	      old_bfd = h->root.u.def.section->owner;
+	      break;
+	    
+	    case bfd_link_hash_common:
+	      old_bfd = h->root.u.c.p->section->owner;
+	      old_alignment = h->root.u.c.p->alignment_power;
+	      break;
+	    }
+
+	  if (elf_tdata (abfd)->verdef != NULL
+	      && ! override
+	      && vernum > 1
+	      && definition)
+	    h->verinfo.verdef = &elf_tdata (abfd)->verdef[vernum - 1];
+	}
+
+      if (! (_bfd_generic_link_add_one_symbol
+	     (info, abfd, name, flags, sec, value, (const char *) NULL,
+	      FALSE, collect, (struct bfd_link_hash_entry **) sym_hash)))
+	goto error_free_vers;
+
+      h = *sym_hash;
+      while (h->root.type == bfd_link_hash_indirect
+	     || h->root.type == bfd_link_hash_warning)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+      *sym_hash = h;
+
+      new_weakdef = FALSE;
+      if (dynamic
+	  && definition
+	  && (flags & BSF_WEAK) != 0
+	  && ELF_ST_TYPE (isym->st_info) != STT_FUNC
+	  && info->hash->creator->flavour == bfd_target_elf_flavour
+	  && h->weakdef == NULL)
+	{
+	  /* Keep a list of all weak defined non function symbols from
+	     a dynamic object, using the weakdef field.  Later in this
+	     function we will set the weakdef field to the correct
+	     value.  We only put non-function symbols from dynamic
+	     objects on this list, because that happens to be the only
+	     time we need to know the normal symbol corresponding to a
+	     weak symbol, and the information is time consuming to
+	     figure out.  If the weakdef field is not already NULL,
+	     then this symbol was already defined by some previous
+	     dynamic object, and we will be using that previous
+	     definition anyhow.  */
+
+	  h->weakdef = weaks;
+	  weaks = h;
+	  new_weakdef = TRUE;
+	}
+
+      /* Set the alignment of a common symbol.  */
+      if (isym->st_shndx == SHN_COMMON
+	  && h->root.type == bfd_link_hash_common)
+	{
+	  unsigned int align;
+
+	  align = bfd_log2 (isym->st_value);
+	  if (align > old_alignment
+	      /* Permit an alignment power of zero if an alignment of one
+		 is specified and no other alignments have been specified.  */
+	      || (isym->st_value == 1 && old_alignment == 0))
+	    h->root.u.c.p->alignment_power = align;
+	  else
+	    h->root.u.c.p->alignment_power = old_alignment;
+	}
+
+      if (info->hash->creator->flavour == bfd_target_elf_flavour)
+	{
+	  int old_flags;
+	  bfd_boolean dynsym;
+	  int new_flag;
+
+	  /* Check the alignment when a common symbol is involved. This
+	     can change when a common symbol is overriden by a normal
+	     definition or a common symbol is ignored due to the old
+	     normal definition. We need to make sure the maximum
+	     alignment is maintained.  */
+	  if ((old_alignment || isym->st_shndx == SHN_COMMON)
+	      && h->root.type != bfd_link_hash_common)
+	    {
+	      unsigned int common_align;
+	      unsigned int normal_align;
+	      unsigned int symbol_align;
+	      bfd *normal_bfd;
+	      bfd *common_bfd;
+
+	      symbol_align = ffs (h->root.u.def.value) - 1;
+	      if ((h->root.u.def.section->owner->flags & DYNAMIC) == 0)
+		{
+		  normal_align = h->root.u.def.section->alignment_power;
+		  if (normal_align > symbol_align)
+		    normal_align = symbol_align;
+		}
+	      else
+		normal_align = symbol_align;
+
+	      if (old_alignment)
+		{
+		  common_align = old_alignment;
+		  common_bfd = old_bfd;
+		  normal_bfd = abfd;
+		}
+	      else
+		{
+		  common_align = bfd_log2 (isym->st_value);
+		  common_bfd = abfd;
+		  normal_bfd = old_bfd;
+		}
+
+	      if (normal_align < common_align)
+		(*_bfd_error_handler)
+		  (_("Warning: alignment %u of symbol `%s' in %s is smaller than %u in %s"),
+		   1 << normal_align,
+		   name,
+		   bfd_archive_filename (normal_bfd),
+		   1 << common_align,
+		   bfd_archive_filename (common_bfd));
+	    }
+
+	  /* Remember the symbol size and type.  */
+	  if (isym->st_size != 0
+	      && (definition || h->size == 0))
+	    {
+	      if (h->size != 0 && h->size != isym->st_size && ! size_change_ok)
+		(*_bfd_error_handler)
+		  (_("Warning: size of symbol `%s' changed from %lu in %s to %lu in %s"),
+		   name, (unsigned long) h->size,
+		   bfd_archive_filename (old_bfd),
+		   (unsigned long) isym->st_size,
+		   bfd_archive_filename (abfd));
+
+	      h->size = isym->st_size;
+	    }
+
+	  /* If this is a common symbol, then we always want H->SIZE
+	     to be the size of the common symbol.  The code just above
+	     won't fix the size if a common symbol becomes larger.  We
+	     don't warn about a size change here, because that is
+	     covered by --warn-common.  */
+	  if (h->root.type == bfd_link_hash_common)
+	    h->size = h->root.u.c.size;
+
+	  if (ELF_ST_TYPE (isym->st_info) != STT_NOTYPE
+	      && (definition || h->type == STT_NOTYPE))
+	    {
+	      if (h->type != STT_NOTYPE
+		  && h->type != ELF_ST_TYPE (isym->st_info)
+		  && ! type_change_ok)
+		(*_bfd_error_handler)
+		  (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
+		   name, h->type, ELF_ST_TYPE (isym->st_info),
+		   bfd_archive_filename (abfd));
+
+	      h->type = ELF_ST_TYPE (isym->st_info);
+	    }
+
+	  /* If st_other has a processor-specific meaning, specific
+	     code might be needed here. We never merge the visibility
+	     attribute with the one from a dynamic object.  */
+	  if (isym->st_other != 0 && !dynamic)
+	    {
+	      unsigned char hvis, symvis, other, nvis;
+
+	      /* Take the balance of OTHER from the definition.  */
+	      other = (definition ? isym->st_other : h->other);
+	      other &= ~ ELF_ST_VISIBILITY (-1);
+
+	      /* Combine visibilities, using the most constraining one.  */
+	      hvis   = ELF_ST_VISIBILITY (h->other);
+	      symvis = ELF_ST_VISIBILITY (isym->st_other);
+	      if (! hvis)
+		nvis = symvis;
+	      else if (! symvis)
+		nvis = hvis;
+	      else
+		nvis = hvis < symvis ? hvis : symvis;
+
+	      h->other = other | nvis;
+	    }
+
+	  /* Set a flag in the hash table entry indicating the type of
+	     reference or definition we just found.  Keep a count of
+	     the number of dynamic symbols we find.  A dynamic symbol
+	     is one which is referenced or defined by both a regular
+	     object and a shared object.  */
+	  old_flags = h->elf_link_hash_flags;
+	  dynsym = FALSE;
+	  if (! dynamic)
+	    {
+	      if (! definition)
+		{
+		  new_flag = ELF_LINK_HASH_REF_REGULAR;
+		  if (bind != STB_WEAK)
+		    new_flag |= ELF_LINK_HASH_REF_REGULAR_NONWEAK;
+		}
+	      else
+		new_flag = ELF_LINK_HASH_DEF_REGULAR;
+	      if (info->shared
+		  || (old_flags & (ELF_LINK_HASH_DEF_DYNAMIC
+				   | ELF_LINK_HASH_REF_DYNAMIC)) != 0)
+		dynsym = TRUE;
+	    }
+	  else
+	    {
+	      if (! definition)
+		new_flag = ELF_LINK_HASH_REF_DYNAMIC;
+	      else
+		new_flag = ELF_LINK_HASH_DEF_DYNAMIC;
+	      if ((old_flags & (ELF_LINK_HASH_DEF_REGULAR
+				| ELF_LINK_HASH_REF_REGULAR)) != 0
+		  || (h->weakdef != NULL
+		      && ! new_weakdef
+		      && h->weakdef->dynindx != -1))
+		dynsym = TRUE;
+	    }
+
+	  h->elf_link_hash_flags |= new_flag;
+
+	  /* Check to see if we need to add an indirect symbol for
+	     the default name.  */
+	  if (definition || h->root.type == bfd_link_hash_common)
+	    if (! elf_add_default_symbol (abfd, info, h, name, isym,
+					  &sec, &value, &dynsym,
+					  override, dt_needed))
+	      goto error_free_vers;
+
+	  if (definition && !dynamic)
+	    {
+	      char *p = strchr (name, ELF_VER_CHR);
+	      if (p != NULL && p[1] != ELF_VER_CHR)
+		{
+		  /* Queue non-default versions so that .symver x, x@FOO
+		     aliases can be checked.  */
+		  if (! nondeflt_vers)
+		    {
+		      amt = (isymend - isym + 1)
+			    * sizeof (struct elf_link_hash_entry *);
+		      nondeflt_vers = bfd_malloc (amt);
+		    }
+		  nondeflt_vers [nondeflt_vers_cnt++] = h;
+		}
+	    }
+
+	  if (dynsym && h->dynindx == -1)
+	    {
+	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+		goto error_free_vers;
+	      if (h->weakdef != NULL
+		  && ! new_weakdef
+		  && h->weakdef->dynindx == -1)
+		{
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
+		    goto error_free_vers;
+		}
+	    }
+	  else if (dynsym && h->dynindx != -1)
+	    /* If the symbol already has a dynamic index, but
+	       visibility says it should not be visible, turn it into
+	       a local symbol.  */
+	    switch (ELF_ST_VISIBILITY (h->other))
+	      {
+	      case STV_INTERNAL:
+	      case STV_HIDDEN:
+		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
+		break;
+	      }
+
+	  if (dt_needed && definition
+	      && (h->elf_link_hash_flags
+		  & ELF_LINK_HASH_REF_REGULAR) != 0)
+	    {
+	      bfd_size_type oldsize;
+	      bfd_size_type strindex;
+
+	      if (! is_elf_hash_table (info))
+		goto error_free_vers;
+
+	      /* The symbol from a DT_NEEDED object is referenced from
+		 the regular object to create a dynamic executable. We
+		 have to make sure there is a DT_NEEDED entry for it.  */
+
+	      dt_needed = FALSE;
+	      oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
+	      strindex = _bfd_elf_strtab_add (hash_table->dynstr,
+					      elf_dt_soname (abfd), FALSE);
+	      if (strindex == (bfd_size_type) -1)
+		goto error_free_vers;
+
+	      if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
+		{
+		  asection *sdyn;
+		  Elf_External_Dyn *dyncon, *dynconend;
+
+		  sdyn = bfd_get_section_by_name (hash_table->dynobj,
+						  ".dynamic");
+		  BFD_ASSERT (sdyn != NULL);
+
+		  dyncon = (Elf_External_Dyn *) sdyn->contents;
+		  dynconend = (Elf_External_Dyn *) (sdyn->contents +
+						    sdyn->_raw_size);
+		  for (; dyncon < dynconend; dyncon++)
+		    {
+		      Elf_Internal_Dyn dyn;
+
+		      elf_swap_dyn_in (hash_table->dynobj,
+				       dyncon, &dyn);
+		      BFD_ASSERT (dyn.d_tag != DT_NEEDED ||
+				  dyn.d_un.d_val != strindex);
+		    }
+		}
+
+	      if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NEEDED, strindex))
+		goto error_free_vers;
+	    }
+	}
+    }
+
+  /* Now that all the symbols from this input file are created, handle
+     .symver foo, foo@BAR such that any relocs against foo become foo@BAR.  */
+  if (nondeflt_vers != NULL)
+    {
+      bfd_size_type cnt, symidx;
+
+      for (cnt = 0; cnt < nondeflt_vers_cnt; ++cnt)
+	{
+	  struct elf_link_hash_entry *h = nondeflt_vers[cnt], *hi;
+	  char *shortname, *p;
+
+	  p = strchr (h->root.root.string, ELF_VER_CHR);
+	  if (p == NULL
+	      || (h->root.type != bfd_link_hash_defined
+		  && h->root.type != bfd_link_hash_defweak))
+	    continue;
+
+	  amt = p - h->root.root.string;
+	  shortname = bfd_malloc (amt + 1);
+	  memcpy (shortname, h->root.root.string, amt);
+	  shortname[amt] = '\0';
+
+	  hi = (struct elf_link_hash_entry *)
+	       bfd_link_hash_lookup (info->hash, shortname,
+				     FALSE, FALSE, FALSE);
+	  if (hi != NULL
+	      && hi->root.type == h->root.type
+	      && hi->root.u.def.value == h->root.u.def.value
+	      && hi->root.u.def.section == h->root.u.def.section)
+	    {
+	      (*bed->elf_backend_hide_symbol) (info, hi, TRUE);
+	      hi->root.type = bfd_link_hash_indirect;
+	      hi->root.u.i.link = (struct bfd_link_hash_entry *) h;
+	      (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
+	      sym_hash = elf_sym_hashes (abfd);
+	      if (sym_hash)
+		for (symidx = 0; symidx < extsymcount; ++symidx)
+		  if (sym_hash[symidx] == hi)
+		    {
+		      sym_hash[symidx] = h;
+		      break;
+		    }
+	    }
+	  free (shortname);
+	}
+      free (nondeflt_vers);
+      nondeflt_vers = NULL;
+    }
+
+  if (extversym != NULL)
+    {
+      free (extversym);
+      extversym = NULL;
+    }
+
+  if (isymbuf != NULL)
+    free (isymbuf);
+  isymbuf = NULL;
+
+  /* Now set the weakdefs field correctly for all the weak defined
+     symbols we found.  The only way to do this is to search all the
+     symbols.  Since we only need the information for non functions in
+     dynamic objects, that's the only time we actually put anything on
+     the list WEAKS.  We need this information so that if a regular
+     object refers to a symbol defined weakly in a dynamic object, the
+     real symbol in the dynamic object is also put in the dynamic
+     symbols; we also must arrange for both symbols to point to the
+     same memory location.  We could handle the general case of symbol
+     aliasing, but a general symbol alias can only be generated in
+     assembler code, handling it correctly would be very time
+     consuming, and other ELF linkers don't handle general aliasing
+     either.  */
+  while (weaks != NULL)
+    {
+      struct elf_link_hash_entry *hlook;
+      asection *slook;
+      bfd_vma vlook;
+      struct elf_link_hash_entry **hpp;
+      struct elf_link_hash_entry **hppend;
+
+      hlook = weaks;
+      weaks = hlook->weakdef;
+      hlook->weakdef = NULL;
+
+      BFD_ASSERT (hlook->root.type == bfd_link_hash_defined
+		  || hlook->root.type == bfd_link_hash_defweak
+		  || hlook->root.type == bfd_link_hash_common
+		  || hlook->root.type == bfd_link_hash_indirect);
+      slook = hlook->root.u.def.section;
+      vlook = hlook->root.u.def.value;
+
+      hpp = elf_sym_hashes (abfd);
+      hppend = hpp + extsymcount;
+      for (; hpp < hppend; hpp++)
+	{
+	  struct elf_link_hash_entry *h;
+
+	  h = *hpp;
+	  if (h != NULL && h != hlook
+	      && h->root.type == bfd_link_hash_defined
+	      && h->root.u.def.section == slook
+	      && h->root.u.def.value == vlook)
+	    {
+	      hlook->weakdef = h;
+
+	      /* If the weak definition is in the list of dynamic
+		 symbols, make sure the real definition is put there
+		 as well.  */
+	      if (hlook->dynindx != -1
+		  && h->dynindx == -1)
+		{
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+		    goto error_return;
+		}
+
+	      /* If the real definition is in the list of dynamic
+		 symbols, make sure the weak definition is put there
+		 as well.  If we don't do this, then the dynamic
+		 loader might not merge the entries for the real
+		 definition and the weak definition.  */
+	      if (h->dynindx != -1
+		  && hlook->dynindx == -1)
+		{
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, hlook))
+		    goto error_return;
+		}
+	      break;
+	    }
+	}
+    }
+
+  /* If this object is the same format as the output object, and it is
+     not a shared library, then let the backend look through the
+     relocs.
+
+     This is required to build global offset table entries and to
+     arrange for dynamic relocs.  It is not required for the
+     particular common case of linking non PIC code, even when linking
+     against shared libraries, but unfortunately there is no way of
+     knowing whether an object file has been compiled PIC or not.
+     Looking through the relocs is not particularly time consuming.
+     The problem is that we must either (1) keep the relocs in memory,
+     which causes the linker to require additional runtime memory or
+     (2) read the relocs twice from the input file, which wastes time.
+     This would be a good case for using mmap.
+
+     I have no idea how to handle linking PIC code into a file of a
+     different format.  It probably can't be done.  */
+  check_relocs = get_elf_backend_data (abfd)->check_relocs;
+  if (! dynamic
+      && abfd->xvec == info->hash->creator
+      && check_relocs != NULL)
+    {
+      asection *o;
+
+      for (o = abfd->sections; o != NULL; o = o->next)
+	{
+	  Elf_Internal_Rela *internal_relocs;
+	  bfd_boolean ok;
+
+	  if ((o->flags & SEC_RELOC) == 0
+	      || o->reloc_count == 0
+	      || ((info->strip == strip_all || info->strip == strip_debugger)
+		  && (o->flags & SEC_DEBUGGING) != 0)
+	      || bfd_is_abs_section (o->output_section))
+	    continue;
+
+	  internal_relocs = (NAME(_bfd_elf,link_read_relocs)
+			     (abfd, o, (PTR) NULL,
+			      (Elf_Internal_Rela *) NULL,
+			      info->keep_memory));
+	  if (internal_relocs == NULL)
+	    goto error_return;
+
+	  ok = (*check_relocs) (abfd, info, o, internal_relocs);
+
+	  if (elf_section_data (o)->relocs != internal_relocs)
+	    free (internal_relocs);
+
+	  if (! ok)
+	    goto error_return;
+	}
+    }
+
+  /* If this is a non-traditional link, try to optimize the handling
+     of the .stab/.stabstr sections.  */
+  if (! dynamic
+      && ! info->traditional_format
+      && info->hash->creator->flavour == bfd_target_elf_flavour
+      && is_elf_hash_table (info)
+      && (info->strip != strip_all && info->strip != strip_debugger))
+    {
+      asection *stab, *stabstr;
+
+      stab = bfd_get_section_by_name (abfd, ".stab");
+      if (stab != NULL
+	  && (stab->flags & SEC_MERGE) == 0
+	  && !bfd_is_abs_section (stab->output_section))
+	{
+	  stabstr = bfd_get_section_by_name (abfd, ".stabstr");
+
+	  if (stabstr != NULL)
+	    {
+	      struct bfd_elf_section_data *secdata;
+
+	      secdata = elf_section_data (stab);
+	      if (! _bfd_link_section_stabs (abfd,
+					     & hash_table->stab_info,
+					     stab, stabstr,
+					     &secdata->sec_info))
+		goto error_return;
+	      if (secdata->sec_info)
+		stab->sec_info_type = ELF_INFO_TYPE_STABS;
+	    }
+	}
+    }
+
+  if (! info->relocateable && ! dynamic
+      && is_elf_hash_table (info))
+    {
+      asection *s;
+
+      for (s = abfd->sections; s != NULL; s = s->next)
+	if ((s->flags & SEC_MERGE) != 0
+	    && !bfd_is_abs_section (s->output_section))
+	  {
+	    struct bfd_elf_section_data *secdata;
+
+	    secdata = elf_section_data (s);
+	    if (! _bfd_merge_section (abfd,
+				      & hash_table->merge_info,
+				      s, &secdata->sec_info))
+	      goto error_return;
+	    else if (secdata->sec_info)
+	      s->sec_info_type = ELF_INFO_TYPE_MERGE;
+	  }
+    }
+
+  if (is_elf_hash_table (info))
+    {
+      /* Add this bfd to the loaded list.  */
+      struct elf_link_loaded_list *n;
+
+      n = ((struct elf_link_loaded_list *)
+	   bfd_alloc (abfd, sizeof (struct elf_link_loaded_list)));
+      if (n == NULL)
+	goto error_return;
+      n->abfd = abfd;
+      n->next = hash_table->loaded;
+      hash_table->loaded = n;
+    }
+
+  return TRUE;
+
+ error_free_vers:
+  if (nondeflt_vers != NULL)
+    free (nondeflt_vers);
+  if (extversym != NULL)
+    free (extversym);
+ error_free_sym:
+  if (isymbuf != NULL)
+    free (isymbuf);
+ error_return:
+  return FALSE;
+}
+
+/* Create some sections which will be filled in with dynamic linking
+   information.  ABFD is an input file which requires dynamic sections
+   to be created.  The dynamic sections take up virtual memory space
+   when the final executable is run, so we need to create them before
+   addresses are assigned to the output sections.  We work out the
+   actual contents and size of these sections later.  */
+
+bfd_boolean
+elf_link_create_dynamic_sections (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  flagword flags;
+  register asection *s;
+  struct elf_link_hash_entry *h;
+  struct bfd_link_hash_entry *bh;
+  struct elf_backend_data *bed;
+
+  if (! is_elf_hash_table (info))
+    return FALSE;
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    return TRUE;
+
+  /* Make sure that all dynamic sections use the same input BFD.  */
+  if (elf_hash_table (info)->dynobj == NULL)
+    elf_hash_table (info)->dynobj = abfd;
+  else
+    abfd = elf_hash_table (info)->dynobj;
+
+  /* Note that we set the SEC_IN_MEMORY flag for all of these
+     sections.  */
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
+	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);
+
+  /* A dynamically linked executable has a .interp section, but a
+     shared library does not.  */
+  if (! info->shared)
+    {
+      s = bfd_make_section (abfd, ".interp");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
+	return FALSE;
+    }
+
+  if (! info->traditional_format
+      && info->hash->creator->flavour == bfd_target_elf_flavour)
+    {
+      s = bfd_make_section (abfd, ".eh_frame_hdr");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+	  || ! bfd_set_section_alignment (abfd, s, 2))
+	return FALSE;
+      elf_hash_table (info)->eh_info.hdr_sec = s;
+    }
+
+  /* Create sections to hold version informations.  These are removed
+     if they are not needed.  */
+  s = bfd_make_section (abfd, ".gnu.version_d");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return FALSE;
+
+  s = bfd_make_section (abfd, ".gnu.version");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, 1))
+    return FALSE;
+
+  s = bfd_make_section (abfd, ".gnu.version_r");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return FALSE;
+
+  s = bfd_make_section (abfd, ".dynsym");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return FALSE;
+
+  s = bfd_make_section (abfd, ".dynstr");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
+    return FALSE;
+
+  /* Create a strtab to hold the dynamic symbol names.  */
+  if (elf_hash_table (info)->dynstr == NULL)
+    {
+      elf_hash_table (info)->dynstr = _bfd_elf_strtab_init ();
+      if (elf_hash_table (info)->dynstr == NULL)
+	return FALSE;
+    }
+
+  s = bfd_make_section (abfd, ".dynamic");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return FALSE;
+
+  /* The special symbol _DYNAMIC is always set to the start of the
+     .dynamic section.  This call occurs before we have processed the
+     symbols for any dynamic object, so we don't have to worry about
+     overriding a dynamic definition.  We could set _DYNAMIC in a
+     linker script, but we only want to define it if we are, in fact,
+     creating a .dynamic section.  We don't want to define it if there
+     is no .dynamic section, since on some ELF platforms the start up
+     code examines it to decide how to initialize the process.  */
+  bh = NULL;
+  if (! (_bfd_generic_link_add_one_symbol
+	 (info, abfd, "_DYNAMIC", BSF_GLOBAL, s, (bfd_vma) 0,
+	  (const char *) 0, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
+    return FALSE;
+  h = (struct elf_link_hash_entry *) bh;
+  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+  h->type = STT_OBJECT;
+
+  if (info->shared
+      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
+    return FALSE;
+
+  bed = get_elf_backend_data (abfd);
+
+  s = bfd_make_section (abfd, ".hash");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return FALSE;
+  elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;
+
+  /* Let the backend create the rest of the sections.  This lets the
+     backend set the right flags.  The backend will normally create
+     the .got and .plt sections.  */
+  if (! (*bed->elf_backend_create_dynamic_sections) (abfd, info))
+    return FALSE;
+
+  elf_hash_table (info)->dynamic_sections_created = TRUE;
+
+  return TRUE;
+}
+
+/* Add an entry to the .dynamic table.  */
+
+bfd_boolean
+elf_add_dynamic_entry (info, tag, val)
+     struct bfd_link_info *info;
+     bfd_vma tag;
+     bfd_vma val;
+{
+  Elf_Internal_Dyn dyn;
+  bfd *dynobj;
+  asection *s;
+  bfd_size_type newsize;
+  bfd_byte *newcontents;
+
+  if (! is_elf_hash_table (info))
+    return FALSE;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  s = bfd_get_section_by_name (dynobj, ".dynamic");
+  BFD_ASSERT (s != NULL);
+
+  newsize = s->_raw_size + sizeof (Elf_External_Dyn);
+  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
+  if (newcontents == NULL)
+    return FALSE;
+
+  dyn.d_tag = tag;
+  dyn.d_un.d_val = val;
+  elf_swap_dyn_out (dynobj, &dyn,
+		    (Elf_External_Dyn *) (newcontents + s->_raw_size));
+
+  s->_raw_size = newsize;
+  s->contents = newcontents;
+
+  return TRUE;
+}
+
+/* Read and swap the relocs from the section indicated by SHDR.  This
+   may be either a REL or a RELA section.  The relocations are
+   translated into RELA relocations and stored in INTERNAL_RELOCS,
+   which should have already been allocated to contain enough space.
+   The EXTERNAL_RELOCS are a buffer where the external form of the
+   relocations should be stored.
+
+   Returns FALSE if something goes wrong.  */
+
+static bfd_boolean
+elf_link_read_relocs_from_section (abfd, shdr, external_relocs,
+				   internal_relocs)
+     bfd *abfd;
+     Elf_Internal_Shdr *shdr;
+     PTR external_relocs;
+     Elf_Internal_Rela *internal_relocs;
+{
+  struct elf_backend_data *bed;
+  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
+  const bfd_byte *erela;
+  const bfd_byte *erelaend;
+  Elf_Internal_Rela *irela;
+
+  /* If there aren't any relocations, that's OK.  */
+  if (!shdr)
+    return TRUE;
+
+  /* Position ourselves at the start of the section.  */
+  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0)
+    return FALSE;
+
+  /* Read the relocations.  */
+  if (bfd_bread (external_relocs, shdr->sh_size, abfd) != shdr->sh_size)
+    return FALSE;
+
+  bed = get_elf_backend_data (abfd);
+
+  /* Convert the external relocations to the internal format.  */
+  if (shdr->sh_entsize == sizeof (Elf_External_Rel))
+    swap_in = bed->s->swap_reloc_in;
+  else if (shdr->sh_entsize == sizeof (Elf_External_Rela))
+    swap_in = bed->s->swap_reloca_in;
+  else
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return FALSE;
+    }
+
+  erela = external_relocs;
+  erelaend = erela + NUM_SHDR_ENTRIES (shdr) * shdr->sh_entsize;
+  irela = internal_relocs;
+  while (erela < erelaend)
+    {
+      (*swap_in) (abfd, erela, irela);
+      irela += bed->s->int_rels_per_ext_rel;
+      erela += shdr->sh_entsize;
+    }
+
+  return TRUE;
+}
+
+/* Read and swap the relocs for a section O.  They may have been
+   cached.  If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are
+   not NULL, they are used as buffers to read into.  They are known to
+   be large enough.  If the INTERNAL_RELOCS relocs argument is NULL,
+   the return value is allocated using either malloc or bfd_alloc,
+   according to the KEEP_MEMORY argument.  If O has two relocation
+   sections (both REL and RELA relocations), then the REL_HDR
+   relocations will appear first in INTERNAL_RELOCS, followed by the
+   REL_HDR2 relocations.  */
+
+Elf_Internal_Rela *
+NAME(_bfd_elf,link_read_relocs) (abfd, o, external_relocs, internal_relocs,
+				 keep_memory)
+     bfd *abfd;
+     asection *o;
+     PTR external_relocs;
+     Elf_Internal_Rela *internal_relocs;
+     bfd_boolean keep_memory;
+{
+  Elf_Internal_Shdr *rel_hdr;
+  PTR alloc1 = NULL;
+  Elf_Internal_Rela *alloc2 = NULL;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+
+  if (elf_section_data (o)->relocs != NULL)
+    return elf_section_data (o)->relocs;
+
+  if (o->reloc_count == 0)
+    return NULL;
+
+  rel_hdr = &elf_section_data (o)->rel_hdr;
+
+  if (internal_relocs == NULL)
+    {
+      bfd_size_type size;
+
+      size = o->reloc_count;
+      size *= bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rela);
+      if (keep_memory)
+	internal_relocs = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
+      else
+	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
+      if (internal_relocs == NULL)
+	goto error_return;
+    }
+
+  if (external_relocs == NULL)
+    {
+      bfd_size_type size = rel_hdr->sh_size;
+
+      if (elf_section_data (o)->rel_hdr2)
+	size += elf_section_data (o)->rel_hdr2->sh_size;
+      alloc1 = (PTR) bfd_malloc (size);
+      if (alloc1 == NULL)
+	goto error_return;
+      external_relocs = alloc1;
+    }
+
+  if (!elf_link_read_relocs_from_section (abfd, rel_hdr,
+					  external_relocs,
+					  internal_relocs))
+    goto error_return;
+  if (!elf_link_read_relocs_from_section
+      (abfd,
+       elf_section_data (o)->rel_hdr2,
+       ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
+       internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
+			  * bed->s->int_rels_per_ext_rel)))
+    goto error_return;
+
+  /* Cache the results for next time, if we can.  */
+  if (keep_memory)
+    elf_section_data (o)->relocs = internal_relocs;
+
+  if (alloc1 != NULL)
+    free (alloc1);
+
+  /* Don't free alloc2, since if it was allocated we are passing it
+     back (under the name of internal_relocs).  */
+
+  return internal_relocs;
+
+ error_return:
+  if (alloc1 != NULL)
+    free (alloc1);
+  if (alloc2 != NULL)
+    free (alloc2);
+  return NULL;
+}
+
+/* Record an assignment to a symbol made by a linker script.  We need
+   this in case some dynamic object refers to this symbol.  */
+
+bfd_boolean
+NAME(bfd_elf,record_link_assignment) (output_bfd, info, name, provide)
+     bfd *output_bfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info *info;
+     const char *name;
+     bfd_boolean provide;
+{
+  struct elf_link_hash_entry *h;
+
+  if (info->hash->creator->flavour != bfd_target_elf_flavour)
+    return TRUE;
+
+  h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, TRUE, FALSE);
+  if (h == NULL)
+    return FALSE;
+
+  if (h->root.type == bfd_link_hash_new)
+    h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
+
+  /* If this symbol is being provided by the linker script, and it is
+     currently defined by a dynamic object, but not by a regular
+     object, then mark it as undefined so that the generic linker will
+     force the correct value.  */
+  if (provide
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+    h->root.type = bfd_link_hash_undefined;
+
+  /* If this symbol is not being provided by the linker script, and it is
+     currently defined by a dynamic object, but not by a regular object,
+     then clear out any version information because the symbol will not be
+     associated with the dynamic object any more.  */
+  if (!provide
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+    h->verinfo.verdef = NULL;
+
+  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+
+  if (((h->elf_link_hash_flags & (ELF_LINK_HASH_DEF_DYNAMIC
+				  | ELF_LINK_HASH_REF_DYNAMIC)) != 0
+       || info->shared)
+      && h->dynindx == -1)
+    {
+      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+	return FALSE;
+
+      /* If this is a weak defined symbol, and we know a corresponding
+	 real symbol from the same dynamic object, make sure the real
+	 symbol is also made into a dynamic symbol.  */
+      if (h->weakdef != NULL
+	  && h->weakdef->dynindx == -1)
+	{
+	  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
+	    return FALSE;
+	}
+    }
+
+  return TRUE;
+}
+
+/* This structure is used to pass information to
+   elf_link_assign_sym_version.  */
+
+struct elf_assign_sym_version_info
+{
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* Version tree.  */
+  struct bfd_elf_version_tree *verdefs;
+  /* Whether we had a failure.  */
+  bfd_boolean failed;
+};
+
+/* This structure is used to pass information to
+   elf_link_find_version_dependencies.  */
+
+struct elf_find_verdep_info
+{
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* The number of dependencies.  */
+  unsigned int vers;
+  /* Whether we had a failure.  */
+  bfd_boolean failed;
+};
+
+/* Array used to determine the number of hash table buckets to use
+   based on the number of symbols there are.  If there are fewer than
+   3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,
+   fewer than 37 we use 17 buckets, and so forth.  We never use more
+   than 32771 buckets.  */
+
+static const size_t elf_buckets[] =
+{
+  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
+  16411, 32771, 0
+};
+
+/* Compute bucket count for hashing table.  We do not use a static set
+   of possible tables sizes anymore.  Instead we determine for all
+   possible reasonable sizes of the table the outcome (i.e., the
+   number of collisions etc) and choose the best solution.  The
+   weighting functions are not too simple to allow the table to grow
+   without bounds.  Instead one of the weighting factors is the size.
+   Therefore the result is always a good payoff between few collisions
+   (= short chain lengths) and table size.  */
+static size_t
+compute_bucket_count (info)
+     struct bfd_link_info *info;
+{
+  size_t dynsymcount = elf_hash_table (info)->dynsymcount;
+  size_t best_size = 0;
+  unsigned long int *hashcodes;
+  unsigned long int *hashcodesp;
+  unsigned long int i;
+  bfd_size_type amt;
+
+  /* Compute the hash values for all exported symbols.  At the same
+     time store the values in an array so that we could use them for
+     optimizations.  */
+  amt = dynsymcount;
+  amt *= sizeof (unsigned long int);
+  hashcodes = (unsigned long int *) bfd_malloc (amt);
+  if (hashcodes == NULL)
+    return 0;
+  hashcodesp = hashcodes;
+
+  /* Put all hash values in HASHCODES.  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_collect_hash_codes, &hashcodesp);
+
+  /* We have a problem here.  The following code to optimize the table
+     size requires an integer type with more the 32 bits.  If
+     BFD_HOST_U_64_BIT is set we know about such a type.  */
+#ifdef BFD_HOST_U_64_BIT
+  if (info->optimize)
+    {
+      unsigned long int nsyms = hashcodesp - hashcodes;
+      size_t minsize;
+      size_t maxsize;
+      BFD_HOST_U_64_BIT best_chlen = ~((BFD_HOST_U_64_BIT) 0);
+      unsigned long int *counts ;
+
+      /* Possible optimization parameters: if we have NSYMS symbols we say
+	 that the hashing table must at least have NSYMS/4 and at most
+	 2*NSYMS buckets.  */
+      minsize = nsyms / 4;
+      if (minsize == 0)
+	minsize = 1;
+      best_size = maxsize = nsyms * 2;
+
+      /* Create array where we count the collisions in.  We must use bfd_malloc
+	 since the size could be large.  */
+      amt = maxsize;
+      amt *= sizeof (unsigned long int);
+      counts = (unsigned long int *) bfd_malloc (amt);
+      if (counts == NULL)
+	{
+	  free (hashcodes);
+	  return 0;
+	}
+
+      /* Compute the "optimal" size for the hash table.  The criteria is a
+	 minimal chain length.  The minor criteria is (of course) the size
+	 of the table.  */
+      for (i = minsize; i < maxsize; ++i)
+	{
+	  /* Walk through the array of hashcodes and count the collisions.  */
+	  BFD_HOST_U_64_BIT max;
+	  unsigned long int j;
+	  unsigned long int fact;
+
+	  memset (counts, '\0', i * sizeof (unsigned long int));
+
+	  /* Determine how often each hash bucket is used.  */
+	  for (j = 0; j < nsyms; ++j)
+	    ++counts[hashcodes[j] % i];
+
+	  /* For the weight function we need some information about the
+	     pagesize on the target.  This is information need not be 100%
+	     accurate.  Since this information is not available (so far) we
+	     define it here to a reasonable default value.  If it is crucial
+	     to have a better value some day simply define this value.  */
+# ifndef BFD_TARGET_PAGESIZE
+#  define BFD_TARGET_PAGESIZE	(4096)
+# endif
+
+	  /* We in any case need 2 + NSYMS entries for the size values and
+	     the chains.  */
+	  max = (2 + nsyms) * (ARCH_SIZE / 8);
+
+# if 1
+	  /* Variant 1: optimize for short chains.  We add the squares
+	     of all the chain lengths (which favous many small chain
+	     over a few long chains).  */
+	  for (j = 0; j < i; ++j)
+	    max += counts[j] * counts[j];
+
+	  /* This adds penalties for the overall size of the table.  */
+	  fact = i / (BFD_TARGET_PAGESIZE / (ARCH_SIZE / 8)) + 1;
+	  max *= fact * fact;
+# else
+	  /* Variant 2: Optimize a lot more for small table.  Here we
+	     also add squares of the size but we also add penalties for
+	     empty slots (the +1 term).  */
+	  for (j = 0; j < i; ++j)
+	    max += (1 + counts[j]) * (1 + counts[j]);
+
+	  /* The overall size of the table is considered, but not as
+	     strong as in variant 1, where it is squared.  */
+	  fact = i / (BFD_TARGET_PAGESIZE / (ARCH_SIZE / 8)) + 1;
+	  max *= fact;
+# endif
+
+	  /* Compare with current best results.  */
+	  if (max < best_chlen)
+	    {
+	      best_chlen = max;
+	      best_size = i;
+	    }
+	}
+
+      free (counts);
+    }
+  else
+#endif /* defined (BFD_HOST_U_64_BIT) */
+    {
+      /* This is the fallback solution if no 64bit type is available or if we
+	 are not supposed to spend much time on optimizations.  We select the
+	 bucket count using a fixed set of numbers.  */
+      for (i = 0; elf_buckets[i] != 0; i++)
+	{
+	  best_size = elf_buckets[i];
+	  if (dynsymcount < elf_buckets[i + 1])
+	    break;
+	}
+    }
+
+  /* Free the arrays we needed.  */
+  free (hashcodes);
+
+  return best_size;
+}
+
+/* Set up the sizes and contents of the ELF dynamic sections.  This is
+   called by the ELF linker emulation before_allocation routine.  We
+   must set the sizes of the sections before the linker sets the
+   addresses of the various sections.  */
+
+bfd_boolean
+NAME(bfd_elf,size_dynamic_sections) (output_bfd, soname, rpath,
+				     filter_shlib,
+				     auxiliary_filters, info, sinterpptr,
+				     verdefs)
+     bfd *output_bfd;
+     const char *soname;
+     const char *rpath;
+     const char *filter_shlib;
+     const char * const *auxiliary_filters;
+     struct bfd_link_info *info;
+     asection **sinterpptr;
+     struct bfd_elf_version_tree *verdefs;
+{
+  bfd_size_type soname_indx;
+  bfd *dynobj;
+  struct elf_backend_data *bed;
+  struct elf_assign_sym_version_info asvinfo;
+
+  *sinterpptr = NULL;
+
+  soname_indx = (bfd_size_type) -1;
+
+  if (info->hash->creator->flavour != bfd_target_elf_flavour)
+    return TRUE;
+
+  if (! is_elf_hash_table (info))
+    return TRUE;
+
+  /* Any syms created from now on start with -1 in
+     got.refcount/offset and plt.refcount/offset.  */
+  elf_hash_table (info)->init_refcount = elf_hash_table (info)->init_offset;
+
+  /* The backend may have to create some sections regardless of whether
+     we're dynamic or not.  */
+  bed = get_elf_backend_data (output_bfd);
+  if (bed->elf_backend_always_size_sections
+      && ! (*bed->elf_backend_always_size_sections) (output_bfd, info))
+    return FALSE;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* If there were no dynamic objects in the link, there is nothing to
+     do here.  */
+  if (dynobj == NULL)
+    return TRUE;
+
+  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))
+    return FALSE;
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      struct elf_info_failed eif;
+      struct elf_link_hash_entry *h;
+      asection *dynstr;
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_expr *d;
+      bfd_boolean all_defined;
+
+      *sinterpptr = bfd_get_section_by_name (dynobj, ".interp");
+      BFD_ASSERT (*sinterpptr != NULL || info->shared);
+
+      if (soname != NULL)
+	{
+	  soname_indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					     soname, TRUE);
+	  if (soname_indx == (bfd_size_type) -1
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_SONAME,
+					  soname_indx))
+	    return FALSE;
+	}
+
+      if (info->symbolic)
+	{
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_SYMBOLIC,
+				       (bfd_vma) 0))
+	    return FALSE;
+	  info->flags |= DF_SYMBOLIC;
+	}
+
+      if (rpath != NULL)
+	{
+	  bfd_size_type indx;
+
+	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, rpath,
+				      TRUE);
+	  if (info->new_dtags)
+	    _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr, indx);
+	  if (indx == (bfd_size_type) -1
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_RPATH, indx)
+	      || (info->new_dtags
+		  && ! elf_add_dynamic_entry (info, (bfd_vma) DT_RUNPATH,
+					      indx)))
+	    return FALSE;
+	}
+
+      if (filter_shlib != NULL)
+	{
+	  bfd_size_type indx;
+
+	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+				      filter_shlib, TRUE);
+	  if (indx == (bfd_size_type) -1
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_FILTER, indx))
+	    return FALSE;
+	}
+
+      if (auxiliary_filters != NULL)
+	{
+	  const char * const *p;
+
+	  for (p = auxiliary_filters; *p != NULL; p++)
+	    {
+	      bfd_size_type indx;
+
+	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					  *p, TRUE);
+	      if (indx == (bfd_size_type) -1
+		  || ! elf_add_dynamic_entry (info, (bfd_vma) DT_AUXILIARY,
+					      indx))
+		return FALSE;
+	    }
+	}
+
+      eif.info = info;
+      eif.verdefs = verdefs;
+      eif.failed = FALSE;
+
+      /* If we are supposed to export all symbols into the dynamic symbol
+	 table (this is not the normal case), then do so.  */
+      if (info->export_dynamic)
+	{
+	  elf_link_hash_traverse (elf_hash_table (info), elf_export_symbol,
+				  (PTR) &eif);
+	  if (eif.failed)
+	    return FALSE;
+	}
+
+      /* Make all global versions with definiton.  */
+      for (t = verdefs; t != NULL; t = t->next)
+	for (d = t->globals; d != NULL; d = d->next)
+	  if (!d->symver && strchr (d->pattern, '*') == NULL)
+	    {
+	      const char *verstr, *name;
+	      size_t namelen, verlen, newlen;
+	      char *newname, *p;
+	      struct elf_link_hash_entry *newh;
+
+	      name = d->pattern;
+	      namelen = strlen (name);
+	      verstr = t->name;
+	      verlen = strlen (verstr);
+	      newlen = namelen + verlen + 3;
+
+	      newname = (char *) bfd_malloc ((bfd_size_type) newlen);
+	      if (newname == NULL)
+		return FALSE;
+	      memcpy (newname, name, namelen);
+
+	      /* Check the hidden versioned definition.  */
+	      p = newname + namelen;
+	      *p++ = ELF_VER_CHR;
+	      memcpy (p, verstr, verlen + 1);
+	      newh = elf_link_hash_lookup (elf_hash_table (info),
+					   newname, FALSE, FALSE,
+					   FALSE);
+	      if (newh == NULL
+		  || (newh->root.type != bfd_link_hash_defined
+		      && newh->root.type != bfd_link_hash_defweak))
+		{
+		  /* Check the default versioned definition.  */
+		  *p++ = ELF_VER_CHR;
+		  memcpy (p, verstr, verlen + 1);
+		  newh = elf_link_hash_lookup (elf_hash_table (info),
+					       newname, FALSE, FALSE,
+					       FALSE);
+		}
+	      free (newname);
+
+	      /* Mark this version if there is a definition and it is
+		 not defined in a shared object.  */
+	      if (newh != NULL
+		  && ((newh->elf_link_hash_flags
+		       & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
+		  && (newh->root.type == bfd_link_hash_defined
+		      || newh->root.type == bfd_link_hash_defweak))
+		d->symver = 1;
+	    }
+
+      /* Attach all the symbols to their version information.  */
+      asvinfo.output_bfd = output_bfd;
+      asvinfo.info = info;
+      asvinfo.verdefs = verdefs;
+      asvinfo.failed = FALSE;
+
+      elf_link_hash_traverse (elf_hash_table (info),
+			      elf_link_assign_sym_version,
+			      (PTR) &asvinfo);
+      if (asvinfo.failed)
+	return FALSE;
+
+      if (!info->allow_undefined_version)
+	{
+	  /* Check if all global versions have a definiton.  */
+	  all_defined = TRUE;
+	  for (t = verdefs; t != NULL; t = t->next)
+	    for (d = t->globals; d != NULL; d = d->next)
+	      if (!d->symver && !d->script
+		  && strchr (d->pattern, '*') == NULL)
+		{
+		  (*_bfd_error_handler)
+		    (_("%s: undefined version: %s"),
+		     d->pattern, t->name);
+		  all_defined = FALSE;
+		}
+
+	  if (!all_defined)
+	    {
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
+	    }
+	}
+
+      /* Find all symbols which were defined in a dynamic object and make
+	 the backend pick a reasonable value for them.  */
+      elf_link_hash_traverse (elf_hash_table (info),
+			      elf_adjust_dynamic_symbol,
+			      (PTR) &eif);
+      if (eif.failed)
+	return FALSE;
+
+      /* Add some entries to the .dynamic section.  We fill in some of the
+	 values later, in elf_bfd_final_link, but we must add the entries
+	 now so that we know the final size of the .dynamic section.  */
+
+      /* If there are initialization and/or finalization functions to
+	 call then add the corresponding DT_INIT/DT_FINI entries.  */
+      h = (info->init_function
+	   ? elf_link_hash_lookup (elf_hash_table (info),
+				   info->init_function, FALSE,
+				   FALSE, FALSE)
+	   : NULL);
+      if (h != NULL
+	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
+					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
+	{
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_INIT, (bfd_vma) 0))
+	    return FALSE;
+	}
+      h = (info->fini_function
+	   ? elf_link_hash_lookup (elf_hash_table (info),
+				   info->fini_function, FALSE,
+				   FALSE, FALSE)
+	   : NULL);
+      if (h != NULL
+	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
+					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
+	{
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_FINI, (bfd_vma) 0))
+	    return FALSE;
+	}
+
+      if (bfd_get_section_by_name (output_bfd, ".preinit_array") != NULL)
+	{
+	  /* DT_PREINIT_ARRAY is not allowed in shared library.  */
+	  if (info->shared)
+	    {
+	      bfd *sub;
+	      asection *o;
+
+	      for (sub = info->input_bfds; sub != NULL;
+		   sub = sub->link_next)
+		for (o = sub->sections; o != NULL; o = o->next)
+		  if (elf_section_data (o)->this_hdr.sh_type
+		      == SHT_PREINIT_ARRAY)
+		    {
+		      (*_bfd_error_handler)
+			(_("%s: .preinit_array section is not allowed in DSO"),
+			 bfd_archive_filename (sub));
+		      break;
+		    }
+
+	      bfd_set_error (bfd_error_nonrepresentable_section);
+	      return FALSE;
+	    }
+
+	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAY,
+				      (bfd_vma) 0)
+	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAYSZ,
+					 (bfd_vma) 0))
+	    return FALSE;
+	}
+      if (bfd_get_section_by_name (output_bfd, ".init_array") != NULL)
+	{
+	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAY,
+				      (bfd_vma) 0)
+	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAYSZ,
+					 (bfd_vma) 0))
+	    return FALSE;
+	}
+      if (bfd_get_section_by_name (output_bfd, ".fini_array") != NULL)
+	{
+	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAY,
+				      (bfd_vma) 0)
+	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAYSZ,
+					 (bfd_vma) 0))
+	    return FALSE;
+	}
+
+      dynstr = bfd_get_section_by_name (dynobj, ".dynstr");
+      /* If .dynstr is excluded from the link, we don't want any of
+	 these tags.  Strictly, we should be checking each section
+	 individually;  This quick check covers for the case where
+	 someone does a /DISCARD/ : { *(*) }.  */
+      if (dynstr != NULL && dynstr->output_section != bfd_abs_section_ptr)
+	{
+	  bfd_size_type strsize;
+
+	  strsize = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_HASH, (bfd_vma) 0)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_STRTAB, (bfd_vma) 0)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_SYMTAB, (bfd_vma) 0)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_STRSZ, strsize)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_SYMENT,
+					  (bfd_vma) sizeof (Elf_External_Sym)))
+	    return FALSE;
+	}
+    }
+
+  /* The backend must work out the sizes of all the other dynamic
+     sections.  */
+  if (bed->elf_backend_size_dynamic_sections
+      && ! (*bed->elf_backend_size_dynamic_sections) (output_bfd, info))
+    return FALSE;
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      bfd_size_type dynsymcount;
+      asection *s;
+      size_t bucketcount = 0;
+      size_t hash_entry_size;
+      unsigned int dtagcount;
+
+      /* Set up the version definition section.  */
+      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
+      BFD_ASSERT (s != NULL);
+
+      /* We may have created additional version definitions if we are
+	 just linking a regular application.  */
+      verdefs = asvinfo.verdefs;
+
+      /* Skip anonymous version tag.  */
+      if (verdefs != NULL && verdefs->vernum == 0)
+	verdefs = verdefs->next;
+
+      if (verdefs == NULL)
+	_bfd_strip_section_from_output (info, s);
+      else
+	{
+	  unsigned int cdefs;
+	  bfd_size_type size;
+	  struct bfd_elf_version_tree *t;
+	  bfd_byte *p;
+	  Elf_Internal_Verdef def;
+	  Elf_Internal_Verdaux defaux;
+
+	  cdefs = 0;
+	  size = 0;
+
+	  /* Make space for the base version.  */
+	  size += sizeof (Elf_External_Verdef);
+	  size += sizeof (Elf_External_Verdaux);
+	  ++cdefs;
+
+	  for (t = verdefs; t != NULL; t = t->next)
+	    {
+	      struct bfd_elf_version_deps *n;
+
+	      size += sizeof (Elf_External_Verdef);
+	      size += sizeof (Elf_External_Verdaux);
+	      ++cdefs;
+
+	      for (n = t->deps; n != NULL; n = n->next)
+		size += sizeof (Elf_External_Verdaux);
+	    }
+
+	  s->_raw_size = size;
+	  s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
+	  if (s->contents == NULL && s->_raw_size != 0)
+	    return FALSE;
+
+	  /* Fill in the version definition section.  */
+
+	  p = s->contents;
+
+	  def.vd_version = VER_DEF_CURRENT;
+	  def.vd_flags = VER_FLG_BASE;
+	  def.vd_ndx = 1;
+	  def.vd_cnt = 1;
+	  def.vd_aux = sizeof (Elf_External_Verdef);
+	  def.vd_next = (sizeof (Elf_External_Verdef)
+			 + sizeof (Elf_External_Verdaux));
+
+	  if (soname_indx != (bfd_size_type) -1)
+	    {
+	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
+				      soname_indx);
+	      def.vd_hash = bfd_elf_hash (soname);
+	      defaux.vda_name = soname_indx;
+	    }
+	  else
+	    {
+	      const char *name;
+	      bfd_size_type indx;
+
+	      name = basename (output_bfd->filename);
+	      def.vd_hash = bfd_elf_hash (name);
+	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					  name, FALSE);
+	      if (indx == (bfd_size_type) -1)
+		return FALSE;
+	      defaux.vda_name = indx;
+	    }
+	  defaux.vda_next = 0;
+
+	  _bfd_elf_swap_verdef_out (output_bfd, &def,
+				    (Elf_External_Verdef *) p);
+	  p += sizeof (Elf_External_Verdef);
+	  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
+				     (Elf_External_Verdaux *) p);
+	  p += sizeof (Elf_External_Verdaux);
+
+	  for (t = verdefs; t != NULL; t = t->next)
+	    {
+	      unsigned int cdeps;
+	      struct bfd_elf_version_deps *n;
+	      struct elf_link_hash_entry *h;
+	      struct bfd_link_hash_entry *bh;
+
+	      cdeps = 0;
+	      for (n = t->deps; n != NULL; n = n->next)
+		++cdeps;
+
+	      /* Add a symbol representing this version.  */
+	      bh = NULL;
+	      if (! (_bfd_generic_link_add_one_symbol
+		     (info, dynobj, t->name, BSF_GLOBAL, bfd_abs_section_ptr,
+		      (bfd_vma) 0, (const char *) NULL, FALSE,
+		      get_elf_backend_data (dynobj)->collect, &bh)))
+		return FALSE;
+	      h = (struct elf_link_hash_entry *) bh;
+	      h->elf_link_hash_flags &= ~ ELF_LINK_NON_ELF;
+	      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+	      h->type = STT_OBJECT;
+	      h->verinfo.vertree = t;
+
+	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+
+	      def.vd_version = VER_DEF_CURRENT;
+	      def.vd_flags = 0;
+	      if (t->globals == NULL && t->locals == NULL && ! t->used)
+		def.vd_flags |= VER_FLG_WEAK;
+	      def.vd_ndx = t->vernum + 1;
+	      def.vd_cnt = cdeps + 1;
+	      def.vd_hash = bfd_elf_hash (t->name);
+	      def.vd_aux = sizeof (Elf_External_Verdef);
+	      if (t->next != NULL)
+		def.vd_next = (sizeof (Elf_External_Verdef)
+			       + (cdeps + 1) * sizeof (Elf_External_Verdaux));
+	      else
+		def.vd_next = 0;
+
+	      _bfd_elf_swap_verdef_out (output_bfd, &def,
+					(Elf_External_Verdef *) p);
+	      p += sizeof (Elf_External_Verdef);
+
+	      defaux.vda_name = h->dynstr_index;
+	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
+				      h->dynstr_index);
+	      if (t->deps == NULL)
+		defaux.vda_next = 0;
+	      else
+		defaux.vda_next = sizeof (Elf_External_Verdaux);
+	      t->name_indx = defaux.vda_name;
+
+	      _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
+					 (Elf_External_Verdaux *) p);
+	      p += sizeof (Elf_External_Verdaux);
+
+	      for (n = t->deps; n != NULL; n = n->next)
+		{
+		  if (n->version_needed == NULL)
+		    {
+		      /* This can happen if there was an error in the
+			 version script.  */
+		      defaux.vda_name = 0;
+		    }
+		  else
+		    {
+		      defaux.vda_name = n->version_needed->name_indx;
+		      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
+					      defaux.vda_name);
+		    }
+		  if (n->next == NULL)
+		    defaux.vda_next = 0;
+		  else
+		    defaux.vda_next = sizeof (Elf_External_Verdaux);
+
+		  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
+					     (Elf_External_Verdaux *) p);
+		  p += sizeof (Elf_External_Verdaux);
+		}
+	    }
+
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_VERDEF, (bfd_vma) 0)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_VERDEFNUM,
+					  (bfd_vma) cdefs))
+	    return FALSE;
+
+	  elf_tdata (output_bfd)->cverdefs = cdefs;
+	}
+
+      if ((info->new_dtags && info->flags) || (info->flags & DF_STATIC_TLS))
+	{
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_FLAGS, info->flags))
+	    return FALSE;
+	}
+
+      if (info->flags_1)
+	{
+	  if (! info->shared)
+	    info->flags_1 &= ~ (DF_1_INITFIRST
+				| DF_1_NODELETE
+				| DF_1_NOOPEN);
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_FLAGS_1,
+				       info->flags_1))
+	    return FALSE;
+	}
+
+      /* Work out the size of the version reference section.  */
+
+      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
+      BFD_ASSERT (s != NULL);
+      {
+	struct elf_find_verdep_info sinfo;
+
+	sinfo.output_bfd = output_bfd;
+	sinfo.info = info;
+	sinfo.vers = elf_tdata (output_bfd)->cverdefs;
+	if (sinfo.vers == 0)
+	  sinfo.vers = 1;
+	sinfo.failed = FALSE;
+
+	elf_link_hash_traverse (elf_hash_table (info),
+				elf_link_find_version_dependencies,
+				(PTR) &sinfo);
+
+	if (elf_tdata (output_bfd)->verref == NULL)
+	  _bfd_strip_section_from_output (info, s);
+	else
+	  {
+	    Elf_Internal_Verneed *t;
+	    unsigned int size;
+	    unsigned int crefs;
+	    bfd_byte *p;
+
+	    /* Build the version definition section.  */
+	    size = 0;
+	    crefs = 0;
+	    for (t = elf_tdata (output_bfd)->verref;
+		 t != NULL;
+		 t = t->vn_nextref)
+	      {
+		Elf_Internal_Vernaux *a;
+
+		size += sizeof (Elf_External_Verneed);
+		++crefs;
+		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+		  size += sizeof (Elf_External_Vernaux);
+	      }
+
+	    s->_raw_size = size;
+	    s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
+	    if (s->contents == NULL)
+	      return FALSE;
+
+	    p = s->contents;
+	    for (t = elf_tdata (output_bfd)->verref;
+		 t != NULL;
+		 t = t->vn_nextref)
+	      {
+		unsigned int caux;
+		Elf_Internal_Vernaux *a;
+		bfd_size_type indx;
+
+		caux = 0;
+		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+		  ++caux;
+
+		t->vn_version = VER_NEED_CURRENT;
+		t->vn_cnt = caux;
+		indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					    elf_dt_name (t->vn_bfd) != NULL
+					    ? elf_dt_name (t->vn_bfd)
+					    : basename (t->vn_bfd->filename),
+					    FALSE);
+		if (indx == (bfd_size_type) -1)
+		  return FALSE;
+		t->vn_file = indx;
+		t->vn_aux = sizeof (Elf_External_Verneed);
+		if (t->vn_nextref == NULL)
+		  t->vn_next = 0;
+		else
+		  t->vn_next = (sizeof (Elf_External_Verneed)
+				+ caux * sizeof (Elf_External_Vernaux));
+
+		_bfd_elf_swap_verneed_out (output_bfd, t,
+					   (Elf_External_Verneed *) p);
+		p += sizeof (Elf_External_Verneed);
+
+		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+		  {
+		    a->vna_hash = bfd_elf_hash (a->vna_nodename);
+		    indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+						a->vna_nodename, FALSE);
+		    if (indx == (bfd_size_type) -1)
+		      return FALSE;
+		    a->vna_name = indx;
+		    if (a->vna_nextptr == NULL)
+		      a->vna_next = 0;
+		    else
+		      a->vna_next = sizeof (Elf_External_Vernaux);
+
+		    _bfd_elf_swap_vernaux_out (output_bfd, a,
+					       (Elf_External_Vernaux *) p);
+		    p += sizeof (Elf_External_Vernaux);
+		  }
+	      }
+
+	    if (! elf_add_dynamic_entry (info, (bfd_vma) DT_VERNEED,
+					 (bfd_vma) 0)
+		|| ! elf_add_dynamic_entry (info, (bfd_vma) DT_VERNEEDNUM,
+					    (bfd_vma) crefs))
+	      return FALSE;
+
+	    elf_tdata (output_bfd)->cverrefs = crefs;
+	  }
+      }
+
+      /* Assign dynsym indicies.  In a shared library we generate a
+	 section symbol for each output section, which come first.
+	 Next come all of the back-end allocated local dynamic syms,
+	 followed by the rest of the global symbols.  */
+
+      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);
+
+      /* Work out the size of the symbol version section.  */
+      s = bfd_get_section_by_name (dynobj, ".gnu.version");
+      BFD_ASSERT (s != NULL);
+      if (dynsymcount == 0
+	  || (verdefs == NULL && elf_tdata (output_bfd)->verref == NULL))
+	{
+	  _bfd_strip_section_from_output (info, s);
+	  /* The DYNSYMCOUNT might have changed if we were going to
+	     output a dynamic symbol table entry for S.  */
+	  dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);
+	}
+      else
+	{
+	  s->_raw_size = dynsymcount * sizeof (Elf_External_Versym);
+	  s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
+	  if (s->contents == NULL)
+	    return FALSE;
+
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_VERSYM, (bfd_vma) 0))
+	    return FALSE;
+	}
+
+      /* Set the size of the .dynsym and .hash sections.  We counted
+	 the number of dynamic symbols in elf_link_add_object_symbols.
+	 We will build the contents of .dynsym and .hash when we build
+	 the final symbol table, because until then we do not know the
+	 correct value to give the symbols.  We built the .dynstr
+	 section as we went along in elf_link_add_object_symbols.  */
+      s = bfd_get_section_by_name (dynobj, ".dynsym");
+      BFD_ASSERT (s != NULL);
+      s->_raw_size = dynsymcount * sizeof (Elf_External_Sym);
+      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
+      if (s->contents == NULL && s->_raw_size != 0)
+	return FALSE;
+
+      if (dynsymcount != 0)
+	{
+	  Elf_Internal_Sym isym;
+
+	  /* The first entry in .dynsym is a dummy symbol.  */
+	  isym.st_value = 0;
+	  isym.st_size = 0;
+	  isym.st_name = 0;
+	  isym.st_info = 0;
+	  isym.st_other = 0;
+	  isym.st_shndx = 0;
+	  elf_swap_symbol_out (output_bfd, &isym, (PTR) s->contents, (PTR) 0);
+	}
+
+      /* Compute the size of the hashing table.  As a side effect this
+	 computes the hash values for all the names we export.  */
+      bucketcount = compute_bucket_count (info);
+
+      s = bfd_get_section_by_name (dynobj, ".hash");
+      BFD_ASSERT (s != NULL);
+      hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;
+      s->_raw_size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
+      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
+      if (s->contents == NULL)
+	return FALSE;
+
+      bfd_put (8 * hash_entry_size, output_bfd, (bfd_vma) bucketcount,
+	       s->contents);
+      bfd_put (8 * hash_entry_size, output_bfd, (bfd_vma) dynsymcount,
+	       s->contents + hash_entry_size);
+
+      elf_hash_table (info)->bucketcount = bucketcount;
+
+      s = bfd_get_section_by_name (dynobj, ".dynstr");
+      BFD_ASSERT (s != NULL);
+
+      elf_finalize_dynstr (output_bfd, info);
+
+      s->_raw_size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
+
+      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)
+	if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NULL, (bfd_vma) 0))
+	  return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* This function is used to adjust offsets into .dynstr for
+   dynamic symbols.  This is called via elf_link_hash_traverse.  */
+
+static bfd_boolean elf_adjust_dynstr_offsets
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+
+static bfd_boolean
+elf_adjust_dynstr_offsets (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_strtab_hash *dynstr = (struct elf_strtab_hash *) data;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if (h->dynindx != -1)
+    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
+  return TRUE;
+}
+
+/* Assign string offsets in .dynstr, update all structures referencing
+   them.  */
+
+static bfd_boolean
+elf_finalize_dynstr (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  struct elf_link_local_dynamic_entry *entry;
+  struct elf_strtab_hash *dynstr = elf_hash_table (info)->dynstr;
+  bfd *dynobj = elf_hash_table (info)->dynobj;
+  asection *sdyn;
+  bfd_size_type size;
+  Elf_External_Dyn *dyncon, *dynconend;
+
+  _bfd_elf_strtab_finalize (dynstr);
+  size = _bfd_elf_strtab_size (dynstr);
+
+  /* Update all .dynamic entries referencing .dynstr strings.  */
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+  BFD_ASSERT (sdyn != NULL);
+
+  dyncon = (Elf_External_Dyn *) sdyn->contents;
+  dynconend = (Elf_External_Dyn *) (sdyn->contents +
+				    sdyn->_raw_size);
+  for (; dyncon < dynconend; dyncon++)
+    {
+      Elf_Internal_Dyn dyn;
+
+      elf_swap_dyn_in (dynobj, dyncon, & dyn);
+      switch (dyn.d_tag)
+	{
+	case DT_STRSZ:
+	  dyn.d_un.d_val = size;
+	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
+	  break;
+	case DT_NEEDED:
+	case DT_SONAME:
+	case DT_RPATH:
+	case DT_RUNPATH:
+	case DT_FILTER:
+	case DT_AUXILIARY:
+	  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
+	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
+	  break;
+	default:
+	  break;
+	}
+    }
+
+  /* Now update local dynamic symbols.  */
+  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
+    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
+						  entry->isym.st_name);
+
+  /* And the rest of dynamic symbols.  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_adjust_dynstr_offsets, dynstr);
+
+  /* Adjust version definitions.  */
+  if (elf_tdata (output_bfd)->cverdefs)
+    {
+      asection *s;
+      bfd_byte *p;
+      bfd_size_type i;
+      Elf_Internal_Verdef def;
+      Elf_Internal_Verdaux defaux;
+
+      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
+      p = (bfd_byte *) s->contents;
+      do
+	{
+	  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
+				   &def);
+	  p += sizeof (Elf_External_Verdef);
+	  for (i = 0; i < def.vd_cnt; ++i)
+	    {
+	      _bfd_elf_swap_verdaux_in (output_bfd,
+					(Elf_External_Verdaux *) p, &defaux);
+	      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
+							defaux.vda_name);
+	      _bfd_elf_swap_verdaux_out (output_bfd,
+					 &defaux, (Elf_External_Verdaux *) p);
+	      p += sizeof (Elf_External_Verdaux);
+	    }
+	}
+      while (def.vd_next);
+    }
+
+  /* Adjust version references.  */
+  if (elf_tdata (output_bfd)->verref)
+    {
+      asection *s;
+      bfd_byte *p;
+      bfd_size_type i;
+      Elf_Internal_Verneed need;
+      Elf_Internal_Vernaux needaux;
+
+      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
+      p = (bfd_byte *) s->contents;
+      do
+	{
+	  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
+				    &need);
+	  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
+	  _bfd_elf_swap_verneed_out (output_bfd, &need,
+				     (Elf_External_Verneed *) p);
+	  p += sizeof (Elf_External_Verneed);
+	  for (i = 0; i < need.vn_cnt; ++i)
+	    {
+	      _bfd_elf_swap_vernaux_in (output_bfd,
+					(Elf_External_Vernaux *) p, &needaux);
+	      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
+							 needaux.vna_name);
+	      _bfd_elf_swap_vernaux_out (output_bfd,
+					 &needaux,
+					 (Elf_External_Vernaux *) p);
+	      p += sizeof (Elf_External_Vernaux);
+	    }
+	}
+      while (need.vn_next);
+    }
+
+  return TRUE;
+}
+
+/* Fix up the flags for a symbol.  This handles various cases which
+   can only be fixed after all the input files are seen.  This is
+   currently called by both adjust_dynamic_symbol and
+   assign_sym_version, which is unnecessary but perhaps more robust in
+   the face of future changes.  */
+
+static bfd_boolean
+elf_fix_symbol_flags (h, eif)
+     struct elf_link_hash_entry *h;
+     struct elf_info_failed *eif;
+{
+  /* If this symbol was mentioned in a non-ELF file, try to set
+     DEF_REGULAR and REF_REGULAR correctly.  This is the only way to
+     permit a non-ELF file to correctly refer to a symbol defined in
+     an ELF dynamic object.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_NON_ELF) != 0)
+    {
+      while (h->root.type == bfd_link_hash_indirect)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      if (h->root.type != bfd_link_hash_defined
+	  && h->root.type != bfd_link_hash_defweak)
+	h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
+				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
+      else
+	{
+	  if (h->root.u.def.section->owner != NULL
+	      && (bfd_get_flavour (h->root.u.def.section->owner)
+		  == bfd_target_elf_flavour))
+	    h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
+				       | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
+	  else
+	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+	}
+
+      if (h->dynindx == -1
+	  && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+	      || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0))
+	{
+	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
+	    {
+	      eif->failed = TRUE;
+	      return FALSE;
+	    }
+	}
+    }
+  else
+    {
+      /* Unfortunately, ELF_LINK_NON_ELF is only correct if the symbol
+	 was first seen in a non-ELF file.  Fortunately, if the symbol
+	 was first seen in an ELF file, we're probably OK unless the
+	 symbol was defined in a non-ELF file.  Catch that case here.
+	 FIXME: We're still in trouble if the symbol was first seen in
+	 a dynamic object, and then later in a non-ELF regular object.  */
+      if ((h->root.type == bfd_link_hash_defined
+	   || h->root.type == bfd_link_hash_defweak)
+	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
+	  && (h->root.u.def.section->owner != NULL
+	      ? (bfd_get_flavour (h->root.u.def.section->owner)
+		 != bfd_target_elf_flavour)
+	      : (bfd_is_abs_section (h->root.u.def.section)
+		 && (h->elf_link_hash_flags
+		     & ELF_LINK_HASH_DEF_DYNAMIC) == 0)))
+	h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+    }
+
+  /* If this is a final link, and the symbol was defined as a common
+     symbol in a regular object file, and there was no definition in
+     any dynamic object, then the linker will have allocated space for
+     the symbol in a common section but the ELF_LINK_HASH_DEF_REGULAR
+     flag will not have been set.  */
+  if (h->root.type == bfd_link_hash_defined
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
+      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
+    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+
+  /* If -Bsymbolic was used (which means to bind references to global
+     symbols to the definition within the shared object), and this
+     symbol was defined in a regular object, then it actually doesn't
+     need a PLT entry, and we can accomplish that by forcing it local.
+     Likewise, if the symbol has hidden or internal visibility.
+     FIXME: It might be that we also do not need a PLT for other
+     non-hidden visibilities, but we would have to tell that to the
+     backend specifically; we can't just clear PLT-related data here.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
+      && eif->info->shared
+      && is_elf_hash_table (eif->info)
+      && (eif->info->symbolic
+	  || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
+	  || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
+    {
+      struct elf_backend_data *bed;
+      bfd_boolean force_local;
+
+      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
+
+      force_local = (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
+		     || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN);
+      (*bed->elf_backend_hide_symbol) (eif->info, h, force_local);
+    }
+
+  /* If this is a weak defined symbol in a dynamic object, and we know
+     the real definition in the dynamic object, copy interesting flags
+     over to the real definition.  */
+  if (h->weakdef != NULL)
+    {
+      struct elf_link_hash_entry *weakdef;
+
+      weakdef = h->weakdef;
+      if (h->root.type == bfd_link_hash_indirect)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      BFD_ASSERT (h->root.type == bfd_link_hash_defined
+		  || h->root.type == bfd_link_hash_defweak);
+      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
+		  || weakdef->root.type == bfd_link_hash_defweak);
+      BFD_ASSERT (weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC);
+
+      /* If the real definition is defined by a regular object file,
+	 don't do anything special.  See the longer description in
+	 elf_adjust_dynamic_symbol, below.  */
+      if ((weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
+	h->weakdef = NULL;
+      else
+	{
+	  struct elf_backend_data *bed;
+
+	  bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
+	  (*bed->elf_backend_copy_indirect_symbol) (bed, weakdef, h);
+	}
+    }
+
+  return TRUE;
+}
+
+/* Make the backend pick a good value for a dynamic symbol.  This is
+   called via elf_link_hash_traverse, and also calls itself
+   recursively.  */
+
+static bfd_boolean
+elf_adjust_dynamic_symbol (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_info_failed *eif = (struct elf_info_failed *) data;
+  bfd *dynobj;
+  struct elf_backend_data *bed;
+
+  if (! is_elf_hash_table (eif->info))
+    return FALSE;
+
+  if (h->root.type == bfd_link_hash_warning)
+    {
+      h->plt = elf_hash_table (eif->info)->init_offset;
+      h->got = elf_hash_table (eif->info)->init_offset;
+
+      /* When warning symbols are created, they **replace** the "real"
+	 entry in the hash table, thus we never get to see the real
+	 symbol in a hash traversal.  So look at it now.  */
+      h = (struct elf_link_hash_entry *) h->root.u.i.link;
+    }
+
+  /* Ignore indirect symbols.  These are added by the versioning code.  */
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  /* Fix the symbol flags.  */
+  if (! elf_fix_symbol_flags (h, eif))
+    return FALSE;
+
+  /* If this symbol does not require a PLT entry, and it is not
+     defined by a dynamic object, or is not referenced by a regular
+     object, ignore it.  We do have to handle a weak defined symbol,
+     even if no regular object refers to it, if we decided to add it
+     to the dynamic symbol table.  FIXME: Do we normally need to worry
+     about symbols which are defined by one dynamic object and
+     referenced by another one?  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0
+      && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
+	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
+	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
+	      && (h->weakdef == NULL || h->weakdef->dynindx == -1))))
+    {
+      h->plt = elf_hash_table (eif->info)->init_offset;
+      return TRUE;
+    }
+
+  /* If we've already adjusted this symbol, don't do it again.  This
+     can happen via a recursive call.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
+    return TRUE;
+
+  /* Don't look at this symbol again.  Note that we must set this
+     after checking the above conditions, because we may look at a
+     symbol once, decide not to do anything, and then get called
+     recursively later after REF_REGULAR is set below.  */
+  h->elf_link_hash_flags |= ELF_LINK_HASH_DYNAMIC_ADJUSTED;
+
+  /* If this is a weak definition, and we know a real definition, and
+     the real symbol is not itself defined by a regular object file,
+     then get a good value for the real definition.  We handle the
+     real symbol first, for the convenience of the backend routine.
+
+     Note that there is a confusing case here.  If the real definition
+     is defined by a regular object file, we don't get the real symbol
+     from the dynamic object, but we do get the weak symbol.  If the
+     processor backend uses a COPY reloc, then if some routine in the
+     dynamic object changes the real symbol, we will not see that
+     change in the corresponding weak symbol.  This is the way other
+     ELF linkers work as well, and seems to be a result of the shared
+     library model.
+
+     I will clarify this issue.  Most SVR4 shared libraries define the
+     variable _timezone and define timezone as a weak synonym.  The
+     tzset call changes _timezone.  If you write
+       extern int timezone;
+       int _timezone = 5;
+       int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }
+     you might expect that, since timezone is a synonym for _timezone,
+     the same number will print both times.  However, if the processor
+     backend uses a COPY reloc, then actually timezone will be copied
+     into your process image, and, since you define _timezone
+     yourself, _timezone will not.  Thus timezone and _timezone will
+     wind up at different memory locations.  The tzset call will set
+     _timezone, leaving timezone unchanged.  */
+
+  if (h->weakdef != NULL)
+    {
+      /* If we get to this point, we know there is an implicit
+	 reference by a regular object file via the weak symbol H.
+	 FIXME: Is this really true?  What if the traversal finds
+	 H->WEAKDEF before it finds H?  */
+      h->weakdef->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
+
+      if (! elf_adjust_dynamic_symbol (h->weakdef, (PTR) eif))
+	return FALSE;
+    }
+
+  /* If a symbol has no type and no size and does not require a PLT
+     entry, then we are probably about to do the wrong thing here: we
+     are probably going to create a COPY reloc for an empty object.
+     This case can arise when a shared object is built with assembly
+     code, and the assembly code fails to set the symbol type.  */
+  if (h->size == 0
+      && h->type == STT_NOTYPE
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
+    (*_bfd_error_handler)
+      (_("warning: type and size of dynamic symbol `%s' are not defined"),
+       h->root.root.string);
+
+  dynobj = elf_hash_table (eif->info)->dynobj;
+  bed = get_elf_backend_data (dynobj);
+  if (! (*bed->elf_backend_adjust_dynamic_symbol) (eif->info, h))
+    {
+      eif->failed = TRUE;
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* This routine is used to export all defined symbols into the dynamic
+   symbol table.  It is called via elf_link_hash_traverse.  */
+
+static bfd_boolean
+elf_export_symbol (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_info_failed *eif = (struct elf_info_failed *) data;
+
+  /* Ignore indirect symbols.  These are added by the versioning code.  */
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if (h->dynindx == -1
+      && (h->elf_link_hash_flags
+	  & (ELF_LINK_HASH_DEF_REGULAR | ELF_LINK_HASH_REF_REGULAR)) != 0)
+    {
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_expr *d;
+
+      for (t = eif->verdefs; t != NULL; t = t->next)
+	{
+	  if (t->globals != NULL)
+	    {
+	      for (d = t->globals; d != NULL; d = d->next)
+		{
+		  if ((*d->match) (d, h->root.root.string))
+		    goto doit;
+		}
+	    }
+
+	  if (t->locals != NULL)
+	    {
+	      for (d = t->locals ; d != NULL; d = d->next)
+		{
+		  if ((*d->match) (d, h->root.root.string))
+		    return TRUE;
+		}
+	    }
+	}
+
+      if (!eif->verdefs)
+	{
+	doit:
+	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
+	    {
+	      eif->failed = TRUE;
+	      return FALSE;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* Look through the symbols which are defined in other shared
+   libraries and referenced here.  Update the list of version
+   dependencies.  This will be put into the .gnu.version_r section.
+   This function is called via elf_link_hash_traverse.  */
+
+static bfd_boolean
+elf_link_find_version_dependencies (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_find_verdep_info *rinfo = (struct elf_find_verdep_info *) data;
+  Elf_Internal_Verneed *t;
+  Elf_Internal_Vernaux *a;
+  bfd_size_type amt;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* We only care about symbols defined in shared objects with version
+     information.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
+      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
+      || h->dynindx == -1
+      || h->verinfo.verdef == NULL)
+    return TRUE;
+
+  /* See if we already know about this version.  */
+  for (t = elf_tdata (rinfo->output_bfd)->verref; t != NULL; t = t->vn_nextref)
+    {
+      if (t->vn_bfd != h->verinfo.verdef->vd_bfd)
+	continue;
+
+      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
+	  return TRUE;
+
+      break;
+    }
+
+  /* This is a new version.  Add it to tree we are building.  */
+
+  if (t == NULL)
+    {
+      amt = sizeof *t;
+      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->output_bfd, amt);
+      if (t == NULL)
+	{
+	  rinfo->failed = TRUE;
+	  return FALSE;
+	}
+
+      t->vn_bfd = h->verinfo.verdef->vd_bfd;
+      t->vn_nextref = elf_tdata (rinfo->output_bfd)->verref;
+      elf_tdata (rinfo->output_bfd)->verref = t;
+    }
+
+  amt = sizeof *a;
+  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->output_bfd, amt);
+
+  /* Note that we are copying a string pointer here, and testing it
+     above.  If bfd_elf_string_from_elf_section is ever changed to
+     discard the string data when low in memory, this will have to be
+     fixed.  */
+  a->vna_nodename = h->verinfo.verdef->vd_nodename;
+
+  a->vna_flags = h->verinfo.verdef->vd_flags;
+  a->vna_nextptr = t->vn_auxptr;
+
+  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
+  ++rinfo->vers;
+
+  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;
+
+  t->vn_auxptr = a;
+
+  return TRUE;
+}
+
+/* Figure out appropriate versions for all the symbols.  We may not
+   have the version number script until we have read all of the input
+   files, so until that point we don't know which symbols should be
+   local.  This function is called via elf_link_hash_traverse.  */
+
+static bfd_boolean
+elf_link_assign_sym_version (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_assign_sym_version_info *sinfo;
+  struct bfd_link_info *info;
+  struct elf_backend_data *bed;
+  struct elf_info_failed eif;
+  char *p;
+  bfd_size_type amt;
+
+  sinfo = (struct elf_assign_sym_version_info *) data;
+  info = sinfo->info;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Fix the symbol flags.  */
+  eif.failed = FALSE;
+  eif.info = info;
+  if (! elf_fix_symbol_flags (h, &eif))
+    {
+      if (eif.failed)
+	sinfo->failed = TRUE;
+      return FALSE;
+    }
+
+  /* We only need version numbers for symbols defined in regular
+     objects.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+    return TRUE;
+
+  bed = get_elf_backend_data (sinfo->output_bfd);
+  p = strchr (h->root.root.string, ELF_VER_CHR);
+  if (p != NULL && h->verinfo.vertree == NULL)
+    {
+      struct bfd_elf_version_tree *t;
+      bfd_boolean hidden;
+
+      hidden = TRUE;
+
+      /* There are two consecutive ELF_VER_CHR characters if this is
+	 not a hidden symbol.  */
+      ++p;
+      if (*p == ELF_VER_CHR)
+	{
+	  hidden = FALSE;
+	  ++p;
+	}
+
+      /* If there is no version string, we can just return out.  */
+      if (*p == '\0')
+	{
+	  if (hidden)
+	    h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
+	  return TRUE;
+	}
+
+      /* Look for the version.  If we find it, it is no longer weak.  */
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (strcmp (t->name, p) == 0)
+	    {
+	      size_t len;
+	      char *alc;
+	      struct bfd_elf_version_expr *d;
+
+	      len = p - h->root.root.string;
+	      alc = bfd_malloc ((bfd_size_type) len);
+	      if (alc == NULL)
+		return FALSE;
+	      memcpy (alc, h->root.root.string, len - 1);
+	      alc[len - 1] = '\0';
+	      if (alc[len - 2] == ELF_VER_CHR)
+		alc[len - 2] = '\0';
+
+	      h->verinfo.vertree = t;
+	      t->used = TRUE;
+	      d = NULL;
+
+	      if (t->globals != NULL)
+		{
+		  for (d = t->globals; d != NULL; d = d->next)
+		    if ((*d->match) (d, alc))
+		      break;
+		}
+
+	      /* See if there is anything to force this symbol to
+		 local scope.  */
+	      if (d == NULL && t->locals != NULL)
+		{
+		  for (d = t->locals; d != NULL; d = d->next)
+		    {
+		      if ((*d->match) (d, alc))
+			{
+			  if (h->dynindx != -1
+			      && info->shared
+			      && ! info->export_dynamic)
+			    {
+			      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
+			    }
+
+			  break;
+			}
+		    }
+		}
+
+	      free (alc);
+	      break;
+	    }
+	}
+
+      /* If we are building an application, we need to create a
+	 version node for this version.  */
+      if (t == NULL && ! info->shared)
+	{
+	  struct bfd_elf_version_tree **pp;
+	  int version_index;
+
+	  /* If we aren't going to export this symbol, we don't need
+	     to worry about it.  */
+	  if (h->dynindx == -1)
+	    return TRUE;
+
+	  amt = sizeof *t;
+	  t = ((struct bfd_elf_version_tree *)
+	       bfd_alloc (sinfo->output_bfd, amt));
+	  if (t == NULL)
+	    {
+	      sinfo->failed = TRUE;
+	      return FALSE;
+	    }
+
+	  t->next = NULL;
+	  t->name = p;
+	  t->globals = NULL;
+	  t->locals = NULL;
+	  t->deps = NULL;
+	  t->name_indx = (unsigned int) -1;
+	  t->used = TRUE;
+
+	  version_index = 1;
+	  /* Don't count anonymous version tag.  */
+	  if (sinfo->verdefs != NULL && sinfo->verdefs->vernum == 0)
+	    version_index = 0;
+	  for (pp = &sinfo->verdefs; *pp != NULL; pp = &(*pp)->next)
+	    ++version_index;
+	  t->vernum = version_index;
+
+	  *pp = t;
+
+	  h->verinfo.vertree = t;
+	}
+      else if (t == NULL)
+	{
+	  /* We could not find the version for a symbol when
+	     generating a shared archive.  Return an error.  */
+	  (*_bfd_error_handler)
+	    (_("%s: undefined versioned symbol name %s"),
+	     bfd_get_filename (sinfo->output_bfd), h->root.root.string);
+	  bfd_set_error (bfd_error_bad_value);
+	  sinfo->failed = TRUE;
+	  return FALSE;
+	}
+
+      if (hidden)
+	h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
+    }
+
+  /* If we don't have a version for this symbol, see if we can find
+     something.  */
+  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
+    {
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_tree *local_ver;
+      struct bfd_elf_version_expr *d;
+
+      /* See if can find what version this symbol is in.  If the
+	 symbol is supposed to be local, then don't actually register
+	 it.  */
+      local_ver = NULL;
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (t->globals != NULL)
+	    {
+	      bfd_boolean matched;
+
+	      matched = FALSE;
+	      for (d = t->globals; d != NULL; d = d->next)
+		{
+		  if ((*d->match) (d, h->root.root.string))
+		    {
+		      if (d->symver)
+			matched = TRUE;
+		      else
+			{
+			  /* There is a version without definition.  Make
+			     the symbol the default definition for this
+			     version.  */
+			  h->verinfo.vertree = t;
+			  local_ver = NULL;
+			  d->script = 1;
+			  break;
+			}
+		    }
+		}
+
+	      if (d != NULL)
+		break;
+	      else if (matched)
+		/* There is no undefined version for this symbol. Hide the
+		   default one.  */
+		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
+	    }
+
+	  if (t->locals != NULL)
+	    {
+	      for (d = t->locals; d != NULL; d = d->next)
+		{
+		  /* If the match is "*", keep looking for a more
+		     explicit, perhaps even global, match.  */
+		  if (d->pattern[0] == '*' && d->pattern[1] == '\0')
+		    local_ver = t;
+		  else if ((*d->match) (d, h->root.root.string))
+		    {
+		      local_ver = t;
+		      break;
+		    }
+		}
+
+	      if (d != NULL)
+		break;
+	    }
+	}
+
+      if (local_ver != NULL)
+	{
+	  h->verinfo.vertree = local_ver;
+	  if (h->dynindx != -1
+	      && info->shared
+	      && ! info->export_dynamic)
+	    {
+	      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* Final phase of ELF linker.  */
+
+/* A structure we use to avoid passing large numbers of arguments.  */
+
+struct elf_final_link_info
+{
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* Symbol string table.  */
+  struct bfd_strtab_hash *symstrtab;
+  /* .dynsym section.  */
+  asection *dynsym_sec;
+  /* .hash section.  */
+  asection *hash_sec;
+  /* symbol version section (.gnu.version).  */
+  asection *symver_sec;
+  /* first SHF_TLS section (if any).  */
+  asection *first_tls_sec;
+  /* Buffer large enough to hold contents of any section.  */
+  bfd_byte *contents;
+  /* Buffer large enough to hold external relocs of any section.  */
+  PTR external_relocs;
+  /* Buffer large enough to hold internal relocs of any section.  */
+  Elf_Internal_Rela *internal_relocs;
+  /* Buffer large enough to hold external local symbols of any input
+     BFD.  */
+  Elf_External_Sym *external_syms;
+  /* And a buffer for symbol section indices.  */
+  Elf_External_Sym_Shndx *locsym_shndx;
+  /* Buffer large enough to hold internal local symbols of any input
+     BFD.  */
+  Elf_Internal_Sym *internal_syms;
+  /* Array large enough to hold a symbol index for each local symbol
+     of any input BFD.  */
+  long *indices;
+  /* Array large enough to hold a section pointer for each local
+     symbol of any input BFD.  */
+  asection **sections;
+  /* Buffer to hold swapped out symbols.  */
+  Elf_External_Sym *symbuf;
+  /* And one for symbol section indices.  */
+  Elf_External_Sym_Shndx *symshndxbuf;
+  /* Number of swapped out symbols in buffer.  */
+  size_t symbuf_count;
+  /* Number of symbols which fit in symbuf.  */
+  size_t symbuf_size;
+  /* And same for symshndxbuf.  */
+  size_t shndxbuf_size;
+};
+
+static bfd_boolean elf_link_output_sym
+  PARAMS ((struct elf_final_link_info *, const char *,
+	   Elf_Internal_Sym *, asection *));
+static bfd_boolean elf_link_flush_output_syms
+  PARAMS ((struct elf_final_link_info *));
+static bfd_boolean elf_link_output_extsym
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static bfd_boolean elf_link_sec_merge_syms
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static bfd_boolean elf_link_check_versioned_symbol
+  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
+static bfd_boolean elf_link_input_bfd
+  PARAMS ((struct elf_final_link_info *, bfd *));
+static bfd_boolean elf_reloc_link_order
+  PARAMS ((bfd *, struct bfd_link_info *, asection *,
+	   struct bfd_link_order *));
+
+/* This struct is used to pass information to elf_link_output_extsym.  */
+
+struct elf_outext_info
+{
+  bfd_boolean failed;
+  bfd_boolean localsyms;
+  struct elf_final_link_info *finfo;
+};
+
+/* Compute the size of, and allocate space for, REL_HDR which is the
+   section header for a section containing relocations for O.  */
+
+static bfd_boolean
+elf_link_size_reloc_section (abfd, rel_hdr, o)
+     bfd *abfd;
+     Elf_Internal_Shdr *rel_hdr;
+     asection *o;
+{
+  bfd_size_type reloc_count;
+  bfd_size_type num_rel_hashes;
+
+  /* Figure out how many relocations there will be.  */
+  if (rel_hdr == &elf_section_data (o)->rel_hdr)
+    reloc_count = elf_section_data (o)->rel_count;
+  else
+    reloc_count = elf_section_data (o)->rel_count2;
+
+  num_rel_hashes = o->reloc_count;
+  if (num_rel_hashes < reloc_count)
+    num_rel_hashes = reloc_count;
+
+  /* That allows us to calculate the size of the section.  */
+  rel_hdr->sh_size = rel_hdr->sh_entsize * reloc_count;
+
+  /* The contents field must last into write_object_contents, so we
+     allocate it with bfd_alloc rather than malloc.  Also since we
+     cannot be sure that the contents will actually be filled in,
+     we zero the allocated space.  */
+  rel_hdr->contents = (PTR) bfd_zalloc (abfd, rel_hdr->sh_size);
+  if (rel_hdr->contents == NULL && rel_hdr->sh_size != 0)
+    return FALSE;
+
+  /* We only allocate one set of hash entries, so we only do it the
+     first time we are called.  */
+  if (elf_section_data (o)->rel_hashes == NULL
+      && num_rel_hashes)
+    {
+      struct elf_link_hash_entry **p;
+
+      p = ((struct elf_link_hash_entry **)
+	   bfd_zmalloc (num_rel_hashes
+			* sizeof (struct elf_link_hash_entry *)));
+      if (p == NULL)
+	return FALSE;
+
+      elf_section_data (o)->rel_hashes = p;
+    }
+
+  return TRUE;
+}
+
+/* When performing a relocateable link, the input relocations are
+   preserved.  But, if they reference global symbols, the indices
+   referenced must be updated.  Update all the relocations in
+   REL_HDR (there are COUNT of them), using the data in REL_HASH.  */
+
+static void
+elf_link_adjust_relocs (abfd, rel_hdr, count, rel_hash)
+     bfd *abfd;
+     Elf_Internal_Shdr *rel_hdr;
+     unsigned int count;
+     struct elf_link_hash_entry **rel_hash;
+{
+  unsigned int i;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  bfd_byte *erela;
+  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
+  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
+
+  if (rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
+    {
+      swap_in = bed->s->swap_reloc_in;
+      swap_out = bed->s->swap_reloc_out;
+    }
+  else if (rel_hdr->sh_entsize == sizeof (Elf_External_Rela))
+    {
+      swap_in = bed->s->swap_reloca_in;
+      swap_out = bed->s->swap_reloca_out;
+    }
+  else
+    abort ();
+
+  if (bed->s->int_rels_per_ext_rel > MAX_INT_RELS_PER_EXT_REL)
+    abort ();
+
+  erela = rel_hdr->contents;
+  for (i = 0; i < count; i++, rel_hash++, erela += rel_hdr->sh_entsize)
+    {
+      Elf_Internal_Rela irela[MAX_INT_RELS_PER_EXT_REL];
+      unsigned int j;
+
+      if (*rel_hash == NULL)
+	continue;
+
+      BFD_ASSERT ((*rel_hash)->indx >= 0);
+
+      (*swap_in) (abfd, erela, irela);
+      for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
+	irela[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
+				      ELF_R_TYPE (irela[j].r_info));
+      (*swap_out) (abfd, irela, erela);
+    }
+}
+
+struct elf_link_sort_rela
+{
+  bfd_vma offset;
+  enum elf_reloc_type_class type;
+  /* We use this as an array of size int_rels_per_ext_rel.  */
+  Elf_Internal_Rela rela[1];
+};
+
+static int
+elf_link_sort_cmp1 (A, B)
+     const PTR A;
+     const PTR B;
+{
+  struct elf_link_sort_rela *a = (struct elf_link_sort_rela *) A;
+  struct elf_link_sort_rela *b = (struct elf_link_sort_rela *) B;
+  int relativea, relativeb;
+
+  relativea = a->type == reloc_class_relative;
+  relativeb = b->type == reloc_class_relative;
+
+  if (relativea < relativeb)
+    return 1;
+  if (relativea > relativeb)
+    return -1;
+  if (ELF_R_SYM (a->rela->r_info) < ELF_R_SYM (b->rela->r_info))
+    return -1;
+  if (ELF_R_SYM (a->rela->r_info) > ELF_R_SYM (b->rela->r_info))
+    return 1;
+  if (a->rela->r_offset < b->rela->r_offset)
+    return -1;
+  if (a->rela->r_offset > b->rela->r_offset)
+    return 1;
+  return 0;
+}
+
+static int
+elf_link_sort_cmp2 (A, B)
+     const PTR A;
+     const PTR B;
+{
+  struct elf_link_sort_rela *a = (struct elf_link_sort_rela *) A;
+  struct elf_link_sort_rela *b = (struct elf_link_sort_rela *) B;
+  int copya, copyb;
+
+  if (a->offset < b->offset)
+    return -1;
+  if (a->offset > b->offset)
+    return 1;
+  copya = (a->type == reloc_class_copy) * 2 + (a->type == reloc_class_plt);
+  copyb = (b->type == reloc_class_copy) * 2 + (b->type == reloc_class_plt);
+  if (copya < copyb)
+    return -1;
+  if (copya > copyb)
+    return 1;
+  if (a->rela->r_offset < b->rela->r_offset)
+    return -1;
+  if (a->rela->r_offset > b->rela->r_offset)
+    return 1;
+  return 0;
+}
+
+static size_t
+elf_link_sort_relocs (abfd, info, psec)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     asection **psec;
+{
+  bfd *dynobj = elf_hash_table (info)->dynobj;
+  asection *reldyn, *o;
+  bfd_size_type count, size;
+  size_t i, ret, sort_elt, ext_size;
+  bfd_byte *sort, *s_non_relative, *p;
+  struct elf_link_sort_rela *sq;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  int i2e = bed->s->int_rels_per_ext_rel;
+  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
+  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
+
+  reldyn = bfd_get_section_by_name (abfd, ".rela.dyn");
+  if (reldyn == NULL || reldyn->_raw_size == 0)
+    {
+      reldyn = bfd_get_section_by_name (abfd, ".rel.dyn");
+      if (reldyn == NULL || reldyn->_raw_size == 0)
+	return 0;
+      ext_size = sizeof (Elf_External_Rel);
+      swap_in = bed->s->swap_reloc_in;
+      swap_out = bed->s->swap_reloc_out;
+    }
+  else
+    {
+      ext_size = sizeof (Elf_External_Rela);
+      swap_in = bed->s->swap_reloca_in;
+      swap_out = bed->s->swap_reloca_out;
+    }
+  count = reldyn->_raw_size / ext_size;
+
+  size = 0;
+  for (o = dynobj->sections; o != NULL; o = o->next)
+    if ((o->flags & (SEC_HAS_CONTENTS|SEC_LINKER_CREATED))
+	== (SEC_HAS_CONTENTS|SEC_LINKER_CREATED)
+	&& o->output_section == reldyn)
+      size += o->_raw_size;
+
+  if (size != reldyn->_raw_size)
+    return 0;
+
+  sort_elt = (sizeof (struct elf_link_sort_rela)
+	      + (i2e - 1) * sizeof (Elf_Internal_Rela));
+  sort = bfd_zmalloc (sort_elt * count);
+  if (sort == NULL)
+    {
+      (*info->callbacks->warning)
+	(info, _("Not enough memory to sort relocations"), 0, abfd, 0,
+	 (bfd_vma) 0);
+      return 0;
+    }
+
+  for (o = dynobj->sections; o != NULL; o = o->next)
+    if ((o->flags & (SEC_HAS_CONTENTS|SEC_LINKER_CREATED))
+	== (SEC_HAS_CONTENTS|SEC_LINKER_CREATED)
+	&& o->output_section == reldyn)
+      {
+	bfd_byte *erel, *erelend;
+
+	erel = o->contents;
+	erelend = o->contents + o->_raw_size;
+	p = sort + o->output_offset / ext_size * sort_elt;
+	while (erel < erelend)
+	  {
+	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
+	    (*swap_in) (abfd, erel, s->rela);
+	    s->type = (*bed->elf_backend_reloc_type_class) (s->rela);
+	    p += sort_elt;
+	    erel += ext_size;
+	  }
+      }
+
+  qsort (sort, (size_t) count, sort_elt, elf_link_sort_cmp1);
+
+  for (i = 0, p = sort; i < count; i++, p += sort_elt)
+    {
+      struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
+      if (s->type != reloc_class_relative)
+	break;
+    }
+  ret = i;
+  s_non_relative = p;
+
+  sq = (struct elf_link_sort_rela *) s_non_relative;
+  for (; i < count; i++, p += sort_elt)
+    {
+      struct elf_link_sort_rela *sp = (struct elf_link_sort_rela *) p;
+      if (ELF_R_SYM (sp->rela->r_info) != ELF_R_SYM (sq->rela->r_info))
+	sq = sp;
+      sp->offset = sq->rela->r_offset;
+    }
+
+  qsort (s_non_relative, (size_t) count - ret, sort_elt, elf_link_sort_cmp2);
+
+  for (o = dynobj->sections; o != NULL; o = o->next)
+    if ((o->flags & (SEC_HAS_CONTENTS|SEC_LINKER_CREATED))
+	== (SEC_HAS_CONTENTS|SEC_LINKER_CREATED)
+	&& o->output_section == reldyn)
+      {
+	bfd_byte *erel, *erelend;
+
+	erel = o->contents;
+	erelend = o->contents + o->_raw_size;
+	p = sort + o->output_offset / ext_size * sort_elt;
+	while (erel < erelend)
+	  {
+	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
+	    (*swap_out) (abfd, s->rela, erel);
+	    p += sort_elt;
+	    erel += ext_size;
+	  }
+      }
+
+  free (sort);
+  *psec = reldyn;
+  return ret;
+}
+
+/* Do the final step of an ELF link.  */
+
+bfd_boolean
+elf_bfd_final_link (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  bfd_boolean dynamic;
+  bfd_boolean emit_relocs;
+  bfd *dynobj;
+  struct elf_final_link_info finfo;
+  register asection *o;
+  register struct bfd_link_order *p;
+  register bfd *sub;
+  bfd_size_type max_contents_size;
+  bfd_size_type max_external_reloc_size;
+  bfd_size_type max_internal_reloc_count;
+  bfd_size_type max_sym_count;
+  bfd_size_type max_sym_shndx_count;
+  file_ptr off;
+  Elf_Internal_Sym elfsym;
+  unsigned int i;
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Shdr *symtab_shndx_hdr;
+  Elf_Internal_Shdr *symstrtab_hdr;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  struct elf_outext_info eoinfo;
+  bfd_boolean merged;
+  size_t relativecount = 0;
+  asection *reldyn = 0;
+  bfd_size_type amt;
+
+  if (! is_elf_hash_table (info))
+    return FALSE;
+
+  if (info->shared)
+    abfd->flags |= DYNAMIC;
+
+  dynamic = elf_hash_table (info)->dynamic_sections_created;
+  dynobj = elf_hash_table (info)->dynobj;
+
+  emit_relocs = (info->relocateable
+		 || info->emitrelocations
+		 || bed->elf_backend_emit_relocs);
+
+  finfo.info = info;
+  finfo.output_bfd = abfd;
+  finfo.symstrtab = elf_stringtab_init ();
+  if (finfo.symstrtab == NULL)
+    return FALSE;
+
+  if (! dynamic)
+    {
+      finfo.dynsym_sec = NULL;
+      finfo.hash_sec = NULL;
+      finfo.symver_sec = NULL;
+    }
+  else
+    {
+      finfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
+      finfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
+      BFD_ASSERT (finfo.dynsym_sec != NULL && finfo.hash_sec != NULL);
+      finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
+      /* Note that it is OK if symver_sec is NULL.  */
+    }
+
+  finfo.contents = NULL;
+  finfo.external_relocs = NULL;
+  finfo.internal_relocs = NULL;
+  finfo.external_syms = NULL;
+  finfo.locsym_shndx = NULL;
+  finfo.internal_syms = NULL;
+  finfo.indices = NULL;
+  finfo.sections = NULL;
+  finfo.symbuf = NULL;
+  finfo.symshndxbuf = NULL;
+  finfo.symbuf_count = 0;
+  finfo.shndxbuf_size = 0;
+  finfo.first_tls_sec = NULL;
+  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
+    if ((o->flags & SEC_THREAD_LOCAL) != 0
+	&& (o->flags & SEC_LOAD) != 0)
+      {
+	finfo.first_tls_sec = o;
+	break;
+      }
+
+  /* Count up the number of relocations we will output for each output
+     section, so that we know the sizes of the reloc sections.  We
+     also figure out some maximum sizes.  */
+  max_contents_size = 0;
+  max_external_reloc_size = 0;
+  max_internal_reloc_count = 0;
+  max_sym_count = 0;
+  max_sym_shndx_count = 0;
+  merged = FALSE;
+  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
+    {
+      struct bfd_elf_section_data *esdo = elf_section_data (o);
+      o->reloc_count = 0;
+
+      for (p = o->link_order_head; p != NULL; p = p->next)
+	{
+	  unsigned int reloc_count = 0;
+	  struct bfd_elf_section_data *esdi = NULL;
+	  unsigned int *rel_count1;
+
+	  if (p->type == bfd_section_reloc_link_order
+	      || p->type == bfd_symbol_reloc_link_order)
+	    reloc_count = 1;
+	  else if (p->type == bfd_indirect_link_order)
+	    {
+	      asection *sec;
+
+	      sec = p->u.indirect.section;
+	      esdi = elf_section_data (sec);
+
+	      /* Mark all sections which are to be included in the
+		 link.  This will normally be every section.  We need
+		 to do this so that we can identify any sections which
+		 the linker has decided to not include.  */
+	      sec->linker_mark = TRUE;
+
+	      if (sec->flags & SEC_MERGE)
+		merged = TRUE;
+
+	      if (info->relocateable || info->emitrelocations)
+		reloc_count = sec->reloc_count;
+	      else if (bed->elf_backend_count_relocs)
+		{
+		  Elf_Internal_Rela * relocs;
+
+		  relocs = (NAME(_bfd_elf,link_read_relocs)
+			    (abfd, sec, (PTR) NULL,
+			     (Elf_Internal_Rela *) NULL, info->keep_memory));
+
+		  reloc_count = (*bed->elf_backend_count_relocs) (sec, relocs);
+
+		  if (elf_section_data (o)->relocs != relocs)
+		    free (relocs);
+		}
+
+	      if (sec->_raw_size > max_contents_size)
+		max_contents_size = sec->_raw_size;
+	      if (sec->_cooked_size > max_contents_size)
+		max_contents_size = sec->_cooked_size;
+
+	      /* We are interested in just local symbols, not all
+		 symbols.  */
+	      if (bfd_get_flavour (sec->owner) == bfd_target_elf_flavour
+		  && (sec->owner->flags & DYNAMIC) == 0)
+		{
+		  size_t sym_count;
+
+		  if (elf_bad_symtab (sec->owner))
+		    sym_count = (elf_tdata (sec->owner)->symtab_hdr.sh_size
+				 / sizeof (Elf_External_Sym));
+		  else
+		    sym_count = elf_tdata (sec->owner)->symtab_hdr.sh_info;
+
+		  if (sym_count > max_sym_count)
+		    max_sym_count = sym_count;
+
+		  if (sym_count > max_sym_shndx_count
+		      && elf_symtab_shndx (sec->owner) != 0)
+		    max_sym_shndx_count = sym_count;
+
+		  if ((sec->flags & SEC_RELOC) != 0)
+		    {
+		      size_t ext_size;
+
+		      ext_size = elf_section_data (sec)->rel_hdr.sh_size;
+		      if (ext_size > max_external_reloc_size)
+			max_external_reloc_size = ext_size;
+		      if (sec->reloc_count > max_internal_reloc_count)
+			max_internal_reloc_count = sec->reloc_count;
+		    }
+		}
+	    }
+
+	  if (reloc_count == 0)
+	    continue;
+
+	  o->reloc_count += reloc_count;
+
+	  /* MIPS may have a mix of REL and RELA relocs on sections.
+	     To support this curious ABI we keep reloc counts in
+	     elf_section_data too.  We must be careful to add the
+	     relocations from the input section to the right output
+	     count.  FIXME: Get rid of one count.  We have
+	     o->reloc_count == esdo->rel_count + esdo->rel_count2.  */
+	  rel_count1 = &esdo->rel_count;
+	  if (esdi != NULL)
+	    {
+	      bfd_boolean same_size;
+	      bfd_size_type entsize1;
+
+	      entsize1 = esdi->rel_hdr.sh_entsize;
+	      BFD_ASSERT (entsize1 == sizeof (Elf_External_Rel)
+			  || entsize1 == sizeof (Elf_External_Rela));
+	      same_size = (!o->use_rela_p
+			   == (entsize1 == sizeof (Elf_External_Rel)));
+
+	      if (!same_size)
+		rel_count1 = &esdo->rel_count2;
+
+	      if (esdi->rel_hdr2 != NULL)
+		{
+		  bfd_size_type entsize2 = esdi->rel_hdr2->sh_entsize;
+		  unsigned int alt_count;
+		  unsigned int *rel_count2;
+
+		  BFD_ASSERT (entsize2 != entsize1
+			      && (entsize2 == sizeof (Elf_External_Rel)
+				  || entsize2 == sizeof (Elf_External_Rela)));
+
+		  rel_count2 = &esdo->rel_count2;
+		  if (!same_size)
+		    rel_count2 = &esdo->rel_count;
+
+		  /* The following is probably too simplistic if the
+		     backend counts output relocs unusually.  */
+		  BFD_ASSERT (bed->elf_backend_count_relocs == NULL);
+		  alt_count = NUM_SHDR_ENTRIES (esdi->rel_hdr2);
+		  *rel_count2 += alt_count;
+		  reloc_count -= alt_count;
+		}
+	    }
+	  *rel_count1 += reloc_count;
+	}
+
+      if (o->reloc_count > 0)
+	o->flags |= SEC_RELOC;
+      else
+	{
+	  /* Explicitly clear the SEC_RELOC flag.  The linker tends to
+	     set it (this is probably a bug) and if it is set
+	     assign_section_numbers will create a reloc section.  */
+	  o->flags &=~ SEC_RELOC;
+	}
+
+      /* If the SEC_ALLOC flag is not set, force the section VMA to
+	 zero.  This is done in elf_fake_sections as well, but forcing
+	 the VMA to 0 here will ensure that relocs against these
+	 sections are handled correctly.  */
+      if ((o->flags & SEC_ALLOC) == 0
+	  && ! o->user_set_vma)
+	o->vma = 0;
+    }
+
+  if (! info->relocateable && merged)
+    elf_link_hash_traverse (elf_hash_table (info),
+			    elf_link_sec_merge_syms, (PTR) abfd);
+
+  /* Figure out the file positions for everything but the symbol table
+     and the relocs.  We set symcount to force assign_section_numbers
+     to create a symbol table.  */
+  bfd_get_symcount (abfd) = info->strip == strip_all ? 0 : 1;
+  BFD_ASSERT (! abfd->output_has_begun);
+  if (! _bfd_elf_compute_section_file_positions (abfd, info))
+    goto error_return;
+
+  /* That created the reloc sections.  Set their sizes, and assign
+     them file positions, and allocate some buffers.  */
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if ((o->flags & SEC_RELOC) != 0)
+	{
+	  if (!elf_link_size_reloc_section (abfd,
+					    &elf_section_data (o)->rel_hdr,
+					    o))
+	    goto error_return;
+
+	  if (elf_section_data (o)->rel_hdr2
+	      && !elf_link_size_reloc_section (abfd,
+					       elf_section_data (o)->rel_hdr2,
+					       o))
+	    goto error_return;
+	}
+
+      /* Now, reset REL_COUNT and REL_COUNT2 so that we can use them
+	 to count upwards while actually outputting the relocations.  */
+      elf_section_data (o)->rel_count = 0;
+      elf_section_data (o)->rel_count2 = 0;
+    }
+
+  _bfd_elf_assign_file_positions_for_relocs (abfd);
+
+  /* We have now assigned file positions for all the sections except
+     .symtab and .strtab.  We start the .symtab section at the current
+     file position, and write directly to it.  We build the .strtab
+     section in memory.  */
+  bfd_get_symcount (abfd) = 0;
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  /* sh_name is set in prep_headers.  */
+  symtab_hdr->sh_type = SHT_SYMTAB;
+  /* sh_flags, sh_addr and sh_size all start off zero.  */
+  symtab_hdr->sh_entsize = sizeof (Elf_External_Sym);
+  /* sh_link is set in assign_section_numbers.  */
+  /* sh_info is set below.  */
+  /* sh_offset is set just below.  */
+  symtab_hdr->sh_addralign = bed->s->file_align;
+
+  off = elf_tdata (abfd)->next_file_pos;
+  off = _bfd_elf_assign_file_position_for_section (symtab_hdr, off, TRUE);
+
+  /* Note that at this point elf_tdata (abfd)->next_file_pos is
+     incorrect.  We do not yet know the size of the .symtab section.
+     We correct next_file_pos below, after we do know the size.  */
+
+  /* Allocate a buffer to hold swapped out symbols.  This is to avoid
+     continuously seeking to the right position in the file.  */
+  if (! info->keep_memory || max_sym_count < 20)
+    finfo.symbuf_size = 20;
+  else
+    finfo.symbuf_size = max_sym_count;
+  amt = finfo.symbuf_size;
+  amt *= sizeof (Elf_External_Sym);
+  finfo.symbuf = (Elf_External_Sym *) bfd_malloc (amt);
+  if (finfo.symbuf == NULL)
+    goto error_return;
+  if (elf_numsections (abfd) > SHN_LORESERVE)
+    {
+      /* Wild guess at number of output symbols.  realloc'd as needed.  */
+      amt = 2 * max_sym_count + elf_numsections (abfd) + 1000;
+      finfo.shndxbuf_size = amt;
+      amt *= sizeof (Elf_External_Sym_Shndx);
+      finfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
+      if (finfo.symshndxbuf == NULL)
+	goto error_return;
+    }
+
+  /* Start writing out the symbol table.  The first symbol is always a
+     dummy symbol.  */
+  if (info->strip != strip_all
+      || emit_relocs)
+    {
+      elfsym.st_value = 0;
+      elfsym.st_size = 0;
+      elfsym.st_info = 0;
+      elfsym.st_other = 0;
+      elfsym.st_shndx = SHN_UNDEF;
+      if (! elf_link_output_sym (&finfo, (const char *) NULL,
+				 &elfsym, bfd_und_section_ptr))
+	goto error_return;
+    }
+
+#if 0
+  /* Some standard ELF linkers do this, but we don't because it causes
+     bootstrap comparison failures.  */
+  /* Output a file symbol for the output file as the second symbol.
+     We output this even if we are discarding local symbols, although
+     I'm not sure if this is correct.  */
+  elfsym.st_value = 0;
+  elfsym.st_size = 0;
+  elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
+  elfsym.st_other = 0;
+  elfsym.st_shndx = SHN_ABS;
+  if (! elf_link_output_sym (&finfo, bfd_get_filename (abfd),
+			     &elfsym, bfd_abs_section_ptr))
+    goto error_return;
+#endif
+
+  /* Output a symbol for each section.  We output these even if we are
+     discarding local symbols, since they are used for relocs.  These
+     symbols have no names.  We store the index of each one in the
+     index field of the section, so that we can find it again when
+     outputting relocs.  */
+  if (info->strip != strip_all
+      || emit_relocs)
+    {
+      elfsym.st_size = 0;
+      elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
+      elfsym.st_other = 0;
+      for (i = 1; i < elf_numsections (abfd); i++)
+	{
+	  o = section_from_elf_index (abfd, i);
+	  if (o != NULL)
+	    o->target_index = bfd_get_symcount (abfd);
+	  elfsym.st_shndx = i;
+	  if (info->relocateable || o == NULL)
+	    elfsym.st_value = 0;
+	  else
+	    elfsym.st_value = o->vma;
+	  if (! elf_link_output_sym (&finfo, (const char *) NULL,
+				     &elfsym, o))
+	    goto error_return;
+	  if (i == SHN_LORESERVE - 1)
+	    i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
+	}
+    }
+
+  /* Allocate some memory to hold information read in from the input
+     files.  */
+  if (max_contents_size != 0)
+    {
+      finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
+      if (finfo.contents == NULL)
+	goto error_return;
+    }
+
+  if (max_external_reloc_size != 0)
+    {
+      finfo.external_relocs = (PTR) bfd_malloc (max_external_reloc_size);
+      if (finfo.external_relocs == NULL)
+	goto error_return;
+    }
+
+  if (max_internal_reloc_count != 0)
+    {
+      amt = max_internal_reloc_count * bed->s->int_rels_per_ext_rel;
+      amt *= sizeof (Elf_Internal_Rela);
+      finfo.internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
+      if (finfo.internal_relocs == NULL)
+	goto error_return;
+    }
+
+  if (max_sym_count != 0)
+    {
+      amt = max_sym_count * sizeof (Elf_External_Sym);
+      finfo.external_syms = (Elf_External_Sym *) bfd_malloc (amt);
+      if (finfo.external_syms == NULL)
+	goto error_return;
+
+      amt = max_sym_count * sizeof (Elf_Internal_Sym);
+      finfo.internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
+      if (finfo.internal_syms == NULL)
+	goto error_return;
+
+      amt = max_sym_count * sizeof (long);
+      finfo.indices = (long *) bfd_malloc (amt);
+      if (finfo.indices == NULL)
+	goto error_return;
+
+      amt = max_sym_count * sizeof (asection *);
+      finfo.sections = (asection **) bfd_malloc (amt);
+      if (finfo.sections == NULL)
+	goto error_return;
+    }
+
+  if (max_sym_shndx_count != 0)
+    {
+      amt = max_sym_shndx_count * sizeof (Elf_External_Sym_Shndx);
+      finfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
+      if (finfo.locsym_shndx == NULL)
+	goto error_return;
+    }
+
+  if (finfo.first_tls_sec)
+    {
+      unsigned int align = 0;
+      bfd_vma base = finfo.first_tls_sec->vma, end = 0;
+      asection *sec;
+
+      for (sec = finfo.first_tls_sec;
+	   sec && (sec->flags & SEC_THREAD_LOCAL);
+	   sec = sec->next)
+	{
+	  bfd_vma size = sec->_raw_size;
+
+	  if (bfd_get_section_alignment (abfd, sec) > align)
+	    align = bfd_get_section_alignment (abfd, sec);
+	  if (sec->_raw_size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
+	    {
+	      struct bfd_link_order *o;
+
+	      size = 0;
+	      for (o = sec->link_order_head; o != NULL; o = o->next)
+		if (size < o->offset + o->size)
+		  size = o->offset + o->size;
+	    }
+	  end = sec->vma + size;
+	}
+      elf_hash_table (info)->tls_segment
+	= bfd_zalloc (abfd, sizeof (struct elf_link_tls_segment));
+      if (elf_hash_table (info)->tls_segment == NULL)
+	goto error_return;
+      elf_hash_table (info)->tls_segment->start = base;
+      elf_hash_table (info)->tls_segment->size = end - base;
+      elf_hash_table (info)->tls_segment->align = align;
+    }
+
+  /* Since ELF permits relocations to be against local symbols, we
+     must have the local symbols available when we do the relocations.
+     Since we would rather only read the local symbols once, and we
+     would rather not keep them in memory, we handle all the
+     relocations for a single input file at the same time.
+
+     Unfortunately, there is no way to know the total number of local
+     symbols until we have seen all of them, and the local symbol
+     indices precede the global symbol indices.  This means that when
+     we are generating relocateable output, and we see a reloc against
+     a global symbol, we can not know the symbol index until we have
+     finished examining all the local symbols to see which ones we are
+     going to output.  To deal with this, we keep the relocations in
+     memory, and don't output them until the end of the link.  This is
+     an unfortunate waste of memory, but I don't see a good way around
+     it.  Fortunately, it only happens when performing a relocateable
+     link, which is not the common case.  FIXME: If keep_memory is set
+     we could write the relocs out and then read them again; I don't
+     know how bad the memory loss will be.  */
+
+  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+    sub->output_has_begun = FALSE;
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      for (p = o->link_order_head; p != NULL; p = p->next)
+	{
+	  if (p->type == bfd_indirect_link_order
+	      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
+		  == bfd_target_elf_flavour)
+	      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)
+	    {
+	      if (! sub->output_has_begun)
+		{
+		  if (! elf_link_input_bfd (&finfo, sub))
+		    goto error_return;
+		  sub->output_has_begun = TRUE;
+		}
+	    }
+	  else if (p->type == bfd_section_reloc_link_order
+		   || p->type == bfd_symbol_reloc_link_order)
+	    {
+	      if (! elf_reloc_link_order (abfd, info, o, p))
+		goto error_return;
+	    }
+	  else
+	    {
+	      if (! _bfd_default_link_order (abfd, info, o, p))
+		goto error_return;
+	    }
+	}
+    }
+
+  /* Output any global symbols that got converted to local in a
+     version script or due to symbol visibility.  We do this in a
+     separate step since ELF requires all local symbols to appear
+     prior to any global symbols.  FIXME: We should only do this if
+     some global symbols were, in fact, converted to become local.
+     FIXME: Will this work correctly with the Irix 5 linker?  */
+  eoinfo.failed = FALSE;
+  eoinfo.finfo = &finfo;
+  eoinfo.localsyms = TRUE;
+  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
+			  (PTR) &eoinfo);
+  if (eoinfo.failed)
+    return FALSE;
+
+  /* That wrote out all the local symbols.  Finish up the symbol table
+     with the global symbols. Even if we want to strip everything we
+     can, we still need to deal with those global symbols that got
+     converted to local in a version script.  */
+
+  /* The sh_info field records the index of the first non local symbol.  */
+  symtab_hdr->sh_info = bfd_get_symcount (abfd);
+
+  if (dynamic
+      && finfo.dynsym_sec->output_section != bfd_abs_section_ptr)
+    {
+      Elf_Internal_Sym sym;
+      Elf_External_Sym *dynsym =
+	(Elf_External_Sym *) finfo.dynsym_sec->contents;
+      long last_local = 0;
+
+      /* Write out the section symbols for the output sections.  */
+      if (info->shared)
+	{
+	  asection *s;
+
+	  sym.st_size = 0;
+	  sym.st_name = 0;
+	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
+	  sym.st_other = 0;
+
+	  for (s = abfd->sections; s != NULL; s = s->next)
+	    {
+	      int indx;
+	      Elf_External_Sym *dest;
+
+	      indx = elf_section_data (s)->this_idx;
+	      BFD_ASSERT (indx > 0);
+	      sym.st_shndx = indx;
+	      sym.st_value = s->vma;
+	      dest = dynsym + elf_section_data (s)->dynindx;
+	      elf_swap_symbol_out (abfd, &sym, (PTR) dest, (PTR) 0);
+	    }
+
+	  last_local = bfd_count_sections (abfd);
+	}
+
+      /* Write out the local dynsyms.  */
+      if (elf_hash_table (info)->dynlocal)
+	{
+	  struct elf_link_local_dynamic_entry *e;
+	  for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
+	    {
+	      asection *s;
+	      Elf_External_Sym *dest;
+
+	      sym.st_size = e->isym.st_size;
+	      sym.st_other = e->isym.st_other;
+
+	      /* Copy the internal symbol as is.
+		 Note that we saved a word of storage and overwrote
+		 the original st_name with the dynstr_index.  */
+	      sym = e->isym;
+
+	      if (e->isym.st_shndx != SHN_UNDEF
+		  && (e->isym.st_shndx < SHN_LORESERVE
+		      || e->isym.st_shndx > SHN_HIRESERVE))
+		{
+		  s = bfd_section_from_elf_index (e->input_bfd,
+						  e->isym.st_shndx);
+
+		  sym.st_shndx =
+		    elf_section_data (s->output_section)->this_idx;
+		  sym.st_value = (s->output_section->vma
+				  + s->output_offset
+				  + e->isym.st_value);
+		}
+
+	      if (last_local < e->dynindx)
+		last_local = e->dynindx;
+
+	      dest = dynsym + e->dynindx;
+	      elf_swap_symbol_out (abfd, &sym, (PTR) dest, (PTR) 0);
+	    }
+	}
+
+      elf_section_data (finfo.dynsym_sec->output_section)->this_hdr.sh_info =
+	last_local + 1;
+    }
+
+  /* We get the global symbols from the hash table.  */
+  eoinfo.failed = FALSE;
+  eoinfo.localsyms = FALSE;
+  eoinfo.finfo = &finfo;
+  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
+			  (PTR) &eoinfo);
+  if (eoinfo.failed)
+    return FALSE;
+
+  /* If backend needs to output some symbols not present in the hash
+     table, do it now.  */
+  if (bed->elf_backend_output_arch_syms)
+    {
+      typedef bfd_boolean (*out_sym_func)
+	PARAMS ((PTR, const char *, Elf_Internal_Sym *, asection *));
+
+      if (! ((*bed->elf_backend_output_arch_syms)
+	     (abfd, info, (PTR) &finfo, (out_sym_func) elf_link_output_sym)))
+	return FALSE;
+    }
+
+  /* Flush all symbols to the file.  */
+  if (! elf_link_flush_output_syms (&finfo))
+    return FALSE;
+
+  /* Now we know the size of the symtab section.  */
+  off += symtab_hdr->sh_size;
+
+  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
+  if (symtab_shndx_hdr->sh_name != 0)
+    {
+      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
+      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
+      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
+      amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);
+      symtab_shndx_hdr->sh_size = amt;
+
+      off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,
+						       off, TRUE);
+
+      if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, SEEK_SET) != 0
+	  || (bfd_bwrite ((PTR) finfo.symshndxbuf, amt, abfd) != amt))
+	return FALSE;
+    }
+
+
+  /* Finish up and write out the symbol string table (.strtab)
+     section.  */
+  symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
+  /* sh_name was set in prep_headers.  */
+  symstrtab_hdr->sh_type = SHT_STRTAB;
+  symstrtab_hdr->sh_flags = 0;
+  symstrtab_hdr->sh_addr = 0;
+  symstrtab_hdr->sh_size = _bfd_stringtab_size (finfo.symstrtab);
+  symstrtab_hdr->sh_entsize = 0;
+  symstrtab_hdr->sh_link = 0;
+  symstrtab_hdr->sh_info = 0;
+  /* sh_offset is set just below.  */
+  symstrtab_hdr->sh_addralign = 1;
+
+  off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr, off, TRUE);
+  elf_tdata (abfd)->next_file_pos = off;
+
+  if (bfd_get_symcount (abfd) > 0)
+    {
+      if (bfd_seek (abfd, symstrtab_hdr->sh_offset, SEEK_SET) != 0
+	  || ! _bfd_stringtab_emit (abfd, finfo.symstrtab))
+	return FALSE;
+    }
+
+  /* Adjust the relocs to have the correct symbol indices.  */
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if ((o->flags & SEC_RELOC) == 0)
+	continue;
+
+      elf_link_adjust_relocs (abfd, &elf_section_data (o)->rel_hdr,
+			      elf_section_data (o)->rel_count,
+			      elf_section_data (o)->rel_hashes);
+      if (elf_section_data (o)->rel_hdr2 != NULL)
+	elf_link_adjust_relocs (abfd, elf_section_data (o)->rel_hdr2,
+				elf_section_data (o)->rel_count2,
+				(elf_section_data (o)->rel_hashes
+				 + elf_section_data (o)->rel_count));
+
+      /* Set the reloc_count field to 0 to prevent write_relocs from
+	 trying to swap the relocs out itself.  */
+      o->reloc_count = 0;
+    }
+
+  if (dynamic && info->combreloc && dynobj != NULL)
+    relativecount = elf_link_sort_relocs (abfd, info, &reldyn);
+
+  /* If we are linking against a dynamic object, or generating a
+     shared library, finish up the dynamic linking information.  */
+  if (dynamic)
+    {
+      Elf_External_Dyn *dyncon, *dynconend;
+
+      /* Fix up .dynamic entries.  */
+      o = bfd_get_section_by_name (dynobj, ".dynamic");
+      BFD_ASSERT (o != NULL);
+
+      dyncon = (Elf_External_Dyn *) o->contents;
+      dynconend = (Elf_External_Dyn *) (o->contents + o->_raw_size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+	  const char *name;
+	  unsigned int type;
+
+	  elf_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      break;
+	    case DT_NULL:
+	      if (relativecount > 0 && dyncon + 1 < dynconend)
+		{
+		  switch (elf_section_data (reldyn)->this_hdr.sh_type)
+		    {
+		    case SHT_REL: dyn.d_tag = DT_RELCOUNT; break;
+		    case SHT_RELA: dyn.d_tag = DT_RELACOUNT; break;
+		    default: break;
+		    }
+		  if (dyn.d_tag != DT_NULL)
+		    {
+		      dyn.d_un.d_val = relativecount;
+		      elf_swap_dyn_out (dynobj, &dyn, dyncon);
+		      relativecount = 0;
+		    }
+		}
+	      break;
+	    case DT_INIT:
+	      name = info->init_function;
+	      goto get_sym;
+	    case DT_FINI:
+	      name = info->fini_function;
+	    get_sym:
+	      {
+		struct elf_link_hash_entry *h;
+
+		h = elf_link_hash_lookup (elf_hash_table (info), name,
+					  FALSE, FALSE, TRUE);
+		if (h != NULL
+		    && (h->root.type == bfd_link_hash_defined
+			|| h->root.type == bfd_link_hash_defweak))
+		  {
+		    dyn.d_un.d_val = h->root.u.def.value;
+		    o = h->root.u.def.section;
+		    if (o->output_section != NULL)
+		      dyn.d_un.d_val += (o->output_section->vma
+					 + o->output_offset);
+		    else
+		      {
+			/* The symbol is imported from another shared
+			   library and does not apply to this one.  */
+			dyn.d_un.d_val = 0;
+		      }
+
+		    elf_swap_dyn_out (dynobj, &dyn, dyncon);
+		  }
+	      }
+	      break;
+
+	    case DT_PREINIT_ARRAYSZ:
+	      name = ".preinit_array";
+	      goto get_size;
+	    case DT_INIT_ARRAYSZ:
+	      name = ".init_array";
+	      goto get_size;
+	    case DT_FINI_ARRAYSZ:
+	      name = ".fini_array";
+	    get_size:
+	      o = bfd_get_section_by_name (abfd, name);
+	      if (o == NULL)
+		{
+		  (*_bfd_error_handler)
+		    (_("%s: could not find output section %s"),
+		     bfd_get_filename (abfd), name);
+		  goto error_return;
+		}
+	      if (o->_raw_size == 0)
+		(*_bfd_error_handler)
+		  (_("warning: %s section has zero size"), name);
+	      dyn.d_un.d_val = o->_raw_size;
+	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_PREINIT_ARRAY:
+	      name = ".preinit_array";
+	      goto get_vma;
+	    case DT_INIT_ARRAY:
+	      name = ".init_array";
+	      goto get_vma;
+	    case DT_FINI_ARRAY:
+	      name = ".fini_array";
+	      goto get_vma;
+
+	    case DT_HASH:
+	      name = ".hash";
+	      goto get_vma;
+	    case DT_STRTAB:
+	      name = ".dynstr";
+	      goto get_vma;
+	    case DT_SYMTAB:
+	      name = ".dynsym";
+	      goto get_vma;
+	    case DT_VERDEF:
+	      name = ".gnu.version_d";
+	      goto get_vma;
+	    case DT_VERNEED:
+	      name = ".gnu.version_r";
+	      goto get_vma;
+	    case DT_VERSYM:
+	      name = ".gnu.version";
+	    get_vma:
+	      o = bfd_get_section_by_name (abfd, name);
+	      if (o == NULL)
+		{
+		  (*_bfd_error_handler)
+		    (_("%s: could not find output section %s"),
+		     bfd_get_filename (abfd), name);
+		  goto error_return;
+		}
+	      dyn.d_un.d_ptr = o->vma;
+	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_REL:
+	    case DT_RELA:
+	    case DT_RELSZ:
+	    case DT_RELASZ:
+	      if (dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)
+		type = SHT_REL;
+	      else
+		type = SHT_RELA;
+	      dyn.d_un.d_val = 0;
+	      for (i = 1; i < elf_numsections (abfd); i++)
+		{
+		  Elf_Internal_Shdr *hdr;
+
+		  hdr = elf_elfsections (abfd)[i];
+		  if (hdr->sh_type == type
+		      && (hdr->sh_flags & SHF_ALLOC) != 0)
+		    {
+		      if (dyn.d_tag == DT_RELSZ || dyn.d_tag == DT_RELASZ)
+			dyn.d_un.d_val += hdr->sh_size;
+		      else
+			{
+			  if (dyn.d_un.d_val == 0
+			      || hdr->sh_addr < dyn.d_un.d_val)
+			    dyn.d_un.d_val = hdr->sh_addr;
+			}
+		    }
+		}
+	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+	    }
+	}
+    }
+
+  /* If we have created any dynamic sections, then output them.  */
+  if (dynobj != NULL)
+    {
+      if (! (*bed->elf_backend_finish_dynamic_sections) (abfd, info))
+	goto error_return;
+
+      for (o = dynobj->sections; o != NULL; o = o->next)
+	{
+	  if ((o->flags & SEC_HAS_CONTENTS) == 0
+	      || o->_raw_size == 0
+	      || o->output_section == bfd_abs_section_ptr)
+	    continue;
+	  if ((o->flags & SEC_LINKER_CREATED) == 0)
+	    {
+	      /* At this point, we are only interested in sections
+		 created by elf_link_create_dynamic_sections.  */
+	      continue;
+	    }
+	  if ((elf_section_data (o->output_section)->this_hdr.sh_type
+	       != SHT_STRTAB)
+	      || strcmp (bfd_get_section_name (abfd, o), ".dynstr") != 0)
+	    {
+	      if (! bfd_set_section_contents (abfd, o->output_section,
+					      o->contents,
+					      (file_ptr) o->output_offset,
+					      o->_raw_size))
+		goto error_return;
+	    }
+	  else
+	    {
+	      /* The contents of the .dynstr section are actually in a
+		 stringtab.  */
+	      off = elf_section_data (o->output_section)->this_hdr.sh_offset;
+	      if (bfd_seek (abfd, off, SEEK_SET) != 0
+		  || ! _bfd_elf_strtab_emit (abfd,
+					     elf_hash_table (info)->dynstr))
+		goto error_return;
+	    }
+	}
+    }
+
+  if (info->relocateable)
+    {
+      bfd_boolean failed = FALSE;
+
+      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
+      if (failed)
+	goto error_return;
+    }
+
+  /* If we have optimized stabs strings, output them.  */
+  if (elf_hash_table (info)->stab_info != NULL)
+    {
+      if (! _bfd_write_stab_strings (abfd, &elf_hash_table (info)->stab_info))
+	goto error_return;
+    }
+
+  if (info->eh_frame_hdr)
+    {
+      if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))
+	goto error_return;
+    }
+
+  if (finfo.symstrtab != NULL)
+    _bfd_stringtab_free (finfo.symstrtab);
+  if (finfo.contents != NULL)
+    free (finfo.contents);
+  if (finfo.external_relocs != NULL)
+    free (finfo.external_relocs);
+  if (finfo.internal_relocs != NULL)
+    free (finfo.internal_relocs);
+  if (finfo.external_syms != NULL)
+    free (finfo.external_syms);
+  if (finfo.locsym_shndx != NULL)
+    free (finfo.locsym_shndx);
+  if (finfo.internal_syms != NULL)
+    free (finfo.internal_syms);
+  if (finfo.indices != NULL)
+    free (finfo.indices);
+  if (finfo.sections != NULL)
+    free (finfo.sections);
+  if (finfo.symbuf != NULL)
+    free (finfo.symbuf);
+  if (finfo.symshndxbuf != NULL)
+    free (finfo.symshndxbuf);
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if ((o->flags & SEC_RELOC) != 0
+	  && elf_section_data (o)->rel_hashes != NULL)
+	free (elf_section_data (o)->rel_hashes);
+    }
+
+  elf_tdata (abfd)->linker = TRUE;
+
+  return TRUE;
+
+ error_return:
+  if (finfo.symstrtab != NULL)
+    _bfd_stringtab_free (finfo.symstrtab);
+  if (finfo.contents != NULL)
+    free (finfo.contents);
+  if (finfo.external_relocs != NULL)
+    free (finfo.external_relocs);
+  if (finfo.internal_relocs != NULL)
+    free (finfo.internal_relocs);
+  if (finfo.external_syms != NULL)
+    free (finfo.external_syms);
+  if (finfo.locsym_shndx != NULL)
+    free (finfo.locsym_shndx);
+  if (finfo.internal_syms != NULL)
+    free (finfo.internal_syms);
+  if (finfo.indices != NULL)
+    free (finfo.indices);
+  if (finfo.sections != NULL)
+    free (finfo.sections);
+  if (finfo.symbuf != NULL)
+    free (finfo.symbuf);
+  if (finfo.symshndxbuf != NULL)
+    free (finfo.symshndxbuf);
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if ((o->flags & SEC_RELOC) != 0
+	  && elf_section_data (o)->rel_hashes != NULL)
+	free (elf_section_data (o)->rel_hashes);
+    }
+
+  return FALSE;
+}
+
+/* Add a symbol to the output symbol table.  */
+
+static bfd_boolean
+elf_link_output_sym (finfo, name, elfsym, input_sec)
+     struct elf_final_link_info *finfo;
+     const char *name;
+     Elf_Internal_Sym *elfsym;
+     asection *input_sec;
+{
+  Elf_External_Sym *dest;
+  Elf_External_Sym_Shndx *destshndx;
+  bfd_boolean (*output_symbol_hook)
+    PARAMS ((bfd *, struct bfd_link_info *info, const char *,
+	     Elf_Internal_Sym *, asection *));
+
+  output_symbol_hook = get_elf_backend_data (finfo->output_bfd)->
+    elf_backend_link_output_symbol_hook;
+  if (output_symbol_hook != NULL)
+    {
+      if (! ((*output_symbol_hook)
+	     (finfo->output_bfd, finfo->info, name, elfsym, input_sec)))
+	return FALSE;
+    }
+
+  if (name == (const char *) NULL || *name == '\0')
+    elfsym->st_name = 0;
+  else if (input_sec->flags & SEC_EXCLUDE)
+    elfsym->st_name = 0;
+  else
+    {
+      elfsym->st_name = (unsigned long) _bfd_stringtab_add (finfo->symstrtab,
+							    name, TRUE, FALSE);
+      if (elfsym->st_name == (unsigned long) -1)
+	return FALSE;
+    }
+
+  if (finfo->symbuf_count >= finfo->symbuf_size)
+    {
+      if (! elf_link_flush_output_syms (finfo))
+	return FALSE;
+    }
+
+  dest = finfo->symbuf + finfo->symbuf_count;
+  destshndx = finfo->symshndxbuf;
+  if (destshndx != NULL)
+    {
+      if (bfd_get_symcount (finfo->output_bfd) >= finfo->shndxbuf_size)
+	{
+	  bfd_size_type amt;
+
+	  amt = finfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
+	  finfo->symshndxbuf = destshndx = bfd_realloc (destshndx, amt * 2);
+	  if (destshndx == NULL)
+	    return FALSE;
+	  memset ((char *) destshndx + amt, 0, amt);
+	  finfo->shndxbuf_size *= 2;
+	}
+      destshndx += bfd_get_symcount (finfo->output_bfd);
+    }
+
+  elf_swap_symbol_out (finfo->output_bfd, elfsym, (PTR) dest, (PTR) destshndx);
+  finfo->symbuf_count += 1;
+  bfd_get_symcount (finfo->output_bfd) += 1;
+
+  return TRUE;
+}
+
+/* Flush the output symbols to the file.  */
+
+static bfd_boolean
+elf_link_flush_output_syms (finfo)
+     struct elf_final_link_info *finfo;
+{
+  if (finfo->symbuf_count > 0)
+    {
+      Elf_Internal_Shdr *hdr;
+      file_ptr pos;
+      bfd_size_type amt;
+
+      hdr = &elf_tdata (finfo->output_bfd)->symtab_hdr;
+      pos = hdr->sh_offset + hdr->sh_size;
+      amt = finfo->symbuf_count * sizeof (Elf_External_Sym);
+      if (bfd_seek (finfo->output_bfd, pos, SEEK_SET) != 0
+	  || bfd_bwrite ((PTR) finfo->symbuf, amt, finfo->output_bfd) != amt)
+	return FALSE;
+
+      hdr->sh_size += amt;
+      finfo->symbuf_count = 0;
+    }
+
+  return TRUE;
+}
+
+/* Adjust all external symbols pointing into SEC_MERGE sections
+   to reflect the object merging within the sections.  */
+
+static bfd_boolean
+elf_link_sec_merge_syms (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  asection *sec;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if ((h->root.type == bfd_link_hash_defined
+       || h->root.type == bfd_link_hash_defweak)
+      && ((sec = h->root.u.def.section)->flags & SEC_MERGE)
+      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
+    {
+      bfd *output_bfd = (bfd *) data;
+
+      h->root.u.def.value =
+	_bfd_merged_section_offset (output_bfd,
+				    &h->root.u.def.section,
+				    elf_section_data (sec)->sec_info,
+				    h->root.u.def.value, (bfd_vma) 0);
+    }
+
+  return TRUE;
+}
+
+/* For DSOs loaded in via a DT_NEEDED entry, emulate ld.so in
+   allowing an unsatisfied unversioned symbol in the DSO to match a
+   versioned symbol that would normally require an explicit version.
+   We also handle the case that a DSO references a hidden symbol
+   which may be satisfied by a versioned symbol in another DSO.  */
+
+static bfd_boolean
+elf_link_check_versioned_symbol (info, h)
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *h;
+{
+  bfd *abfd;
+  struct elf_link_loaded_list *loaded;
+
+  if (info->hash->creator->flavour != bfd_target_elf_flavour)
+    return FALSE;
+
+  switch (h->root.type)
+    {
+    default:
+      abfd = NULL;
+      break;
+
+    case bfd_link_hash_undefined:
+    case bfd_link_hash_undefweak:
+      abfd = h->root.u.undef.abfd;
+      if ((abfd->flags & DYNAMIC) == 0 || elf_dt_soname (abfd) == NULL)
+	return FALSE;
+      break;
+
+    case bfd_link_hash_defined:
+    case bfd_link_hash_defweak:
+      abfd = h->root.u.def.section->owner;
+      break;
+
+    case bfd_link_hash_common:
+      abfd = h->root.u.c.p->section->owner;
+      break;
+    }
+  BFD_ASSERT (abfd != NULL);
+
+  for (loaded = elf_hash_table (info)->loaded;
+       loaded != NULL;
+       loaded = loaded->next)
+    {
+      bfd *input;
+      Elf_Internal_Shdr *hdr;
+      bfd_size_type symcount;
+      bfd_size_type extsymcount;
+      bfd_size_type extsymoff;
+      Elf_Internal_Shdr *versymhdr;
+      Elf_Internal_Sym *isym;
+      Elf_Internal_Sym *isymend;
+      Elf_Internal_Sym *isymbuf;
+      Elf_External_Versym *ever;
+      Elf_External_Versym *extversym;
+
+      input = loaded->abfd;
+
+      /* We check each DSO for a possible hidden versioned definition.  */
+      if (input == abfd
+	  || (input->flags & DYNAMIC) == 0
+	  || elf_dynversym (input) == 0)
+	continue;
+
+      hdr = &elf_tdata (input)->dynsymtab_hdr;
+
+      symcount = hdr->sh_size / sizeof (Elf_External_Sym);
+      if (elf_bad_symtab (input))
+	{
+	  extsymcount = symcount;
+	  extsymoff = 0;
+	}
+      else
+	{
+	  extsymcount = symcount - hdr->sh_info;
+	  extsymoff = hdr->sh_info;
+	}
+
+      if (extsymcount == 0)
+	continue;
+
+      isymbuf = bfd_elf_get_elf_syms (input, hdr, extsymcount, extsymoff,
+				      NULL, NULL, NULL);
+      if (isymbuf == NULL)
+	return FALSE;
+
+      /* Read in any version definitions.  */
+      versymhdr = &elf_tdata (input)->dynversym_hdr;
+      extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
+      if (extversym == NULL)
+	goto error_ret;
+
+      if (bfd_seek (input, versymhdr->sh_offset, SEEK_SET) != 0
+	  || (bfd_bread ((PTR) extversym, versymhdr->sh_size, input)
+	      != versymhdr->sh_size))
+	{
+	  free (extversym);
+	error_ret:
+	  free (isymbuf);
+	  return FALSE;
+	}
+
+      ever = extversym + extsymoff;
+      isymend = isymbuf + extsymcount;
+      for (isym = isymbuf; isym < isymend; isym++, ever++)
+	{
+	  const char *name;
+	  Elf_Internal_Versym iver;
+
+	  if (ELF_ST_BIND (isym->st_info) == STB_LOCAL
+	      || isym->st_shndx == SHN_UNDEF)
+	    continue;
+
+	  name = bfd_elf_string_from_elf_section (input,
+						  hdr->sh_link,
+						  isym->st_name);
+	  if (strcmp (name, h->root.root.string) != 0)
+	    continue;
+
+	  _bfd_elf_swap_versym_in (input, ever, &iver);
+
+	  if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
+	    {
+	      /* If we have a non-hidden versioned sym, then it should
+		 have provided a definition for the undefined sym.  */
+	      abort ();
+	    }
+
+	  if ((iver.vs_vers & VERSYM_VERSION) == 2)
+	    {
+	      /* This is the oldest (default) sym.  We can use it.  */
+	      free (extversym);
+	      free (isymbuf);
+	      return TRUE;
+	    }
+	}
+
+      free (extversym);
+      free (isymbuf);
+    }
+
+  return FALSE;
+}
+
+/* Add an external symbol to the symbol table.  This is called from
+   the hash table traversal routine.  When generating a shared object,
+   we go through the symbol table twice.  The first time we output
+   anything that might have been forced to local scope in a version
+   script.  The second time we output the symbols that are still
+   global symbols.  */
+
+static bfd_boolean
+elf_link_output_extsym (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_outext_info *eoinfo = (struct elf_outext_info *) data;
+  struct elf_final_link_info *finfo = eoinfo->finfo;
+  bfd_boolean strip;
+  Elf_Internal_Sym sym;
+  asection *input_sec;
+
+  if (h->root.type == bfd_link_hash_warning)
+    {
+      h = (struct elf_link_hash_entry *) h->root.u.i.link;
+      if (h->root.type == bfd_link_hash_new)
+	return TRUE;
+    }
+
+  /* Decide whether to output this symbol in this pass.  */
+  if (eoinfo->localsyms)
+    {
+      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
+	return TRUE;
+    }
+  else
+    {
+      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
+	return TRUE;
+    }
+
+  /* If we are not creating a shared library, and this symbol is
+     referenced by a shared library but is not defined anywhere, then
+     warn that it is undefined.  If we do not do this, the runtime
+     linker will complain that the symbol is undefined when the
+     program is run.  We don't have to worry about symbols that are
+     referenced by regular files, because we will already have issued
+     warnings for them.  */
+  if (! finfo->info->relocateable
+      && (! finfo->info->shared || ! finfo->info->allow_shlib_undefined)
+      && h->root.type == bfd_link_hash_undefined
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
+      && ! elf_link_check_versioned_symbol (finfo->info, h))
+    {
+      if (! ((*finfo->info->callbacks->undefined_symbol)
+	     (finfo->info, h->root.root.string, h->root.u.undef.abfd,
+	      (asection *) NULL, (bfd_vma) 0, TRUE)))
+	{
+	  eoinfo->failed = TRUE;
+	  return FALSE;
+	}
+    }
+
+  /* We should also warn if a forced local symbol is referenced from
+     shared libraries.  */
+  if (! finfo->info->relocateable
+      && (! finfo->info->shared || ! finfo->info->allow_shlib_undefined)
+      && (h->elf_link_hash_flags
+	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC
+	     | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
+	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC)
+      && ! elf_link_check_versioned_symbol (finfo->info, h))
+    {
+      (*_bfd_error_handler)
+	(_("%s: %s symbol `%s' in %s is referenced by DSO"),
+	 bfd_get_filename (finfo->output_bfd),
+	 ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
+	 ? "internal"
+	 : ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
+	   ? "hidden" : "local",
+	 h->root.root.string,
+	 bfd_archive_filename (h->root.u.def.section->owner));
+      eoinfo->failed = TRUE;
+      return FALSE;
+    }
+
+  /* We don't want to output symbols that have never been mentioned by
+     a regular file, or that we have been told to strip.  However, if
+     h->indx is set to -2, the symbol is used by a reloc and we must
+     output it.  */
+  if (h->indx == -2)
+    strip = FALSE;
+  else if (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+	    || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
+	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
+	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
+    strip = TRUE;
+  else if (finfo->info->strip == strip_all)
+    strip = TRUE;
+  else if (finfo->info->strip == strip_some
+	   && bfd_hash_lookup (finfo->info->keep_hash,
+			       h->root.root.string, FALSE, FALSE) == NULL)
+    strip = TRUE;
+  else if (finfo->info->strip_discarded
+	   && (h->root.type == bfd_link_hash_defined
+	       || h->root.type == bfd_link_hash_defweak)
+	   && elf_discarded_section (h->root.u.def.section))
+    strip = TRUE;
+  else
+    strip = FALSE;
+
+  /* If we're stripping it, and it's not a dynamic symbol, there's
+     nothing else to do unless it is a forced local symbol.  */
+  if (strip
+      && h->dynindx == -1
+      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
+    return TRUE;
+
+  sym.st_value = 0;
+  sym.st_size = h->size;
+  sym.st_other = h->other;
+  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
+    sym.st_info = ELF_ST_INFO (STB_LOCAL, h->type);
+  else if (h->root.type == bfd_link_hash_undefweak
+	   || h->root.type == bfd_link_hash_defweak)
+    sym.st_info = ELF_ST_INFO (STB_WEAK, h->type);
+  else
+    sym.st_info = ELF_ST_INFO (STB_GLOBAL, h->type);
+
+  switch (h->root.type)
+    {
+    default:
+    case bfd_link_hash_new:
+    case bfd_link_hash_warning:
+      abort ();
+      return FALSE;
+
+    case bfd_link_hash_undefined:
+    case bfd_link_hash_undefweak:
+      input_sec = bfd_und_section_ptr;
+      sym.st_shndx = SHN_UNDEF;
+      break;
+
+    case bfd_link_hash_defined:
+    case bfd_link_hash_defweak:
+      {
+	input_sec = h->root.u.def.section;
+	if (input_sec->output_section != NULL)
+	  {
+	    sym.st_shndx =
+	      _bfd_elf_section_from_bfd_section (finfo->output_bfd,
+						 input_sec->output_section);
+	    if (sym.st_shndx == SHN_BAD)
+	      {
+		(*_bfd_error_handler)
+		  (_("%s: could not find output section %s for input section %s"),
+		   bfd_get_filename (finfo->output_bfd),
+		   input_sec->output_section->name,
+		   input_sec->name);
+		eoinfo->failed = TRUE;
+		return FALSE;
+	      }
+
+	    /* ELF symbols in relocateable files are section relative,
+	       but in nonrelocateable files they are virtual
+	       addresses.  */
+	    sym.st_value = h->root.u.def.value + input_sec->output_offset;
+	    if (! finfo->info->relocateable)
+	      {
+		sym.st_value += input_sec->output_section->vma;
+		if (h->type == STT_TLS)
+		  {
+		    /* STT_TLS symbols are relative to PT_TLS segment
+		       base.  */
+		    BFD_ASSERT (finfo->first_tls_sec != NULL);
+		    sym.st_value -= finfo->first_tls_sec->vma;
+		  }
+	      }
+	  }
+	else
+	  {
+	    BFD_ASSERT (input_sec->owner == NULL
+			|| (input_sec->owner->flags & DYNAMIC) != 0);
+	    sym.st_shndx = SHN_UNDEF;
+	    input_sec = bfd_und_section_ptr;
+	  }
+      }
+      break;
+
+    case bfd_link_hash_common:
+      input_sec = h->root.u.c.p->section;
+      sym.st_shndx = SHN_COMMON;
+      sym.st_value = 1 << h->root.u.c.p->alignment_power;
+      break;
+
+    case bfd_link_hash_indirect:
+      /* These symbols are created by symbol versioning.  They point
+	 to the decorated version of the name.  For example, if the
+	 symbol foo@@GNU_1.2 is the default, which should be used when
+	 foo is used with no version, then we add an indirect symbol
+	 foo which points to foo@@GNU_1.2.  We ignore these symbols,
+	 since the indirected symbol is already in the hash table.  */
+      return TRUE;
+    }
+
+  /* Give the processor backend a chance to tweak the symbol value,
+     and also to finish up anything that needs to be done for this
+     symbol.  FIXME: Not calling elf_backend_finish_dynamic_symbol for
+     forced local syms when non-shared is due to a historical quirk.  */
+  if ((h->dynindx != -1
+       || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
+      && (finfo->info->shared
+	  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
+      && elf_hash_table (finfo->info)->dynamic_sections_created)
+    {
+      struct elf_backend_data *bed;
+
+      bed = get_elf_backend_data (finfo->output_bfd);
+      if (! ((*bed->elf_backend_finish_dynamic_symbol)
+	     (finfo->output_bfd, finfo->info, h, &sym)))
+	{
+	  eoinfo->failed = TRUE;
+	  return FALSE;
+	}
+    }
+
+  /* If we are marking the symbol as undefined, and there are no
+     non-weak references to this symbol from a regular object, then
+     mark the symbol as weak undefined; if there are non-weak
+     references, mark the symbol as strong.  We can't do this earlier,
+     because it might not be marked as undefined until the
+     finish_dynamic_symbol routine gets through with it.  */
+  if (sym.st_shndx == SHN_UNDEF
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
+      && (ELF_ST_BIND (sym.st_info) == STB_GLOBAL
+	  || ELF_ST_BIND (sym.st_info) == STB_WEAK))
+    {
+      int bindtype;
+
+      if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) != 0)
+	bindtype = STB_GLOBAL;
+      else
+	bindtype = STB_WEAK;
+      sym.st_info = ELF_ST_INFO (bindtype, ELF_ST_TYPE (sym.st_info));
+    }
+
+  /* If a non-weak symbol with non-default visibility is not defined
+     locally, it is a fatal error.  */
+  if (! finfo->info->relocateable
+      && ELF_ST_VISIBILITY (sym.st_other)
+      && ELF_ST_BIND (sym.st_info) != STB_WEAK
+      && h->root.type == bfd_link_hash_undefined
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+    {
+      (*_bfd_error_handler)
+	(_("%s: %s symbol `%s' isn't defined"),
+	  bfd_get_filename (finfo->output_bfd),
+	  ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
+	  ? "protected"
+	  : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
+	    ? "internal" : "hidden",
+	  h->root.root.string);
+      eoinfo->failed = TRUE;
+      return FALSE;
+    }
+
+  /* If this symbol should be put in the .dynsym section, then put it
+     there now.  We already know the symbol index.  We also fill in
+     the entry in the .hash section.  */
+  if (h->dynindx != -1
+      && elf_hash_table (finfo->info)->dynamic_sections_created)
+    {
+      size_t bucketcount;
+      size_t bucket;
+      size_t hash_entry_size;
+      bfd_byte *bucketpos;
+      bfd_vma chain;
+      Elf_External_Sym *esym;
+
+      sym.st_name = h->dynstr_index;
+      esym = (Elf_External_Sym *) finfo->dynsym_sec->contents + h->dynindx;
+      elf_swap_symbol_out (finfo->output_bfd, &sym, (PTR) esym, (PTR) 0);
+
+      bucketcount = elf_hash_table (finfo->info)->bucketcount;
+      bucket = h->elf_hash_value % bucketcount;
+      hash_entry_size
+	= elf_section_data (finfo->hash_sec)->this_hdr.sh_entsize;
+      bucketpos = ((bfd_byte *) finfo->hash_sec->contents
+		   + (bucket + 2) * hash_entry_size);
+      chain = bfd_get (8 * hash_entry_size, finfo->output_bfd, bucketpos);
+      bfd_put (8 * hash_entry_size, finfo->output_bfd, (bfd_vma) h->dynindx,
+	       bucketpos);
+      bfd_put (8 * hash_entry_size, finfo->output_bfd, chain,
+	       ((bfd_byte *) finfo->hash_sec->contents
+		+ (bucketcount + 2 + h->dynindx) * hash_entry_size));
+
+      if (finfo->symver_sec != NULL && finfo->symver_sec->contents != NULL)
+	{
+	  Elf_Internal_Versym iversym;
+	  Elf_External_Versym *eversym;
+
+	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+	    {
+	      if (h->verinfo.verdef == NULL)
+		iversym.vs_vers = 0;
+	      else
+		iversym.vs_vers = h->verinfo.verdef->vd_exp_refno + 1;
+	    }
+	  else
+	    {
+	      if (h->verinfo.vertree == NULL)
+		iversym.vs_vers = 1;
+	      else
+		iversym.vs_vers = h->verinfo.vertree->vernum + 1;
+	    }
+
+	  if ((h->elf_link_hash_flags & ELF_LINK_HIDDEN) != 0)
+	    iversym.vs_vers |= VERSYM_HIDDEN;
+
+	  eversym = (Elf_External_Versym *) finfo->symver_sec->contents;
+	  eversym += h->dynindx;
+	  _bfd_elf_swap_versym_out (finfo->output_bfd, &iversym, eversym);
+	}
+    }
+
+  /* If we're stripping it, then it was just a dynamic symbol, and
+     there's nothing else to do.  */
+  if (strip || (input_sec->flags & SEC_EXCLUDE) != 0)
+    return TRUE;
+
+  h->indx = bfd_get_symcount (finfo->output_bfd);
+
+  if (! elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec))
+    {
+      eoinfo->failed = TRUE;
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Copy the relocations indicated by the INTERNAL_RELOCS (which
+   originated from the section given by INPUT_REL_HDR) to the
+   OUTPUT_BFD.  */
+
+static bfd_boolean
+elf_link_output_relocs (output_bfd, input_section, input_rel_hdr,
+			internal_relocs)
+     bfd *output_bfd;
+     asection *input_section;
+     Elf_Internal_Shdr *input_rel_hdr;
+     Elf_Internal_Rela *internal_relocs;
+{
+  Elf_Internal_Rela *irela;
+  Elf_Internal_Rela *irelaend;
+  bfd_byte *erel;
+  Elf_Internal_Shdr *output_rel_hdr;
+  asection *output_section;
+  unsigned int *rel_countp = NULL;
+  struct elf_backend_data *bed;
+  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
+
+  output_section = input_section->output_section;
+  output_rel_hdr = NULL;
+
+  if (elf_section_data (output_section)->rel_hdr.sh_entsize
+      == input_rel_hdr->sh_entsize)
+    {
+      output_rel_hdr = &elf_section_data (output_section)->rel_hdr;
+      rel_countp = &elf_section_data (output_section)->rel_count;
+    }
+  else if (elf_section_data (output_section)->rel_hdr2
+	   && (elf_section_data (output_section)->rel_hdr2->sh_entsize
+	       == input_rel_hdr->sh_entsize))
+    {
+      output_rel_hdr = elf_section_data (output_section)->rel_hdr2;
+      rel_countp = &elf_section_data (output_section)->rel_count2;
+    }
+  else
+    {
+      (*_bfd_error_handler)
+	(_("%s: relocation size mismatch in %s section %s"),
+	 bfd_get_filename (output_bfd),
+	 bfd_archive_filename (input_section->owner),
+	 input_section->name);
+      bfd_set_error (bfd_error_wrong_object_format);
+      return FALSE;
+    }
+
+  bed = get_elf_backend_data (output_bfd);
+  if (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
+    swap_out = bed->s->swap_reloc_out;
+  else if (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rela))
+    swap_out = bed->s->swap_reloca_out;
+  else
+    abort ();
+
+  erel = output_rel_hdr->contents;
+  erel += *rel_countp * input_rel_hdr->sh_entsize;
+  irela = internal_relocs;
+  irelaend = irela + (NUM_SHDR_ENTRIES (input_rel_hdr)
+		      * bed->s->int_rels_per_ext_rel);
+  while (irela < irelaend)
+    {
+      (*swap_out) (output_bfd, irela, erel);
+      irela += bed->s->int_rels_per_ext_rel;
+      erel += input_rel_hdr->sh_entsize;
+    }
+
+  /* Bump the counter, so that we know where to add the next set of
+     relocations.  */
+  *rel_countp += NUM_SHDR_ENTRIES (input_rel_hdr);
+
+  return TRUE;
+}
+
+/* Link an input file into the linker output file.  This function
+   handles all the sections and relocations of the input file at once.
+   This is so that we only have to read the local symbols once, and
+   don't have to keep them in memory.  */
+
+static bfd_boolean
+elf_link_input_bfd (finfo, input_bfd)
+     struct elf_final_link_info *finfo;
+     bfd *input_bfd;
+{
+  bfd_boolean (*relocate_section)
+    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+	     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
+  bfd *output_bfd;
+  Elf_Internal_Shdr *symtab_hdr;
+  size_t locsymcount;
+  size_t extsymoff;
+  Elf_Internal_Sym *isymbuf;
+  Elf_Internal_Sym *isym;
+  Elf_Internal_Sym *isymend;
+  long *pindex;
+  asection **ppsection;
+  asection *o;
+  struct elf_backend_data *bed;
+  bfd_boolean emit_relocs;
+  struct elf_link_hash_entry **sym_hashes;
+
+  output_bfd = finfo->output_bfd;
+  bed = get_elf_backend_data (output_bfd);
+  relocate_section = bed->elf_backend_relocate_section;
+
+  /* If this is a dynamic object, we don't want to do anything here:
+     we don't want the local symbols, and we don't want the section
+     contents.  */
+  if ((input_bfd->flags & DYNAMIC) != 0)
+    return TRUE;
+
+  emit_relocs = (finfo->info->relocateable
+		 || finfo->info->emitrelocations
+		 || bed->elf_backend_emit_relocs);
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  if (elf_bad_symtab (input_bfd))
+    {
+      locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
+      extsymoff = 0;
+    }
+  else
+    {
+      locsymcount = symtab_hdr->sh_info;
+      extsymoff = symtab_hdr->sh_info;
+    }
+
+  /* Read the local symbols.  */
+  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+  if (isymbuf == NULL && locsymcount != 0)
+    {
+      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
+				      finfo->internal_syms,
+				      finfo->external_syms,
+				      finfo->locsym_shndx);
+      if (isymbuf == NULL)
+	return FALSE;
+    }
+
+  /* Find local symbol sections and adjust values of symbols in
+     SEC_MERGE sections.  Write out those local symbols we know are
+     going into the output file.  */
+  isymend = isymbuf + locsymcount;
+  for (isym = isymbuf, pindex = finfo->indices, ppsection = finfo->sections;
+       isym < isymend;
+       isym++, pindex++, ppsection++)
+    {
+      asection *isec;
+      const char *name;
+      Elf_Internal_Sym osym;
+
+      *pindex = -1;
+
+      if (elf_bad_symtab (input_bfd))
+	{
+	  if (ELF_ST_BIND (isym->st_info) != STB_LOCAL)
+	    {
+	      *ppsection = NULL;
+	      continue;
+	    }
+	}
+
+      if (isym->st_shndx == SHN_UNDEF)
+	isec = bfd_und_section_ptr;
+      else if (isym->st_shndx < SHN_LORESERVE
+	       || isym->st_shndx > SHN_HIRESERVE)
+	{
+	  isec = section_from_elf_index (input_bfd, isym->st_shndx);
+	  if (isec
+	      && isec->sec_info_type == ELF_INFO_TYPE_MERGE
+	      && ELF_ST_TYPE (isym->st_info) != STT_SECTION)
+	    isym->st_value =
+	      _bfd_merged_section_offset (output_bfd, &isec,
+					  elf_section_data (isec)->sec_info,
+					  isym->st_value, (bfd_vma) 0);
+	}
+      else if (isym->st_shndx == SHN_ABS)
+	isec = bfd_abs_section_ptr;
+      else if (isym->st_shndx == SHN_COMMON)
+	isec = bfd_com_section_ptr;
+      else
+	{
+	  /* Who knows?  */
+	  isec = NULL;
+	}
+
+      *ppsection = isec;
+
+      /* Don't output the first, undefined, symbol.  */
+      if (ppsection == finfo->sections)
+	continue;
+
+      if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
+	{
+	  /* We never output section symbols.  Instead, we use the
+	     section symbol of the corresponding section in the output
+	     file.  */
+	  continue;
+	}
+
+      /* If we are stripping all symbols, we don't want to output this
+	 one.  */
+      if (finfo->info->strip == strip_all)
+	continue;
+
+      /* If we are discarding all local symbols, we don't want to
+	 output this one.  If we are generating a relocateable output
+	 file, then some of the local symbols may be required by
+	 relocs; we output them below as we discover that they are
+	 needed.  */
+      if (finfo->info->discard == discard_all)
+	continue;
+
+      /* If this symbol is defined in a section which we are
+	 discarding, we don't need to keep it, but note that
+	 linker_mark is only reliable for sections that have contents.
+	 For the benefit of the MIPS ELF linker, we check SEC_EXCLUDE
+	 as well as linker_mark.  */
+      if ((isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
+	  && isec != NULL
+	  && ((! isec->linker_mark && (isec->flags & SEC_HAS_CONTENTS) != 0)
+	      || (! finfo->info->relocateable
+		  && (isec->flags & SEC_EXCLUDE) != 0)))
+	continue;
+
+      /* Get the name of the symbol.  */
+      name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link,
+					      isym->st_name);
+      if (name == NULL)
+	return FALSE;
+
+      /* See if we are discarding symbols with this name.  */
+      if ((finfo->info->strip == strip_some
+	   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
+	       == NULL))
+	  || (((finfo->info->discard == discard_sec_merge
+		&& (isec->flags & SEC_MERGE) && ! finfo->info->relocateable)
+	       || finfo->info->discard == discard_l)
+	      && bfd_is_local_label_name (input_bfd, name)))
+	continue;
+
+      /* If we get here, we are going to output this symbol.  */
+
+      osym = *isym;
+
+      /* Adjust the section index for the output file.  */
+      osym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
+							 isec->output_section);
+      if (osym.st_shndx == SHN_BAD)
+	return FALSE;
+
+      *pindex = bfd_get_symcount (output_bfd);
+
+      /* ELF symbols in relocateable files are section relative, but
+	 in executable files they are virtual addresses.  Note that
+	 this code assumes that all ELF sections have an associated
+	 BFD section with a reasonable value for output_offset; below
+	 we assume that they also have a reasonable value for
+	 output_section.  Any special sections must be set up to meet
+	 these requirements.  */
+      osym.st_value += isec->output_offset;
+      if (! finfo->info->relocateable)
+	{
+	  osym.st_value += isec->output_section->vma;
+	  if (ELF_ST_TYPE (osym.st_info) == STT_TLS)
+	    {
+	      /* STT_TLS symbols are relative to PT_TLS segment base.  */
+	      BFD_ASSERT (finfo->first_tls_sec != NULL);
+	      osym.st_value -= finfo->first_tls_sec->vma;
+	    }
+	}
+
+      if (! elf_link_output_sym (finfo, name, &osym, isec))
+	return FALSE;
+    }
+
+  /* Relocate the contents of each section.  */
+  sym_hashes = elf_sym_hashes (input_bfd);
+  for (o = input_bfd->sections; o != NULL; o = o->next)
+    {
+      bfd_byte *contents;
+
+      if (! o->linker_mark)
+	{
+	  /* This section was omitted from the link.  */
+	  continue;
+	}
+
+      if ((o->flags & SEC_HAS_CONTENTS) == 0
+	  || (o->_raw_size == 0 && (o->flags & SEC_RELOC) == 0))
+	continue;
+
+      if ((o->flags & SEC_LINKER_CREATED) != 0)
+	{
+	  /* Section was created by elf_link_create_dynamic_sections
+	     or somesuch.  */
+	  continue;
+	}
+
+      /* Get the contents of the section.  They have been cached by a
+	 relaxation routine.  Note that o is a section in an input
+	 file, so the contents field will not have been set by any of
+	 the routines which work on output files.  */
+      if (elf_section_data (o)->this_hdr.contents != NULL)
+	contents = elf_section_data (o)->this_hdr.contents;
+      else
+	{
+	  contents = finfo->contents;
+	  if (! bfd_get_section_contents (input_bfd, o, contents,
+					  (file_ptr) 0, o->_raw_size))
+	    return FALSE;
+	}
+
+      if ((o->flags & SEC_RELOC) != 0)
+	{
+	  Elf_Internal_Rela *internal_relocs;
+
+	  /* Get the swapped relocs.  */
+	  internal_relocs = (NAME(_bfd_elf,link_read_relocs)
+			     (input_bfd, o, finfo->external_relocs,
+			      finfo->internal_relocs, FALSE));
+	  if (internal_relocs == NULL
+	      && o->reloc_count > 0)
+	    return FALSE;
+
+	  /* Run through the relocs looking for any against symbols
+	     from discarded sections and section symbols from
+	     removed link-once sections.  Complain about relocs
+	     against discarded sections.  Zero relocs against removed
+	     link-once sections.  */
+	  if (!finfo->info->relocateable
+	      && !elf_section_ignore_discarded_relocs (o))
+	    {
+	      Elf_Internal_Rela *rel, *relend;
+
+	      rel = internal_relocs;
+	      relend = rel + o->reloc_count * bed->s->int_rels_per_ext_rel;
+	      for ( ; rel < relend; rel++)
+		{
+		  unsigned long r_symndx = ELF_R_SYM (rel->r_info);
+
+		  if (r_symndx >= locsymcount
+		      || (elf_bad_symtab (input_bfd)
+			  && finfo->sections[r_symndx] == NULL))
+		    {
+		      struct elf_link_hash_entry *h;
+
+		      h = sym_hashes[r_symndx - extsymoff];
+		      while (h->root.type == bfd_link_hash_indirect
+			     || h->root.type == bfd_link_hash_warning)
+			h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+		      /* Complain if the definition comes from a
+			 discarded section.  */
+		      if ((h->root.type == bfd_link_hash_defined
+			   || h->root.type == bfd_link_hash_defweak)
+			  && elf_discarded_section (h->root.u.def.section))
+			{
+			  if ((o->flags & SEC_DEBUGGING) != 0)
+			    {
+			      BFD_ASSERT (r_symndx != 0);
+			      memset (rel, 0, sizeof (*rel));
+			    }
+			  else
+			    {
+			      if (! ((*finfo->info->callbacks->undefined_symbol)
+				     (finfo->info, h->root.root.string,
+				      input_bfd, o, rel->r_offset,
+				      TRUE)))
+				return FALSE;
+			    }
+			}
+		    }
+		  else
+		    {
+		      asection *sec = finfo->sections[r_symndx];
+
+		      if (sec != NULL && elf_discarded_section (sec))
+			{
+			  if ((o->flags & SEC_DEBUGGING) != 0
+			      || (sec->flags & SEC_LINK_ONCE) != 0)
+			    {
+			      BFD_ASSERT (r_symndx != 0);
+			      rel->r_info
+				= ELF_R_INFO (0, ELF_R_TYPE (rel->r_info));
+			      rel->r_addend = 0;
+			    }
+			  else
+			    {
+			      bfd_boolean ok;
+			      const char *msg
+				= _("local symbols in discarded section %s");
+			      bfd_size_type amt
+				= strlen (sec->name) + strlen (msg) - 1;
+			      char *buf = (char *) bfd_malloc (amt);
+
+			      if (buf != NULL)
+				sprintf (buf, msg, sec->name);
+			      else
+				buf = (char *) sec->name;
+			      ok = (*finfo->info->callbacks
+				    ->undefined_symbol) (finfo->info, buf,
+							 input_bfd, o,
+							 rel->r_offset,
+							 TRUE);
+			      if (buf != sec->name)
+				free (buf);
+			      if (!ok)
+				return FALSE;
+			    }
+			}
+		    }
+		}
+	    }
+
+	  /* Relocate the section by invoking a back end routine.
+
+	     The back end routine is responsible for adjusting the
+	     section contents as necessary, and (if using Rela relocs
+	     and generating a relocateable output file) adjusting the
+	     reloc addend as necessary.
+
+	     The back end routine does not have to worry about setting
+	     the reloc address or the reloc symbol index.
+
+	     The back end routine is given a pointer to the swapped in
+	     internal symbols, and can access the hash table entries
+	     for the external symbols via elf_sym_hashes (input_bfd).
+
+	     When generating relocateable output, the back end routine
+	     must handle STB_LOCAL/STT_SECTION symbols specially.  The
+	     output symbol is going to be a section symbol
+	     corresponding to the output section, which will require
+	     the addend to be adjusted.  */
+
+	  if (! (*relocate_section) (output_bfd, finfo->info,
+				     input_bfd, o, contents,
+				     internal_relocs,
+				     isymbuf,
+				     finfo->sections))
+	    return FALSE;
+
+	  if (emit_relocs)
+	    {
+	      Elf_Internal_Rela *irela;
+	      Elf_Internal_Rela *irelaend;
+	      bfd_vma last_offset;
+	      struct elf_link_hash_entry **rel_hash;
+	      Elf_Internal_Shdr *input_rel_hdr, *input_rel_hdr2;
+	      unsigned int next_erel;
+	      bfd_boolean (*reloc_emitter)
+		PARAMS ((bfd *, asection *, Elf_Internal_Shdr *,
+			 Elf_Internal_Rela *));
+	      bfd_boolean rela_normal;
+
+	      input_rel_hdr = &elf_section_data (o)->rel_hdr;
+	      rela_normal = (bed->rela_normal
+			     && (input_rel_hdr->sh_entsize
+				 == sizeof (Elf_External_Rela)));
+
+	      /* Adjust the reloc addresses and symbol indices.  */
+
+	      irela = internal_relocs;
+	      irelaend = irela + o->reloc_count * bed->s->int_rels_per_ext_rel;
+	      rel_hash = (elf_section_data (o->output_section)->rel_hashes
+			  + elf_section_data (o->output_section)->rel_count
+			  + elf_section_data (o->output_section)->rel_count2);
+	      last_offset = o->output_offset;
+	      if (!finfo->info->relocateable)
+		last_offset += o->output_section->vma;
+	      for (next_erel = 0; irela < irelaend; irela++, next_erel++)
+		{
+		  unsigned long r_symndx;
+		  asection *sec;
+		  Elf_Internal_Sym sym;
+
+		  if (next_erel == bed->s->int_rels_per_ext_rel)
+		    {
+		      rel_hash++;
+		      next_erel = 0;
+		    }
+
+		  irela->r_offset = _bfd_elf_section_offset (output_bfd,
+							     finfo->info, o,
+							     irela->r_offset);
+		  if (irela->r_offset >= (bfd_vma) -2)
+		    {
+		      /* This is a reloc for a deleted entry or somesuch.
+			 Turn it into an R_*_NONE reloc, at the same
+			 offset as the last reloc.  elf_eh_frame.c and
+			 elf_bfd_discard_info rely on reloc offsets
+			 being ordered.  */
+		      irela->r_offset = last_offset;
+		      irela->r_info = 0;
+		      irela->r_addend = 0;
+		      continue;
+		    }
+
+		  irela->r_offset += o->output_offset;
+
+		  /* Relocs in an executable have to be virtual addresses.  */
+		  if (!finfo->info->relocateable)
+		    irela->r_offset += o->output_section->vma;
+
+		  last_offset = irela->r_offset;
+
+		  r_symndx = ELF_R_SYM (irela->r_info);
+		  if (r_symndx == STN_UNDEF)
+		    continue;
+
+		  if (r_symndx >= locsymcount
+		      || (elf_bad_symtab (input_bfd)
+			  && finfo->sections[r_symndx] == NULL))
+		    {
+		      struct elf_link_hash_entry *rh;
+		      unsigned long indx;
+
+		      /* This is a reloc against a global symbol.  We
+			 have not yet output all the local symbols, so
+			 we do not know the symbol index of any global
+			 symbol.  We set the rel_hash entry for this
+			 reloc to point to the global hash table entry
+			 for this symbol.  The symbol index is then
+			 set at the end of elf_bfd_final_link.  */
+		      indx = r_symndx - extsymoff;
+		      rh = elf_sym_hashes (input_bfd)[indx];
+		      while (rh->root.type == bfd_link_hash_indirect
+			     || rh->root.type == bfd_link_hash_warning)
+			rh = (struct elf_link_hash_entry *) rh->root.u.i.link;
+
+		      /* Setting the index to -2 tells
+			 elf_link_output_extsym that this symbol is
+			 used by a reloc.  */
+		      BFD_ASSERT (rh->indx < 0);
+		      rh->indx = -2;
+
+		      *rel_hash = rh;
+
+		      continue;
+		    }
+
+		  /* This is a reloc against a local symbol.  */
+
+		  *rel_hash = NULL;
+		  sym = isymbuf[r_symndx];
+		  sec = finfo->sections[r_symndx];
+		  if (ELF_ST_TYPE (sym.st_info) == STT_SECTION)
+		    {
+		      /* I suppose the backend ought to fill in the
+			 section of any STT_SECTION symbol against a
+			 processor specific section.  If we have
+			 discarded a section, the output_section will
+			 be the absolute section.  */
+		      if (bfd_is_abs_section (sec)
+			  || (sec != NULL
+			      && bfd_is_abs_section (sec->output_section)))
+			r_symndx = 0;
+		      else if (sec == NULL || sec->owner == NULL)
+			{
+			  bfd_set_error (bfd_error_bad_value);
+			  return FALSE;
+			}
+		      else
+			{
+			  r_symndx = sec->output_section->target_index;
+			  BFD_ASSERT (r_symndx != 0);
+			}
+
+		      /* Adjust the addend according to where the
+			 section winds up in the output section.  */
+		      if (rela_normal)
+			irela->r_addend += sec->output_offset;
+		    }
+		  else
+		    {
+		      if (finfo->indices[r_symndx] == -1)
+			{
+			  unsigned long shlink;
+			  const char *name;
+			  asection *osec;
+
+			  if (finfo->info->strip == strip_all)
+			    {
+			      /* You can't do ld -r -s.  */
+			      bfd_set_error (bfd_error_invalid_operation);
+			      return FALSE;
+			    }
+
+			  /* This symbol was skipped earlier, but
+			     since it is needed by a reloc, we
+			     must output it now.  */
+			  shlink = symtab_hdr->sh_link;
+			  name = (bfd_elf_string_from_elf_section
+				  (input_bfd, shlink, sym.st_name));
+			  if (name == NULL)
+			    return FALSE;
+
+			  osec = sec->output_section;
+			  sym.st_shndx =
+			    _bfd_elf_section_from_bfd_section (output_bfd,
+							       osec);
+			  if (sym.st_shndx == SHN_BAD)
+			    return FALSE;
+
+			  sym.st_value += sec->output_offset;
+			  if (! finfo->info->relocateable)
+			    {
+			      sym.st_value += osec->vma;
+			      if (ELF_ST_TYPE (sym.st_info) == STT_TLS)
+				{
+				  /* STT_TLS symbols are relative to PT_TLS
+				     segment base.  */
+				  BFD_ASSERT (finfo->first_tls_sec != NULL);
+				  sym.st_value -= finfo->first_tls_sec->vma;
+				}
+			    }
+
+			  finfo->indices[r_symndx]
+			    = bfd_get_symcount (output_bfd);
+
+			  if (! elf_link_output_sym (finfo, name, &sym, sec))
+			    return FALSE;
+			}
+
+		      r_symndx = finfo->indices[r_symndx];
+		    }
+
+		  irela->r_info = ELF_R_INFO (r_symndx,
+					      ELF_R_TYPE (irela->r_info));
+		}
+
+	      /* Swap out the relocs.  */
+	      if (bed->elf_backend_emit_relocs
+		  && !(finfo->info->relocateable
+		       || finfo->info->emitrelocations))
+		reloc_emitter = bed->elf_backend_emit_relocs;
+	      else
+		reloc_emitter = elf_link_output_relocs;
+
+	      if (input_rel_hdr->sh_size != 0
+		  && ! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
+					 internal_relocs))
+		return FALSE;
+
+	      input_rel_hdr2 = elf_section_data (o)->rel_hdr2;
+	      if (input_rel_hdr2 && input_rel_hdr2->sh_size != 0)
+		{
+		  internal_relocs += (NUM_SHDR_ENTRIES (input_rel_hdr)
+				      * bed->s->int_rels_per_ext_rel);
+		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr2,
+					  internal_relocs))
+		    return FALSE;
+		}
+	    }
+	}
+
+      /* Write out the modified section contents.  */
+      if (bed->elf_backend_write_section
+	  && (*bed->elf_backend_write_section) (output_bfd, o, contents))
+	{
+	  /* Section written out.  */
+	}
+      else switch (o->sec_info_type)
+	{
+	case ELF_INFO_TYPE_STABS:
+	  if (! (_bfd_write_section_stabs
+		 (output_bfd,
+		  &elf_hash_table (finfo->info)->stab_info,
+		  o, &elf_section_data (o)->sec_info, contents)))
+	    return FALSE;
+	  break;
+	case ELF_INFO_TYPE_MERGE:
+	  if (! _bfd_write_merged_section (output_bfd, o,
+					   elf_section_data (o)->sec_info))
+	    return FALSE;
+	  break;
+	case ELF_INFO_TYPE_EH_FRAME:
+	  {
+	    if (! _bfd_elf_write_section_eh_frame (output_bfd, finfo->info,
+						   o, contents))
+	      return FALSE;
+	  }
+	  break;
+	default:
+	  {
+	    bfd_size_type sec_size;
+
+	    sec_size = (o->_cooked_size != 0 ? o->_cooked_size : o->_raw_size);
+	    if (! (o->flags & SEC_EXCLUDE)
+		&& ! bfd_set_section_contents (output_bfd, o->output_section,
+					       contents,
+					       (file_ptr) o->output_offset,
+					       sec_size))
+	      return FALSE;
+	  }
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Generate a reloc when linking an ELF file.  This is a reloc
+   requested by the linker, and does come from any input file.  This
+   is used to build constructor and destructor tables when linking
+   with -Ur.  */
+
+static bfd_boolean
+elf_reloc_link_order (output_bfd, info, output_section, link_order)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+     asection *output_section;
+     struct bfd_link_order *link_order;
+{
+  reloc_howto_type *howto;
+  long indx;
+  bfd_vma offset;
+  bfd_vma addend;
+  struct elf_link_hash_entry **rel_hash_ptr;
+  Elf_Internal_Shdr *rel_hdr;
+  struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+  Elf_Internal_Rela irel[MAX_INT_RELS_PER_EXT_REL];
+  bfd_byte *erel;
+  unsigned int i;
+
+  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
+  if (howto == NULL)
+    {
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+
+  addend = link_order->u.reloc.p->addend;
+
+  /* Figure out the symbol index.  */
+  rel_hash_ptr = (elf_section_data (output_section)->rel_hashes
+		  + elf_section_data (output_section)->rel_count
+		  + elf_section_data (output_section)->rel_count2);
+  if (link_order->type == bfd_section_reloc_link_order)
+    {
+      indx = link_order->u.reloc.p->u.section->target_index;
+      BFD_ASSERT (indx != 0);
+      *rel_hash_ptr = NULL;
+    }
+  else
+    {
+      struct elf_link_hash_entry *h;
+
+      /* Treat a reloc against a defined symbol as though it were
+	 actually against the section.  */
+      h = ((struct elf_link_hash_entry *)
+	   bfd_wrapped_link_hash_lookup (output_bfd, info,
+					 link_order->u.reloc.p->u.name,
+					 FALSE, FALSE, TRUE));
+      if (h != NULL
+	  && (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak))
+	{
+	  asection *section;
+
+	  section = h->root.u.def.section;
+	  indx = section->output_section->target_index;
+	  *rel_hash_ptr = NULL;
+	  /* It seems that we ought to add the symbol value to the
+	     addend here, but in practice it has already been added
+	     because it was passed to constructor_callback.  */
+	  addend += section->output_section->vma + section->output_offset;
+	}
+      else if (h != NULL)
+	{
+	  /* Setting the index to -2 tells elf_link_output_extsym that
+	     this symbol is used by a reloc.  */
+	  h->indx = -2;
+	  *rel_hash_ptr = h;
+	  indx = 0;
+	}
+      else
+	{
+	  if (! ((*info->callbacks->unattached_reloc)
+		 (info, link_order->u.reloc.p->u.name, (bfd *) NULL,
+		  (asection *) NULL, (bfd_vma) 0)))
+	    return FALSE;
+	  indx = 0;
+	}
+    }
+
+  /* If this is an inplace reloc, we must write the addend into the
+     object file.  */
+  if (howto->partial_inplace && addend != 0)
+    {
+      bfd_size_type size;
+      bfd_reloc_status_type rstat;
+      bfd_byte *buf;
+      bfd_boolean ok;
+      const char *sym_name;
+
+      size = bfd_get_reloc_size (howto);
+      buf = (bfd_byte *) bfd_zmalloc (size);
+      if (buf == (bfd_byte *) NULL)
+	return FALSE;
+      rstat = _bfd_relocate_contents (howto, output_bfd, (bfd_vma) addend, buf);
+      switch (rstat)
+	{
+	case bfd_reloc_ok:
+	  break;
+
+	default:
+	case bfd_reloc_outofrange:
+	  abort ();
+
+	case bfd_reloc_overflow:
+	  if (link_order->type == bfd_section_reloc_link_order)
+	    sym_name = bfd_section_name (output_bfd,
+					 link_order->u.reloc.p->u.section);
+	  else
+	    sym_name = link_order->u.reloc.p->u.name;
+	  if (! ((*info->callbacks->reloc_overflow)
+		 (info, sym_name, howto->name, addend,
+		  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0)))
+	    {
+	      free (buf);
+	      return FALSE;
+	    }
+	  break;
+	}
+      ok = bfd_set_section_contents (output_bfd, output_section, (PTR) buf,
+				     (file_ptr) link_order->offset, size);
+      free (buf);
+      if (! ok)
+	return FALSE;
+    }
+
+  /* The address of a reloc is relative to the section in a
+     relocateable file, and is a virtual address in an executable
+     file.  */
+  offset = link_order->offset;
+  if (! info->relocateable)
+    offset += output_section->vma;
+
+  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
+    {
+      irel[i].r_offset = offset;
+      irel[i].r_info = 0;
+      irel[i].r_addend = 0;
+    }
+  irel[0].r_info = ELF_R_INFO (indx, howto->type);
+
+  rel_hdr = &elf_section_data (output_section)->rel_hdr;
+  erel = rel_hdr->contents;
+  if (rel_hdr->sh_type == SHT_REL)
+    {
+      erel += (elf_section_data (output_section)->rel_count
+	       * sizeof (Elf_External_Rel));
+      (*bed->s->swap_reloc_out) (output_bfd, irel, erel);
+    }
+  else
+    {
+      irel[0].r_addend = addend;
+      erel += (elf_section_data (output_section)->rel_count
+	       * sizeof (Elf_External_Rela));
+      (*bed->s->swap_reloca_out) (output_bfd, irel, erel);
+    }
+
+  ++elf_section_data (output_section)->rel_count;
+
+  return TRUE;
+}
+
+/* Allocate a pointer to live in a linker created section.  */
+
+bfd_boolean
+elf_create_pointer_linker_section (abfd, info, lsect, h, rel)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     elf_linker_section_t *lsect;
+     struct elf_link_hash_entry *h;
+     const Elf_Internal_Rela *rel;
+{
+  elf_linker_section_pointers_t **ptr_linker_section_ptr = NULL;
+  elf_linker_section_pointers_t *linker_section_ptr;
+  unsigned long r_symndx = ELF_R_SYM (rel->r_info);
+  bfd_size_type amt;
+
+  BFD_ASSERT (lsect != NULL);
+
+  /* Is this a global symbol?  */
+  if (h != NULL)
+    {
+      /* Has this symbol already been allocated?  If so, our work is done.  */
+      if (_bfd_elf_find_pointer_linker_section (h->linker_section_pointer,
+						rel->r_addend,
+						lsect->which))
+	return TRUE;
+
+      ptr_linker_section_ptr = &h->linker_section_pointer;
+      /* Make sure this symbol is output as a dynamic symbol.  */
+      if (h->dynindx == -1)
+	{
+	  if (! elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      if (lsect->rel_section)
+	lsect->rel_section->_raw_size += sizeof (Elf_External_Rela);
+    }
+  else
+    {
+      /* Allocation of a pointer to a local symbol.  */
+      elf_linker_section_pointers_t **ptr = elf_local_ptr_offsets (abfd);
+
+      /* Allocate a table to hold the local symbols if first time.  */
+      if (!ptr)
+	{
+	  unsigned int num_symbols = elf_tdata (abfd)->symtab_hdr.sh_info;
+	  register unsigned int i;
+
+	  amt = num_symbols;
+	  amt *= sizeof (elf_linker_section_pointers_t *);
+	  ptr = (elf_linker_section_pointers_t **) bfd_alloc (abfd, amt);
+
+	  if (!ptr)
+	    return FALSE;
+
+	  elf_local_ptr_offsets (abfd) = ptr;
+	  for (i = 0; i < num_symbols; i++)
+	    ptr[i] = (elf_linker_section_pointers_t *) 0;
+	}
+
+      /* Has this symbol already been allocated?  If so, our work is done.  */
+      if (_bfd_elf_find_pointer_linker_section (ptr[r_symndx],
+						rel->r_addend,
+						lsect->which))
+	return TRUE;
+
+      ptr_linker_section_ptr = &ptr[r_symndx];
+
+      if (info->shared)
+	{
+	  /* If we are generating a shared object, we need to
+	     output a R_<xxx>_RELATIVE reloc so that the
+	     dynamic linker can adjust this GOT entry.  */
+	  BFD_ASSERT (lsect->rel_section != NULL);
+	  lsect->rel_section->_raw_size += sizeof (Elf_External_Rela);
+	}
+    }
+
+  /* Allocate space for a pointer in the linker section, and allocate
+     a new pointer record from internal memory.  */
+  BFD_ASSERT (ptr_linker_section_ptr != NULL);
+  amt = sizeof (elf_linker_section_pointers_t);
+  linker_section_ptr = (elf_linker_section_pointers_t *) bfd_alloc (abfd, amt);
+
+  if (!linker_section_ptr)
+    return FALSE;
+
+  linker_section_ptr->next = *ptr_linker_section_ptr;
+  linker_section_ptr->addend = rel->r_addend;
+  linker_section_ptr->which = lsect->which;
+  linker_section_ptr->written_address_p = FALSE;
+  *ptr_linker_section_ptr = linker_section_ptr;
+
+#if 0
+  if (lsect->hole_size && lsect->hole_offset < lsect->max_hole_offset)
+    {
+      linker_section_ptr->offset = (lsect->section->_raw_size
+				    - lsect->hole_size + (ARCH_SIZE / 8));
+      lsect->hole_offset += ARCH_SIZE / 8;
+      lsect->sym_offset  += ARCH_SIZE / 8;
+      if (lsect->sym_hash)
+	{
+	  /* Bump up symbol value if needed.  */
+	  lsect->sym_hash->root.u.def.value += ARCH_SIZE / 8;
+#ifdef DEBUG
+	  fprintf (stderr, "Bump up %s by %ld, current value = %ld\n",
+		   lsect->sym_hash->root.root.string,
+		   (long) ARCH_SIZE / 8,
+		   (long) lsect->sym_hash->root.u.def.value);
+#endif
+	}
+    }
+  else
+#endif
+    linker_section_ptr->offset = lsect->section->_raw_size;
+
+  lsect->section->_raw_size += ARCH_SIZE / 8;
+
+#ifdef DEBUG
+  fprintf (stderr,
+	   "Create pointer in linker section %s, offset = %ld, section size = %ld\n",
+	   lsect->name, (long) linker_section_ptr->offset,
+	   (long) lsect->section->_raw_size);
+#endif
+
+  return TRUE;
+}
+
+#if ARCH_SIZE==64
+#define bfd_put_ptr(BFD,VAL,ADDR) bfd_put_64 (BFD, VAL, ADDR)
+#endif
+#if ARCH_SIZE==32
+#define bfd_put_ptr(BFD,VAL,ADDR) bfd_put_32 (BFD, VAL, ADDR)
+#endif
+
+/* Fill in the address for a pointer generated in a linker section.  */
+
+bfd_vma
+elf_finish_pointer_linker_section (output_bfd, input_bfd, info, lsect, h,
+				   relocation, rel, relative_reloc)
+     bfd *output_bfd;
+     bfd *input_bfd;
+     struct bfd_link_info *info;
+     elf_linker_section_t *lsect;
+     struct elf_link_hash_entry *h;
+     bfd_vma relocation;
+     const Elf_Internal_Rela *rel;
+     int relative_reloc;
+{
+  elf_linker_section_pointers_t *linker_section_ptr;
+
+  BFD_ASSERT (lsect != NULL);
+
+  if (h != NULL)
+    {
+      /* Handle global symbol.  */
+      linker_section_ptr = (_bfd_elf_find_pointer_linker_section
+			    (h->linker_section_pointer,
+			     rel->r_addend,
+			     lsect->which));
+
+      BFD_ASSERT (linker_section_ptr != NULL);
+
+      if (! elf_hash_table (info)->dynamic_sections_created
+	  || (info->shared
+	      && info->symbolic
+	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
+	{
+	  /* This is actually a static link, or it is a
+	     -Bsymbolic link and the symbol is defined
+	     locally.  We must initialize this entry in the
+	     global section.
+
+	     When doing a dynamic link, we create a .rela.<xxx>
+	     relocation entry to initialize the value.  This
+	     is done in the finish_dynamic_symbol routine.  */
+	  if (!linker_section_ptr->written_address_p)
+	    {
+	      linker_section_ptr->written_address_p = TRUE;
+	      bfd_put_ptr (output_bfd,
+			   relocation + linker_section_ptr->addend,
+			   (lsect->section->contents
+			    + linker_section_ptr->offset));
+	    }
+	}
+    }
+  else
+    {
+      /* Handle local symbol.  */
+      unsigned long r_symndx = ELF_R_SYM (rel->r_info);
+      BFD_ASSERT (elf_local_ptr_offsets (input_bfd) != NULL);
+      BFD_ASSERT (elf_local_ptr_offsets (input_bfd)[r_symndx] != NULL);
+      linker_section_ptr = (_bfd_elf_find_pointer_linker_section
+			    (elf_local_ptr_offsets (input_bfd)[r_symndx],
+			     rel->r_addend,
+			     lsect->which));
+
+      BFD_ASSERT (linker_section_ptr != NULL);
+
+      /* Write out pointer if it hasn't been rewritten out before.  */
+      if (!linker_section_ptr->written_address_p)
+	{
+	  linker_section_ptr->written_address_p = TRUE;
+	  bfd_put_ptr (output_bfd, relocation + linker_section_ptr->addend,
+		       lsect->section->contents + linker_section_ptr->offset);
+
+	  if (info->shared)
+	    {
+	      asection *srel = lsect->rel_section;
+	      Elf_Internal_Rela outrel[MAX_INT_RELS_PER_EXT_REL];
+	      bfd_byte *erel;
+	      struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+	      unsigned int i;
+
+	      /* We need to generate a relative reloc for the dynamic
+		 linker.  */
+	      if (!srel)
+		{
+		  srel = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
+						  lsect->rel_name);
+		  lsect->rel_section = srel;
+		}
+
+	      BFD_ASSERT (srel != NULL);
+
+	      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
+		{
+		  outrel[i].r_offset = (lsect->section->output_section->vma
+					+ lsect->section->output_offset
+					+ linker_section_ptr->offset);
+		  outrel[i].r_info = 0;
+		  outrel[i].r_addend = 0;
+		}
+	      outrel[0].r_info = ELF_R_INFO (0, relative_reloc);
+	      erel = lsect->section->contents;
+	      erel += (elf_section_data (lsect->section)->rel_count++
+		       * sizeof (Elf_External_Rela));
+	      elf_swap_reloca_out (output_bfd, outrel, erel);
+	    }
+	}
+    }
+
+  relocation = (lsect->section->output_offset
+		+ linker_section_ptr->offset
+		- lsect->hole_offset
+		- lsect->sym_offset);
+
+#ifdef DEBUG
+  fprintf (stderr,
+	   "Finish pointer in linker section %s, offset = %ld (0x%lx)\n",
+	   lsect->name, (long) relocation, (long) relocation);
+#endif
+
+  /* Subtract out the addend, because it will get added back in by the normal
+     processing.  */
+  return relocation - linker_section_ptr->addend;
+}
+
+/* Garbage collect unused sections.  */
+
+static bfd_boolean elf_gc_mark
+  PARAMS ((struct bfd_link_info *, asection *,
+	   asection * (*) (asection *, struct bfd_link_info *,
+			   Elf_Internal_Rela *, struct elf_link_hash_entry *,
+			   Elf_Internal_Sym *)));
+
+static bfd_boolean elf_gc_sweep
+  PARAMS ((struct bfd_link_info *,
+	   bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *,
+			    const Elf_Internal_Rela *)));
+
+static bfd_boolean elf_gc_sweep_symbol
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+
+static bfd_boolean elf_gc_allocate_got_offsets
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+
+static bfd_boolean elf_gc_propagate_vtable_entries_used
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+
+static bfd_boolean elf_gc_smash_unused_vtentry_relocs
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+
+/* The mark phase of garbage collection.  For a given section, mark
+   it and any sections in this section's group, and all the sections
+   which define symbols to which it refers.  */
+
+typedef asection * (*gc_mark_hook_fn)
+  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
+	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
+
+static bfd_boolean
+elf_gc_mark (info, sec, gc_mark_hook)
+     struct bfd_link_info *info;
+     asection *sec;
+     gc_mark_hook_fn gc_mark_hook;
+{
+  bfd_boolean ret;
+  asection *group_sec;
+
+  sec->gc_mark = 1;
+
+  /* Mark all the sections in the group.  */
+  group_sec = elf_section_data (sec)->next_in_group;
+  if (group_sec && !group_sec->gc_mark)
+    if (!elf_gc_mark (info, group_sec, gc_mark_hook))
+      return FALSE;
+
+  /* Look through the section relocs.  */
+  ret = TRUE;
+  if ((sec->flags & SEC_RELOC) != 0 && sec->reloc_count > 0)
+    {
+      Elf_Internal_Rela *relstart, *rel, *relend;
+      Elf_Internal_Shdr *symtab_hdr;
+      struct elf_link_hash_entry **sym_hashes;
+      size_t nlocsyms;
+      size_t extsymoff;
+      bfd *input_bfd = sec->owner;
+      struct elf_backend_data *bed = get_elf_backend_data (input_bfd);
+      Elf_Internal_Sym *isym = NULL;
+
+      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+      sym_hashes = elf_sym_hashes (input_bfd);
+
+      /* Read the local symbols.  */
+      if (elf_bad_symtab (input_bfd))
+	{
+	  nlocsyms = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
+	  extsymoff = 0;
+	}
+      else
+	extsymoff = nlocsyms = symtab_hdr->sh_info;
+
+      isym = (Elf_Internal_Sym *) symtab_hdr->contents;
+      if (isym == NULL && nlocsyms != 0)
+	{
+	  isym = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, nlocsyms, 0,
+				       NULL, NULL, NULL);
+	  if (isym == NULL)
+	    return FALSE;
+	}
+
+      /* Read the relocations.  */
+      relstart = (NAME(_bfd_elf,link_read_relocs)
+		  (input_bfd, sec, NULL, (Elf_Internal_Rela *) NULL,
+		   info->keep_memory));
+      if (relstart == NULL)
+	{
+	  ret = FALSE;
+	  goto out1;
+	}
+      relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;
+
+      for (rel = relstart; rel < relend; rel++)
+	{
+	  unsigned long r_symndx;
+	  asection *rsec;
+	  struct elf_link_hash_entry *h;
+
+	  r_symndx = ELF_R_SYM (rel->r_info);
+	  if (r_symndx == 0)
+	    continue;
+
+	  if (r_symndx >= nlocsyms
+	      || ELF_ST_BIND (isym[r_symndx].st_info) != STB_LOCAL)
+	    {
+	      h = sym_hashes[r_symndx - extsymoff];
+	      rsec = (*gc_mark_hook) (sec, info, rel, h, NULL);
+	    }
+	  else
+	    {
+	      rsec = (*gc_mark_hook) (sec, info, rel, NULL, &isym[r_symndx]);
+	    }
+
+	  if (rsec && !rsec->gc_mark)
+	    {
+	      if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour)
+		rsec->gc_mark = 1;
+	      else if (!elf_gc_mark (info, rsec, gc_mark_hook))
+		{
+		  ret = FALSE;
+		  goto out2;
+		}
+	    }
+	}
+
+    out2:
+      if (elf_section_data (sec)->relocs != relstart)
+	free (relstart);
+    out1:
+      if (isym != NULL && symtab_hdr->contents != (unsigned char *) isym)
+	{
+	  if (! info->keep_memory)
+	    free (isym);
+	  else
+	    symtab_hdr->contents = (unsigned char *) isym;
+	}
+    }
+
+  return ret;
+}
+
+/* The sweep phase of garbage collection.  Remove all garbage sections.  */
+
+typedef bfd_boolean (*gc_sweep_hook_fn)
+  PARAMS ((bfd *, struct bfd_link_info *, asection *,
+	   const Elf_Internal_Rela *));
+
+static bfd_boolean
+elf_gc_sweep (info, gc_sweep_hook)
+     struct bfd_link_info *info;
+     gc_sweep_hook_fn gc_sweep_hook;
+{
+  bfd *sub;
+
+  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+    {
+      asection *o;
+
+      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
+	continue;
+
+      for (o = sub->sections; o != NULL; o = o->next)
+	{
+	  /* Keep special sections.  Keep .debug sections.  */
+	  if ((o->flags & SEC_LINKER_CREATED)
+	      || (o->flags & SEC_DEBUGGING))
+	    o->gc_mark = 1;
+
+	  if (o->gc_mark)
+	    continue;
+
+	  /* Skip sweeping sections already excluded.  */
+	  if (o->flags & SEC_EXCLUDE)
+	    continue;
+
+	  /* Since this is early in the link process, it is simple
+	     to remove a section from the output.  */
+	  o->flags |= SEC_EXCLUDE;
+
+	  /* But we also have to update some of the relocation
+	     info we collected before.  */
+	  if (gc_sweep_hook
+	      && (o->flags & SEC_RELOC) && o->reloc_count > 0)
+	    {
+	      Elf_Internal_Rela *internal_relocs;
+	      bfd_boolean r;
+
+	      internal_relocs = (NAME(_bfd_elf,link_read_relocs)
+				 (o->owner, o, NULL, NULL, info->keep_memory));
+	      if (internal_relocs == NULL)
+		return FALSE;
+
+	      r = (*gc_sweep_hook) (o->owner, info, o, internal_relocs);
+
+	      if (elf_section_data (o)->relocs != internal_relocs)
+		free (internal_relocs);
+
+	      if (!r)
+		return FALSE;
+	    }
+	}
+    }
+
+  /* Remove the symbols that were in the swept sections from the dynamic
+     symbol table.  GCFIXME: Anyone know how to get them out of the
+     static symbol table as well?  */
+  {
+    int i = 0;
+
+    elf_link_hash_traverse (elf_hash_table (info),
+			    elf_gc_sweep_symbol,
+			    (PTR) &i);
+
+    elf_hash_table (info)->dynsymcount = i;
+  }
+
+  return TRUE;
+}
+
+/* Sweep symbols in swept sections.  Called via elf_link_hash_traverse.  */
+
+static bfd_boolean
+elf_gc_sweep_symbol (h, idxptr)
+     struct elf_link_hash_entry *h;
+     PTR idxptr;
+{
+  int *idx = (int *) idxptr;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if (h->dynindx != -1
+      && ((h->root.type != bfd_link_hash_defined
+	   && h->root.type != bfd_link_hash_defweak)
+	  || h->root.u.def.section->gc_mark))
+    h->dynindx = (*idx)++;
+
+  return TRUE;
+}
+
+/* Propogate collected vtable information.  This is called through
+   elf_link_hash_traverse.  */
+
+static bfd_boolean
+elf_gc_propagate_vtable_entries_used (h, okp)
+     struct elf_link_hash_entry *h;
+     PTR okp;
+{
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Those that are not vtables.  */
+  if (h->vtable_parent == NULL)
+    return TRUE;
+
+  /* Those vtables that do not have parents, we cannot merge.  */
+  if (h->vtable_parent == (struct elf_link_hash_entry *) -1)
+    return TRUE;
+
+  /* If we've already been done, exit.  */
+  if (h->vtable_entries_used && h->vtable_entries_used[-1])
+    return TRUE;
+
+  /* Make sure the parent's table is up to date.  */
+  elf_gc_propagate_vtable_entries_used (h->vtable_parent, okp);
+
+  if (h->vtable_entries_used == NULL)
+    {
+      /* None of this table's entries were referenced.  Re-use the
+	 parent's table.  */
+      h->vtable_entries_used = h->vtable_parent->vtable_entries_used;
+      h->vtable_entries_size = h->vtable_parent->vtable_entries_size;
+    }
+  else
+    {
+      size_t n;
+      bfd_boolean *cu, *pu;
+
+      /* Or the parent's entries into ours.  */
+      cu = h->vtable_entries_used;
+      cu[-1] = TRUE;
+      pu = h->vtable_parent->vtable_entries_used;
+      if (pu != NULL)
+	{
+	  asection *sec = h->root.u.def.section;
+	  struct elf_backend_data *bed = get_elf_backend_data (sec->owner);
+	  int file_align = bed->s->file_align;
+
+	  n = h->vtable_parent->vtable_entries_size / file_align;
+	  while (n--)
+	    {
+	      if (*pu)
+		*cu = TRUE;
+	      pu++;
+	      cu++;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf_gc_smash_unused_vtentry_relocs (h, okp)
+     struct elf_link_hash_entry *h;
+     PTR okp;
+{
+  asection *sec;
+  bfd_vma hstart, hend;
+  Elf_Internal_Rela *relstart, *relend, *rel;
+  struct elf_backend_data *bed;
+  int file_align;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Take care of both those symbols that do not describe vtables as
+     well as those that are not loaded.  */
+  if (h->vtable_parent == NULL)
+    return TRUE;
+
+  BFD_ASSERT (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak);
+
+  sec = h->root.u.def.section;
+  hstart = h->root.u.def.value;
+  hend = hstart + h->size;
+
+  relstart = (NAME(_bfd_elf,link_read_relocs)
+	      (sec->owner, sec, NULL, (Elf_Internal_Rela *) NULL, TRUE));
+  if (!relstart)
+    return *(bfd_boolean *) okp = FALSE;
+  bed = get_elf_backend_data (sec->owner);
+  file_align = bed->s->file_align;
+
+  relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;
+
+  for (rel = relstart; rel < relend; ++rel)
+    if (rel->r_offset >= hstart && rel->r_offset < hend)
+      {
+	/* If the entry is in use, do nothing.  */
+	if (h->vtable_entries_used
+	    && (rel->r_offset - hstart) < h->vtable_entries_size)
+	  {
+	    bfd_vma entry = (rel->r_offset - hstart) / file_align;
+	    if (h->vtable_entries_used[entry])
+	      continue;
+	  }
+	/* Otherwise, kill it.  */
+	rel->r_offset = rel->r_info = rel->r_addend = 0;
+      }
+
+  return TRUE;
+}
+
+/* Do mark and sweep of unused sections.  */
+
+bfd_boolean
+elf_gc_sections (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  bfd_boolean ok = TRUE;
+  bfd *sub;
+  asection * (*gc_mark_hook)
+    PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
+	     struct elf_link_hash_entry *h, Elf_Internal_Sym *));
+
+  if (!get_elf_backend_data (abfd)->can_gc_sections
+      || info->relocateable || info->emitrelocations
+      || elf_hash_table (info)->dynamic_sections_created)
+    return TRUE;
+
+  /* Apply transitive closure to the vtable entry usage info.  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_gc_propagate_vtable_entries_used,
+			  (PTR) &ok);
+  if (!ok)
+    return FALSE;
+
+  /* Kill the vtable relocations that were not used.  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_gc_smash_unused_vtentry_relocs,
+			  (PTR) &ok);
+  if (!ok)
+    return FALSE;
+
+  /* Grovel through relocs to find out who stays ...  */
+
+  gc_mark_hook = get_elf_backend_data (abfd)->gc_mark_hook;
+  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+    {
+      asection *o;
+
+      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
+	continue;
+
+      for (o = sub->sections; o != NULL; o = o->next)
+	{
+	  if (o->flags & SEC_KEEP)
+	    if (!elf_gc_mark (info, o, gc_mark_hook))
+	      return FALSE;
+	}
+    }
+
+  /* ... and mark SEC_EXCLUDE for those that go.  */
+  if (!elf_gc_sweep (info, get_elf_backend_data (abfd)->gc_sweep_hook))
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Called from check_relocs to record the existance of a VTINHERIT reloc.  */
+
+bfd_boolean
+elf_gc_record_vtinherit (abfd, sec, h, offset)
+     bfd *abfd;
+     asection *sec;
+     struct elf_link_hash_entry *h;
+     bfd_vma offset;
+{
+  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
+  struct elf_link_hash_entry **search, *child;
+  bfd_size_type extsymcount;
+
+  /* The sh_info field of the symtab header tells us where the
+     external symbols start.  We don't care about the local symbols at
+     this point.  */
+  extsymcount = elf_tdata (abfd)->symtab_hdr.sh_size/sizeof (Elf_External_Sym);
+  if (!elf_bad_symtab (abfd))
+    extsymcount -= elf_tdata (abfd)->symtab_hdr.sh_info;
+
+  sym_hashes = elf_sym_hashes (abfd);
+  sym_hashes_end = sym_hashes + extsymcount;
+
+  /* Hunt down the child symbol, which is in this section at the same
+     offset as the relocation.  */
+  for (search = sym_hashes; search != sym_hashes_end; ++search)
+    {
+      if ((child = *search) != NULL
+	  && (child->root.type == bfd_link_hash_defined
+	      || child->root.type == bfd_link_hash_defweak)
+	  && child->root.u.def.section == sec
+	  && child->root.u.def.value == offset)
+	goto win;
+    }
+
+  (*_bfd_error_handler) ("%s: %s+%lu: No symbol found for INHERIT",
+			 bfd_archive_filename (abfd), sec->name,
+			 (unsigned long) offset);
+  bfd_set_error (bfd_error_invalid_operation);
+  return FALSE;
+
+ win:
+  if (!h)
+    {
+      /* This *should* only be the absolute section.  It could potentially
+	 be that someone has defined a non-global vtable though, which
+	 would be bad.  It isn't worth paging in the local symbols to be
+	 sure though; that case should simply be handled by the assembler.  */
+
+      child->vtable_parent = (struct elf_link_hash_entry *) -1;
+    }
+  else
+    child->vtable_parent = h;
+
+  return TRUE;
+}
+
+/* Called from check_relocs to record the existance of a VTENTRY reloc.  */
+
+bfd_boolean
+elf_gc_record_vtentry (abfd, sec, h, addend)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     asection *sec ATTRIBUTE_UNUSED;
+     struct elf_link_hash_entry *h;
+     bfd_vma addend;
+{
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  int file_align = bed->s->file_align;
+
+  if (addend >= h->vtable_entries_size)
+    {
+      size_t size, bytes;
+      bfd_boolean *ptr = h->vtable_entries_used;
+
+      /* While the symbol is undefined, we have to be prepared to handle
+	 a zero size.  */
+      if (h->root.type == bfd_link_hash_undefined)
+	size = addend;
+      else
+	{
+	  size = h->size;
+	  if (size < addend)
+	    {
+	      /* Oops!  We've got a reference past the defined end of
+		 the table.  This is probably a bug -- shall we warn?  */
+	      size = addend;
+	    }
+	}
+
+      /* Allocate one extra entry for use as a "done" flag for the
+	 consolidation pass.  */
+      bytes = (size / file_align + 1) * sizeof (bfd_boolean);
+
+      if (ptr)
+	{
+	  ptr = bfd_realloc (ptr - 1, (bfd_size_type) bytes);
+
+	  if (ptr != NULL)
+	    {
+	      size_t oldbytes;
+
+	      oldbytes = ((h->vtable_entries_size / file_align + 1)
+			  * sizeof (bfd_boolean));
+	      memset (((char *) ptr) + oldbytes, 0, bytes - oldbytes);
+	    }
+	}
+      else
+	ptr = bfd_zmalloc ((bfd_size_type) bytes);
+
+      if (ptr == NULL)
+	return FALSE;
+
+      /* And arrange for that done flag to be at index -1.  */
+      h->vtable_entries_used = ptr + 1;
+      h->vtable_entries_size = size;
+    }
+
+  h->vtable_entries_used[addend / file_align] = TRUE;
+
+  return TRUE;
+}
+
+/* And an accompanying bit to work out final got entry offsets once
+   we're done.  Should be called from final_link.  */
+
+bfd_boolean
+elf_gc_common_finalize_got_offsets (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  bfd *i;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  bfd_vma gotoff;
+
+  /* The GOT offset is relative to the .got section, but the GOT header is
+     put into the .got.plt section, if the backend uses it.  */
+  if (bed->want_got_plt)
+    gotoff = 0;
+  else
+    gotoff = bed->got_header_size;
+
+  /* Do the local .got entries first.  */
+  for (i = info->input_bfds; i; i = i->link_next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_size_type j, locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+
+      if (bfd_get_flavour (i) != bfd_target_elf_flavour)
+	continue;
+
+      local_got = elf_local_got_refcounts (i);
+      if (!local_got)
+	continue;
+
+      symtab_hdr = &elf_tdata (i)->symtab_hdr;
+      if (elf_bad_symtab (i))
+	locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
+      else
+	locsymcount = symtab_hdr->sh_info;
+
+      for (j = 0; j < locsymcount; ++j)
+	{
+	  if (local_got[j] > 0)
+	    {
+	      local_got[j] = gotoff;
+	      gotoff += ARCH_SIZE / 8;
+	    }
+	  else
+	    local_got[j] = (bfd_vma) -1;
+	}
+    }
+
+  /* Then the global .got entries.  .plt refcounts are handled by
+     adjust_dynamic_symbol  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_gc_allocate_got_offsets,
+			  (PTR) &gotoff);
+  return TRUE;
+}
+
+/* We need a special top-level link routine to convert got reference counts
+   to real got offsets.  */
+
+static bfd_boolean
+elf_gc_allocate_got_offsets (h, offarg)
+     struct elf_link_hash_entry *h;
+     PTR offarg;
+{
+  bfd_vma *off = (bfd_vma *) offarg;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if (h->got.refcount > 0)
+    {
+      h->got.offset = off[0];
+      off[0] += ARCH_SIZE / 8;
+    }
+  else
+    h->got.offset = (bfd_vma) -1;
+
+  return TRUE;
+}
+
+/* Many folk need no more in the way of final link than this, once
+   got entry reference counting is enabled.  */
+
+bfd_boolean
+elf_gc_common_final_link (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  if (!elf_gc_common_finalize_got_offsets (abfd, info))
+    return FALSE;
+
+  /* Invoke the regular ELF backend linker to do all the work.  */
+  return elf_bfd_final_link (abfd, info);
+}
+
+/* This function will be called though elf_link_hash_traverse to store
+   all hash value of the exported symbols in an array.  */
+
+static bfd_boolean
+elf_collect_hash_codes (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  unsigned long **valuep = (unsigned long **) data;
+  const char *name;
+  char *p;
+  unsigned long ha;
+  char *alc = NULL;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Ignore indirect symbols.  These are added by the versioning code.  */
+  if (h->dynindx == -1)
+    return TRUE;
+
+  name = h->root.root.string;
+  p = strchr (name, ELF_VER_CHR);
+  if (p != NULL)
+    {
+      alc = bfd_malloc ((bfd_size_type) (p - name + 1));
+      memcpy (alc, name, (size_t) (p - name));
+      alc[p - name] = '\0';
+      name = alc;
+    }
+
+  /* Compute the hash value.  */
+  ha = bfd_elf_hash (name);
+
+  /* Store the found hash value in the array given as the argument.  */
+  *(*valuep)++ = ha;
+
+  /* And store it in the struct so that we can put it in the hash table
+     later.  */
+  h->elf_hash_value = ha;
+
+  if (alc != NULL)
+    free (alc);
+
+  return TRUE;
+}
+
+bfd_boolean
+elf_reloc_symbol_deleted_p (offset, cookie)
+     bfd_vma offset;
+     PTR cookie;
+{
+  struct elf_reloc_cookie *rcookie = (struct elf_reloc_cookie *) cookie;
+
+  if (rcookie->bad_symtab)
+    rcookie->rel = rcookie->rels;
+
+  for (; rcookie->rel < rcookie->relend; rcookie->rel++)
+    {
+      unsigned long r_symndx;
+
+      if (! rcookie->bad_symtab)
+	if (rcookie->rel->r_offset > offset)
+	  return FALSE;
+      if (rcookie->rel->r_offset != offset)
+	continue;
+
+      r_symndx = ELF_R_SYM (rcookie->rel->r_info);
+      if (r_symndx == SHN_UNDEF)
+	return TRUE;
+
+      if (r_symndx >= rcookie->locsymcount
+	  || ELF_ST_BIND (rcookie->locsyms[r_symndx].st_info) != STB_LOCAL)
+	{
+	  struct elf_link_hash_entry *h;
+
+	  h = rcookie->sym_hashes[r_symndx - rcookie->extsymoff];
+
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+	  if ((h->root.type == bfd_link_hash_defined
+	       || h->root.type == bfd_link_hash_defweak)
+	      && elf_discarded_section (h->root.u.def.section))
+	    return TRUE;
+	  else
+	    return FALSE;
+	}
+      else
+	{
+	  /* It's not a relocation against a global symbol,
+	     but it could be a relocation against a local
+	     symbol for a discarded section.  */
+	  asection *isec;
+	  Elf_Internal_Sym *isym;
+
+	  /* Need to: get the symbol; get the section.  */
+	  isym = &rcookie->locsyms[r_symndx];
+	  if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
+	    {
+	      isec = section_from_elf_index (rcookie->abfd, isym->st_shndx);
+	      if (isec != NULL && elf_discarded_section (isec))
+		return TRUE;
+	    }
+	}
+      return FALSE;
+    }
+  return FALSE;
+}
+
+/* Discard unneeded references to discarded sections.
+   Returns TRUE if any section's size was changed.  */
+/* This function assumes that the relocations are in sorted order,
+   which is true for all known assemblers.  */
+
+bfd_boolean
+elf_bfd_discard_info (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  struct elf_reloc_cookie cookie;
+  asection *stab, *eh;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_backend_data *bed;
+  bfd *abfd;
+  unsigned int count;
+  bfd_boolean ret = FALSE;
+
+  if (info->traditional_format
+      || info->hash->creator->flavour != bfd_target_elf_flavour
+      || ! is_elf_hash_table (info))
+    return FALSE;
+
+  for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
+    {
+      if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
+	continue;
+
+      bed = get_elf_backend_data (abfd);
+
+      if ((abfd->flags & DYNAMIC) != 0)
+	continue;
+
+      eh = bfd_get_section_by_name (abfd, ".eh_frame");
+      if (info->relocateable
+	  || (eh != NULL
+	      && (eh->_raw_size == 0
+		  || bfd_is_abs_section (eh->output_section))))
+	eh = NULL;
+
+      stab = bfd_get_section_by_name (abfd, ".stab");
+      if (stab != NULL
+	  && (stab->_raw_size == 0
+	      || bfd_is_abs_section (stab->output_section)
+	      || stab->sec_info_type != ELF_INFO_TYPE_STABS))
+	stab = NULL;
+
+      if (stab == NULL
+	  && eh == NULL
+	  && bed->elf_backend_discard_info == NULL)
+	continue;
+
+      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+      cookie.abfd = abfd;
+      cookie.sym_hashes = elf_sym_hashes (abfd);
+      cookie.bad_symtab = elf_bad_symtab (abfd);
+      if (cookie.bad_symtab)
+	{
+	  cookie.locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
+	  cookie.extsymoff = 0;
+	}
+      else
+	{
+	  cookie.locsymcount = symtab_hdr->sh_info;
+	  cookie.extsymoff = symtab_hdr->sh_info;
+	}
+
+      cookie.locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
+      if (cookie.locsyms == NULL && cookie.locsymcount != 0)
+	{
+	  cookie.locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
+						 cookie.locsymcount, 0,
+						 NULL, NULL, NULL);
+	  if (cookie.locsyms == NULL)
+	    return FALSE;
+	}
+
+      if (stab != NULL)
+	{
+	  cookie.rels = NULL;
+	  count = stab->reloc_count;
+	  if (count != 0)
+	    cookie.rels = (NAME(_bfd_elf,link_read_relocs)
+			   (abfd, stab, (PTR) NULL, (Elf_Internal_Rela *) NULL,
+			    info->keep_memory));
+	  if (cookie.rels != NULL)
+	    {
+	      cookie.rel = cookie.rels;
+	      cookie.relend = cookie.rels;
+	      cookie.relend += count * bed->s->int_rels_per_ext_rel;
+	      if (_bfd_discard_section_stabs (abfd, stab,
+					      elf_section_data (stab)->sec_info,
+					      elf_reloc_symbol_deleted_p,
+					      &cookie))
+		ret = TRUE;
+	      if (elf_section_data (stab)->relocs != cookie.rels)
+		free (cookie.rels);
+	    }
+	}
+
+      if (eh != NULL)
+	{
+	  cookie.rels = NULL;
+	  count = eh->reloc_count;
+	  if (count != 0)
+	    cookie.rels = (NAME(_bfd_elf,link_read_relocs)
+			   (abfd, eh, (PTR) NULL, (Elf_Internal_Rela *) NULL,
+			    info->keep_memory));
+	  cookie.rel = cookie.rels;
+	  cookie.relend = cookie.rels;
+	  if (cookie.rels != NULL)
+	    cookie.relend += count * bed->s->int_rels_per_ext_rel;
+
+	  if (_bfd_elf_discard_section_eh_frame (abfd, info, eh,
+						 elf_reloc_symbol_deleted_p,
+						 &cookie))
+	    ret = TRUE;
+
+	  if (cookie.rels != NULL
+	      && elf_section_data (eh)->relocs != cookie.rels)
+	    free (cookie.rels);
+	}
+
+      if (bed->elf_backend_discard_info != NULL
+	  && (*bed->elf_backend_discard_info) (abfd, &cookie, info))
+	ret = TRUE;
+
+      if (cookie.locsyms != NULL
+	  && symtab_hdr->contents != (unsigned char *) cookie.locsyms)
+	{
+	  if (! info->keep_memory)
+	    free (cookie.locsyms);
+	  else
+	    symtab_hdr->contents = (unsigned char *) cookie.locsyms;
+	}
+    }
+
+  if (info->eh_frame_hdr
+      && !info->relocateable
+      && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info))
+    ret = TRUE;
+
+  return ret;
+}
+
+static bfd_boolean
+elf_section_ignore_discarded_relocs (sec)
+     asection *sec;
+{
+  struct elf_backend_data *bed;
+
+  switch (sec->sec_info_type)
+    {
+    case ELF_INFO_TYPE_STABS:
+    case ELF_INFO_TYPE_EH_FRAME:
+      return TRUE;
+    default:
+      break;
+    }
+
+  bed = get_elf_backend_data (sec->owner);
+  if (bed->elf_backend_ignore_discarded_relocs != NULL
+      && (*bed->elf_backend_ignore_discarded_relocs) (sec))
+    return TRUE;
+
+  return FALSE;
+}
--- binutils-2.15.orig/bfd/elfxx-mips.c
+++ binutils-2.15/bfd/elfxx-mips.c
@@ -6960,11 +6960,16 @@
 		 decided not to make.  This is for the n64 irix rld,
 		 which doesn't seem to apply any relocations if there
 		 are trailing null entries.  */
-	      s = mips_elf_rel_dyn_section (dynobj, FALSE);
-	      dyn.d_un.d_val = (s->reloc_count
+	      if (SGI_COMPAT (output_bfd))
+		{
+		  s = mips_elf_rel_dyn_section (dynobj, FALSE);
+		  dyn.d_un.d_val = (s->reloc_count
 				* (ABI_64_P (output_bfd)
 				   ? sizeof (Elf64_Mips_External_Rel)
 				   : sizeof (Elf32_External_Rel)));
+		}
+	      else
+		swap_out_p = FALSE;
 	      break;
 
 	    default:
--- binutils-2.15.orig/bfd/libaout.h
+++ binutils-2.15/bfd/libaout.h
@@ -274,9 +274,14 @@
   M_ALPHA_NETBSD = 141,	/* NetBSD/alpha binary */
   M_ARM6_NETBSD = 143,	/* NetBSD/arm32 binary */
   M_SPARCLET_1 = 147,	/* 0x93, reserved */
+  M_POWERPC_NETBSD = 149, /* NetBSD/powerpc (big-endian) binary */
   M_VAX4K_NETBSD = 150,	/* NetBSD/vax 4K pages binary */
   M_MIPS1 = 151,        /* MIPS R2000/R3000 binary */
   M_MIPS2 = 152,        /* MIPS R4000/R6000 binary */
+  M_88K_OPENBSD = 153,	/* OpenBSD/m88k binary */
+  M_HPPA_OPENBSD = 154,	/* OpenBSD/hppa binary */
+  M_SPARC64_NETBSD = 156, /* NetBSD/sparc64 binary */
+  M_X86_64_NETBSD = 157, /* NetBSD/amd64 binary */
   M_SPARCLET_2 = 163,	/* 0xa3, reserved */
   M_SPARCLET_3 = 179,	/* 0xb3, reserved */
   M_SPARCLET_4 = 195,	/* 0xc3, reserved */
--- binutils-2.15.orig/bfd/m88kopenbsd.c
+++ binutils-2.15/bfd/m88kopenbsd.c
@@ -0,0 +1,33 @@
+/* BFD back-end for OpenBSD/m88k a.out binaries.
+   Copyright 2004 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#define	TARGET_IS_BIG_ENDIAN_P
+
+#define	TARGET_PAGE_SIZE	4096
+
+#define	DEFAULT_ARCH		bfd_arch_m88k
+#define	DEFAULT_MID		M_88K_OPENBSD
+
+/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
+   remove whitespace added here, and thus will fail to concatenate
+   the tokens.  */
+#define MY(OP) CONCAT2 (m88kopenbsd_,OP)
+#define TARGETNAME "a.out-m88k-openbsd"
+
+#include "netbsd.h"
--- binutils-2.15.orig/bfd/netbsd-core.c
+++ binutils-2.15/bfd/netbsd-core.c
@@ -30,13 +30,17 @@
 #include <signal.h>
 #include <sys/core.h>
 
-/*
- * FIXME: On NetBSD/sparc CORE_FPU_OFFSET should be (sizeof (struct trapframe))
- */
-
+/* The machine ID for OpenBSD/sparc64 and older versions of
+   NetBSD/sparc64 overlaps with M_MIPS1.  */
+#define M_SPARC64_OPENBSD	M_MIPS1
+ 
 /* Offset of StackGhost cookie within `struct md_coredump' on
    OpenBSD/sparc.  */
-#define CORE_WCOOKIE_OFFSET	344
+#define SPARC_WCOOKIE_OFFSET	344
+
+/* Offset of StackGhost cookie within `struct md_coredump' on
+   OpenBSD/sparc64.  */
+#define SPARC64_WCOOKIE_OFFSET	832
 
 struct netbsd_core_struct {
 	struct core core;
@@ -64,7 +68,7 @@
 {
   int i, val;
   file_ptr offset;
-  asection *asect, *asect2;
+  asection *asect;
   struct core core;
   struct coreseg coreseg;
   bfd_size_type amt = sizeof core;
@@ -143,44 +147,85 @@
       asect->filepos = offset;
       asect->alignment_power = 2;
 
-      if (CORE_GETMID (core) == M_SPARC_NETBSD
-	  && CORE_GETFLAG (coreseg) == CORE_CPU
-	  && coreseg.c_size > CORE_WCOOKIE_OFFSET)
+      if (CORE_GETFLAG (coreseg) == CORE_CPU)
 	{
-	  /* Truncate the .reg section.  */
-	  asect->_raw_size = CORE_WCOOKIE_OFFSET;
+	  bfd_size_type wcookie_offset;
 
-	  /* And create the .wcookie section.  */
-	  asect = bfd_make_section_anyway (abfd, ".wcookie");
-	  if (asect == NULL)
-	    goto punt;
-
-	  asect->flags = SEC_ALLOC + SEC_HAS_CONTENTS;
-	  asect->_raw_size = 4;
-	  asect->vma = 0;
-	  asect->filepos = offset + CORE_WCOOKIE_OFFSET;
-	  asect->alignment_power = 2;
+	  switch (CORE_GETMID (core))
+	    {
+	    case M_SPARC_NETBSD:
+	      wcookie_offset = SPARC_WCOOKIE_OFFSET;
+	      break;
+	    case M_SPARC64_OPENBSD:
+	      wcookie_offset = SPARC64_WCOOKIE_OFFSET;
+	      break;
+	    default:
+	      wcookie_offset = 0;
+	      break;
+	    }
+
+	  if (wcookie_offset > 0 && coreseg.c_size > wcookie_offset)
+	    {
+	      /* Truncate the .reg section.  */
+	      asect->_raw_size = wcookie_offset;
+
+	      /* And create the .wcookie section.  */
+	      asect = bfd_make_section_anyway (abfd, ".wcookie");
+	      if (asect == NULL)
+		goto punt;
+
+	      asect->flags = SEC_ALLOC + SEC_HAS_CONTENTS;
+	      asect->_raw_size = coreseg.c_size - wcookie_offset;
+	      asect->vma = 0;
+	      asect->filepos = offset + wcookie_offset;
+	      asect->alignment_power = 2;
+	    }
 	}
 
       offset += coreseg.c_size;
+    }
 
-#ifdef CORE_FPU_OFFSET
-      switch (CORE_GETFLAG (coreseg))
-	{
-	case CORE_CPU:
-	  /* Hackish...  */
-	  asect->_raw_size = CORE_FPU_OFFSET;
-	  asect2 = bfd_make_section_anyway (abfd, ".reg2");
-	  if (asect2 == NULL)
-	    goto punt;
-	  asect2->_raw_size = coreseg.c_size - CORE_FPU_OFFSET;
-	  asect2->vma = 0;
-	  asect2->filepos = asect->filepos + CORE_FPU_OFFSET;
-	  asect2->alignment_power = 2;
-	  asect2->flags = SEC_ALLOC + SEC_HAS_CONTENTS;
-	  break;
-	}
-#endif
+  /* Set architecture from machine ID.  */
+  switch (CORE_GETMID (core))
+    {
+    case M_X86_64_NETBSD:
+      bfd_default_set_arch_mach (abfd, bfd_arch_i386, bfd_mach_x86_64);
+      break;
+
+    case M_386_NETBSD:
+      bfd_default_set_arch_mach (abfd, bfd_arch_i386, bfd_mach_i386_i386);
+      break;
+
+    case M_68K_NETBSD:
+    case M_68K4K_NETBSD:
+      bfd_default_set_arch_mach (abfd, bfd_arch_m68k, 0);
+      break;
+
+    case M_88K_OPENBSD:
+      bfd_default_set_arch_mach (abfd, bfd_arch_m88k, 0);
+      break;
+
+    case M_HPPA_OPENBSD:
+      bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 0);
+      break;
+
+    case M_POWERPC_NETBSD:
+      bfd_default_set_arch_mach (abfd, bfd_arch_powerpc, bfd_mach_ppc);
+      break;
+
+    case M_SPARC_NETBSD:
+      bfd_default_set_arch_mach (abfd, bfd_arch_sparc, bfd_mach_sparc);
+      break;
+
+    case M_SPARC64_NETBSD:
+    case M_SPARC64_OPENBSD:
+      bfd_default_set_arch_mach (abfd, bfd_arch_sparc, bfd_mach_sparc_v9);
+      break;
+
+    case M_VAX_NETBSD:
+    case M_VAX4K_NETBSD:
+      bfd_default_set_arch_mach (abfd, bfd_arch_vax, 0);
+      break;
     }
 
   /* OK, we believe you.  You're a core file (sure, sure).  */
--- binutils-2.15.orig/bfd/po/SRC-POTFILES.in
+++ binutils-2.15/bfd/po/SRC-POTFILES.in
@@ -232,6 +232,7 @@
 m68klynx.c
 m68knetbsd.c
 m88kmach3.c
+m88kopenbsd.c
 mach-o.c
 mach-o.h
 merge.c
--- binutils-2.15.orig/bfd/targets.c
+++ binutils-2.15/bfd/targets.c
@@ -659,6 +659,7 @@
 extern const bfd_target m68ksysvcoff_vec;
 extern const bfd_target m88kbcs_vec;
 extern const bfd_target m88kmach3_vec;
+extern const bfd_target m88kopenbsd_vec;
 extern const bfd_target mach_o_be_vec;
 extern const bfd_target mach_o_le_vec;
 extern const bfd_target mach_o_fat_vec;
@@ -982,6 +983,7 @@
 	&m68ksysvcoff_vec,
 	&m88kbcs_vec,
 	&m88kmach3_vec,
+	&m88kopenbsd_vec,
 	&mach_o_be_vec,
 	&mach_o_le_vec,
 	&mach_o_fat_vec,
--- binutils-2.15.orig/binutils/Makefile.am
+++ binutils-2.15/binutils/Makefile.am
@@ -41,7 +41,7 @@
 
 # This is the demangler, as a standalone program.
 # Note: This one is used as the installed name too, unlike the above.
-DEMANGLER_PROG=cxxfilt
+#DEMANGLER_PROG=cxxfilt
 
 ADDR2LINE_PROG=addr2line
 
@@ -52,18 +52,19 @@
 
 SRCONV_PROG=srconv$(EXEEXT) sysdump$(EXEEXT) coffdump$(EXEEXT) 
 
-PROGS = $(SIZE_PROG) $(OBJDUMP_PROG) $(NM_PROG) $(AR_PROG) $(STRINGS_PROG) $(STRIP_PROG) $(RANLIB_PROG) $(DEMANGLER_PROG) $(OBJCOPY_PROG) @BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ $(ADDR2LINE_PROG) $(READELF_PROG) @BUILD_DLLWRAP@ @BUILD_MISC@
+PROGS = $(OBJDUMP_PROG) $(AR_PROG) $(STRINGS_PROG) $(STRIP_PROG) $(RANLIB_PROG) $(DEMANGLER_PROG) $(OBJCOPY_PROG) @BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ $(ADDR2LINE_PROG) $(READELF_PROG) @BUILD_DLLWRAP@ @BUILD_MISC@
 
-bin_PROGRAMS = $(SIZE_PROG) $(OBJDUMP_PROG) $(AR_PROG) $(STRINGS_PROG) $(RANLIB_PROG) $(OBJCOPY_PROG) @BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ $(ADDR2LINE_PROG) $(READELF_PROG) @BUILD_DLLWRAP@ @BUILD_MISC@
+bin_PROGRAMS = $(OBJDUMP_PROG) $(AR_PROG) $(STRINGS_PROG) $(RANLIB_PROG) $(OBJCOPY_PROG) @BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ $(ADDR2LINE_PROG) $(READELF_PROG) @BUILD_DLLWRAP@ @BUILD_MISC@
 
 ## We need a special rule to install the programs which are built with
 ## -new, and to rename cxxfilt to c++filt.
-noinst_PROGRAMS = $(NM_PROG) $(STRIP_PROG) $(DEMANGLER_PROG)
+#noinst_PROGRAMS = $(NM_PROG) $(STRIP_PROG) $(DEMANGLER_PROG)
+noinst_PROGRAMS = $(STRIP_PROG)
 
 EXTRA_PROGRAMS = $(NLMCONV_PROG) srconv sysdump coffdump $(DLLTOOL_PROG) $(WINDRES_PROG) $(DLLWRAP_PROG)
 
 # Stuff that goes in tooldir/ if appropriate.
-TOOL_PROGS = nm-new strip-new ar ranlib dlltool
+TOOL_PROGS = strip-new ar ranlib dlltool
 
 BASEDIR = $(srcdir)/..
 BFDDIR = $(BASEDIR)/bfd
@@ -111,7 +112,7 @@
 
 OPCODES = ../opcodes/libopcodes.la
 
-LIBIBERTY = ../libiberty/libiberty.a
+LIBIBERTY = -liberty
 
 POTFILES = $(CFILES) $(DEBUG_SRCS) $(HFILES)
 po/POTFILES.in: @MAINT@ Makefile
@@ -180,7 +181,7 @@
 objdump.o:objdump.c
 	$(COMPILE) -c $(OBJDUMP_DEFS) $(srcdir)/objdump.c
 
-cxxfilt_SOURCES = cxxfilt.c $(BULIBS)
+#cxxfilt_SOURCES = cxxfilt.c $(BULIBS)
 
 ar_SOURCES = arparse.y arlex.l ar.c not-ranlib.c arsup.c rename.c binemul.c \
 	emul_$(EMULATION).c $(BULIBS)
@@ -341,7 +342,7 @@
 install-exec-local: install-binPROGRAMS $(bin_PROGRAMS) $(noinst_PROGRAMS)
 	@list='$(noinst_PROGRAMS)'; for p in $$list; do \
 	  if test -f $$p; then \
-	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//' -e 's/cxxfilt/$(DEMANGLER_NAME)/'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
+	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//' -e 's/cxxfilt/$(DEMANGLER_NAME)/'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
 	    $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//' -e 's/cxxfilt/$(DEMANGLER_NAME)/'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
 	  else :; fi; \
 	done
--- binutils-2.15.orig/binutils/Makefile.in
+++ binutils-2.15/binutils/Makefile.in
@@ -77,7 +77,7 @@
 CXX = @CXX@
 CXXCPP = @CXXCPP@
 DATADIRNAME = @DATADIRNAME@
-DEMANGLER_NAME = @DEMANGLER_NAME@
+#DEMANGLER_NAME = @DEMANGLER_NAME@
 DLLTOOL = @DLLTOOL@
 DLLTOOL_DEFS = @DLLTOOL_DEFS@
 EMULATION = @EMULATION@
@@ -153,7 +153,7 @@
 
 # This is the demangler, as a standalone program.
 # Note: This one is used as the installed name too, unlike the above.
-DEMANGLER_PROG = cxxfilt
+#DEMANGLER_PROG = cxxfilt
 
 ADDR2LINE_PROG = addr2line
 
@@ -164,16 +164,17 @@
 
 SRCONV_PROG = srconv$(EXEEXT) sysdump$(EXEEXT) coffdump$(EXEEXT) 
 
-PROGS = $(SIZE_PROG) $(OBJDUMP_PROG) $(NM_PROG) $(AR_PROG) $(STRINGS_PROG) $(STRIP_PROG) $(RANLIB_PROG) $(DEMANGLER_PROG) $(OBJCOPY_PROG) @BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ $(ADDR2LINE_PROG) $(READELF_PROG) @BUILD_DLLWRAP@ @BUILD_MISC@
+PROGS = $(OBJDUMP_PROG) $(AR_PROG) $(STRINGS_PROG) $(STRIP_PROG) $(RANLIB_PROG) $(DEMANGLER_PROG) $(OBJCOPY_PROG) @BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ $(ADDR2LINE_PROG) $(READELF_PROG) @BUILD_DLLWRAP@ @BUILD_MISC@
 
-bin_PROGRAMS = $(SIZE_PROG) $(OBJDUMP_PROG) $(AR_PROG) $(STRINGS_PROG) $(RANLIB_PROG) $(OBJCOPY_PROG) @BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ $(ADDR2LINE_PROG) $(READELF_PROG) @BUILD_DLLWRAP@ @BUILD_MISC@
+bin_PROGRAMS = $(OBJDUMP_PROG) $(AR_PROG) $(STRINGS_PROG) $(RANLIB_PROG) $(OBJCOPY_PROG) @BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ $(ADDR2LINE_PROG) $(READELF_PROG) @BUILD_DLLWRAP@ @BUILD_MISC@
 
-noinst_PROGRAMS = $(NM_PROG) $(STRIP_PROG) $(DEMANGLER_PROG)
+#noinst_PROGRAMS = $(NM_PROG) $(STRIP_PROG) $(DEMANGLER_PROG)
+noinst_PROGRAMS = $(STRIP_PROG)
 
 EXTRA_PROGRAMS = $(NLMCONV_PROG) srconv sysdump coffdump $(DLLTOOL_PROG) $(WINDRES_PROG) $(DLLWRAP_PROG)
 
 # Stuff that goes in tooldir/ if appropriate.
-TOOL_PROGS = nm-new strip-new ar ranlib dlltool
+TOOL_PROGS = strip-new ar ranlib dlltool
 
 BASEDIR = $(srcdir)/..
 BFDDIR = $(BASEDIR)/bfd
@@ -225,7 +226,7 @@
 
 OPCODES = ../opcodes/libopcodes.la
 
-LIBIBERTY = ../libiberty/libiberty.a
+LIBIBERTY = -liberty
 
 POTFILES = $(CFILES) $(DEBUG_SRCS) $(HFILES)
 
@@ -272,7 +273,7 @@
 objdump_SOURCES = objdump.c budemang.c prdbg.c $(DEBUG_SRCS) $(BULIBS)
 objdump_LDADD = $(OPCODES) $(BFDLIB) $(LIBIBERTY) $(INTLLIBS)
 
-cxxfilt_SOURCES = cxxfilt.c $(BULIBS)
+#cxxfilt_SOURCES = cxxfilt.c $(BULIBS)
 
 ar_SOURCES = arparse.y arlex.l ar.c not-ranlib.c arsup.c rename.c binemul.c \
 	emul_$(EMULATION).c $(BULIBS)
@@ -322,11 +323,12 @@
 mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs
 CONFIG_HEADER = config.h
 CONFIG_CLEAN_FILES = 
-bin_PROGRAMS =  size$(EXEEXT) objdump$(EXEEXT) ar$(EXEEXT) \
+bin_PROGRAMS =  objdump$(EXEEXT) ar$(EXEEXT) \
 strings$(EXEEXT) ranlib$(EXEEXT) objcopy$(EXEEXT) @BUILD_NLMCONV@ \
 @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ addr2line$(EXEEXT) \
 readelf$(EXEEXT) @BUILD_DLLWRAP@ @BUILD_MISC@
-noinst_PROGRAMS =  nm-new$(EXEEXT) strip-new$(EXEEXT) cxxfilt$(EXEEXT)
+#noinst_PROGRAMS =  strip-new$(EXEEXT) cxxfilt$(EXEEXT)
+noinst_PROGRAMS =  strip-new$(EXEEXT)
 PROGRAMS =  $(bin_PROGRAMS) $(noinst_PROGRAMS)
 
 
@@ -337,96 +339,90 @@
 nlmconv_OBJECTS =  nlmconv.$(OBJEXT) nlmheader.$(OBJEXT) \
 bucomm.$(OBJEXT) version.$(OBJEXT) filemode.$(OBJEXT)
 nlmconv_LDADD = $(LDADD)
-nlmconv_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+nlmconv_DEPENDENCIES =  ../bfd/libbfd.la
 nlmconv_LDFLAGS = 
 srconv_OBJECTS =  srconv.$(OBJEXT) coffgrok.$(OBJEXT) bucomm.$(OBJEXT) \
 version.$(OBJEXT) filemode.$(OBJEXT)
 srconv_LDADD = $(LDADD)
-srconv_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+srconv_DEPENDENCIES =  ../bfd/libbfd.la
 srconv_LDFLAGS = 
 sysdump_OBJECTS =  sysdump.$(OBJEXT) bucomm.$(OBJEXT) version.$(OBJEXT) \
 filemode.$(OBJEXT)
 sysdump_LDADD = $(LDADD)
-sysdump_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+sysdump_DEPENDENCIES =  ../bfd/libbfd.la
 sysdump_LDFLAGS = 
 coffdump_OBJECTS =  coffdump.$(OBJEXT) coffgrok.$(OBJEXT) \
 bucomm.$(OBJEXT) version.$(OBJEXT) filemode.$(OBJEXT)
 coffdump_LDADD = $(LDADD)
-coffdump_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+coffdump_DEPENDENCIES =  ../bfd/libbfd.la
 coffdump_LDFLAGS = 
 dlltool_OBJECTS =  dlltool.$(OBJEXT) defparse.$(OBJEXT) deflex.$(OBJEXT) \
 bucomm.$(OBJEXT) version.$(OBJEXT) filemode.$(OBJEXT)
-dlltool_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+dlltool_DEPENDENCIES =  ../bfd/libbfd.la
 dlltool_LDFLAGS = 
 windres_OBJECTS =  windres.$(OBJEXT) resrc.$(OBJEXT) rescoff.$(OBJEXT) \
 resbin.$(OBJEXT) rcparse.$(OBJEXT) rclex.$(OBJEXT) winduni.$(OBJEXT) \
 resres.$(OBJEXT) bucomm.$(OBJEXT) version.$(OBJEXT) filemode.$(OBJEXT)
-windres_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+windres_DEPENDENCIES =  ../bfd/libbfd.la
 windres_LDFLAGS = 
 dllwrap_OBJECTS =  dllwrap.$(OBJEXT) version.$(OBJEXT)
-dllwrap_DEPENDENCIES =  ../libiberty/libiberty.a
+dllwrap_DEPENDENCIES = 
 dllwrap_LDFLAGS = 
 size_OBJECTS =  size.$(OBJEXT) bucomm.$(OBJEXT) version.$(OBJEXT) \
 filemode.$(OBJEXT)
 size_LDADD = $(LDADD)
-size_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+size_DEPENDENCIES =  ../bfd/libbfd.la
 size_LDFLAGS = 
 objdump_OBJECTS =  objdump.$(OBJEXT) budemang.$(OBJEXT) prdbg.$(OBJEXT) \
 rddbg.$(OBJEXT) debug.$(OBJEXT) stabs.$(OBJEXT) ieee.$(OBJEXT) \
 rdcoff.$(OBJEXT) bucomm.$(OBJEXT) version.$(OBJEXT) filemode.$(OBJEXT)
-objdump_DEPENDENCIES =  ../opcodes/libopcodes.la ../bfd/libbfd.la \
-../libiberty/libiberty.a
+objdump_DEPENDENCIES =  ../opcodes/libopcodes.la ../bfd/libbfd.la
 objdump_LDFLAGS = 
 ar_OBJECTS =  arparse.$(OBJEXT) arlex.$(OBJEXT) ar.$(OBJEXT) \
 not-ranlib.$(OBJEXT) arsup.$(OBJEXT) rename.$(OBJEXT) binemul.$(OBJEXT) \
 emul_$(EMULATION).$(OBJEXT) bucomm.$(OBJEXT) version.$(OBJEXT) \
 filemode.$(OBJEXT)
-ar_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+ar_DEPENDENCIES =  ../bfd/libbfd.la
 ar_LDFLAGS = 
 strings_OBJECTS =  strings.$(OBJEXT) bucomm.$(OBJEXT) version.$(OBJEXT) \
 filemode.$(OBJEXT)
 strings_LDADD = $(LDADD)
-strings_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+strings_DEPENDENCIES =  ../bfd/libbfd.la
 strings_LDFLAGS = 
 ranlib_OBJECTS =  ar.$(OBJEXT) is-ranlib.$(OBJEXT) arparse.$(OBJEXT) \
 arlex.$(OBJEXT) arsup.$(OBJEXT) rename.$(OBJEXT) binemul.$(OBJEXT) \
 emul_$(EMULATION).$(OBJEXT) bucomm.$(OBJEXT) version.$(OBJEXT) \
 filemode.$(OBJEXT)
-ranlib_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+ranlib_DEPENDENCIES =  ../bfd/libbfd.la
 ranlib_LDFLAGS = 
 objcopy_OBJECTS =  objcopy.$(OBJEXT) not-strip.$(OBJEXT) \
 rename.$(OBJEXT) rddbg.$(OBJEXT) debug.$(OBJEXT) stabs.$(OBJEXT) \
 ieee.$(OBJEXT) rdcoff.$(OBJEXT) wrstabs.$(OBJEXT) bucomm.$(OBJEXT) \
 version.$(OBJEXT) filemode.$(OBJEXT)
 objcopy_LDADD = $(LDADD)
-objcopy_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+objcopy_DEPENDENCIES =  ../bfd/libbfd.la
 objcopy_LDFLAGS = 
 addr2line_OBJECTS =  addr2line.$(OBJEXT) budemang.$(OBJEXT) \
 bucomm.$(OBJEXT) version.$(OBJEXT) filemode.$(OBJEXT)
 addr2line_LDADD = $(LDADD)
-addr2line_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+addr2line_DEPENDENCIES =  ../bfd/libbfd.la
 addr2line_LDFLAGS = 
 readelf_OBJECTS =  readelf.$(OBJEXT) version.$(OBJEXT) \
 unwind-ia64.$(OBJEXT)
-readelf_DEPENDENCIES =  ../libiberty/libiberty.a
+readelf_DEPENDENCIES = 
 readelf_LDFLAGS = 
 nm_new_OBJECTS =  nm.$(OBJEXT) budemang.$(OBJEXT) bucomm.$(OBJEXT) \
 version.$(OBJEXT) filemode.$(OBJEXT)
 nm_new_LDADD = $(LDADD)
-nm_new_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+nm_new_DEPENDENCIES =  ../bfd/libbfd.la
 nm_new_LDFLAGS = 
 strip_new_OBJECTS =  objcopy.$(OBJEXT) is-strip.$(OBJEXT) \
 rename.$(OBJEXT) rddbg.$(OBJEXT) debug.$(OBJEXT) stabs.$(OBJEXT) \
 ieee.$(OBJEXT) rdcoff.$(OBJEXT) wrstabs.$(OBJEXT) bucomm.$(OBJEXT) \
 version.$(OBJEXT) filemode.$(OBJEXT)
 strip_new_LDADD = $(LDADD)
-strip_new_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
+strip_new_DEPENDENCIES =  ../bfd/libbfd.la
 strip_new_LDFLAGS = 
-cxxfilt_OBJECTS =  cxxfilt.$(OBJEXT) bucomm.$(OBJEXT) version.$(OBJEXT) \
-filemode.$(OBJEXT)
-cxxfilt_LDADD = $(LDADD)
-cxxfilt_DEPENDENCIES =  ../bfd/libbfd.la ../libiberty/libiberty.a
-cxxfilt_LDFLAGS = 
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LEXLIB = @LEXLIB@
 YLWRAP = $(top_srcdir)/../ylwrap
@@ -444,8 +440,8 @@
 
 TAR = tar
 GZIP_ENV = --best
-SOURCES = $(nlmconv_SOURCES) $(srconv_SOURCES) $(sysdump_SOURCES) $(coffdump_SOURCES) $(dlltool_SOURCES) $(windres_SOURCES) $(dllwrap_SOURCES) $(size_SOURCES) $(objdump_SOURCES) $(ar_SOURCES) $(strings_SOURCES) $(ranlib_SOURCES) $(objcopy_SOURCES) $(addr2line_SOURCES) $(readelf_SOURCES) $(nm_new_SOURCES) $(strip_new_SOURCES) $(cxxfilt_SOURCES)
-OBJECTS = $(nlmconv_OBJECTS) $(srconv_OBJECTS) $(sysdump_OBJECTS) $(coffdump_OBJECTS) $(dlltool_OBJECTS) $(windres_OBJECTS) $(dllwrap_OBJECTS) $(size_OBJECTS) $(objdump_OBJECTS) $(ar_OBJECTS) $(strings_OBJECTS) $(ranlib_OBJECTS) $(objcopy_OBJECTS) $(addr2line_OBJECTS) $(readelf_OBJECTS) $(nm_new_OBJECTS) $(strip_new_OBJECTS) $(cxxfilt_OBJECTS)
+SOURCES = $(nlmconv_SOURCES) $(srconv_SOURCES) $(sysdump_SOURCES) $(coffdump_SOURCES) $(dlltool_SOURCES) $(windres_SOURCES) $(dllwrap_SOURCES) $(size_SOURCES) $(objdump_SOURCES) $(ar_SOURCES) $(strings_SOURCES) $(ranlib_SOURCES) $(objcopy_SOURCES) $(addr2line_SOURCES) $(readelf_SOURCES) $(nm_new_SOURCES) $(strip_new_SOURCES)
+OBJECTS = $(nlmconv_OBJECTS) $(srconv_OBJECTS) $(sysdump_OBJECTS) $(coffdump_OBJECTS) $(dlltool_OBJECTS) $(windres_OBJECTS) $(dllwrap_OBJECTS) $(size_OBJECTS) $(objdump_OBJECTS) $(ar_OBJECTS) $(strings_OBJECTS) $(ranlib_OBJECTS) $(objcopy_OBJECTS) $(addr2line_OBJECTS) $(readelf_OBJECTS) $(nm_new_OBJECTS) $(strip_new_OBJECTS)
 
 all: all-redirect
 .SUFFIXES:
@@ -639,9 +635,6 @@
 	@rm -f strip-new$(EXEEXT)
 	$(LINK) $(strip_new_LDFLAGS) $(strip_new_OBJECTS) $(strip_new_LDADD) $(LIBS)
 
-cxxfilt$(EXEEXT): $(cxxfilt_OBJECTS) $(cxxfilt_DEPENDENCIES)
-	@rm -f cxxfilt$(EXEEXT)
-	$(LINK) $(cxxfilt_LDFLAGS) $(cxxfilt_OBJECTS) $(cxxfilt_LDADD) $(LIBS)
 .l.c:
 	$(SHELL) $(YLWRAP) "$(LEX)" $< $(LEX_OUTPUT_ROOT).c $@ -- $(AM_LFLAGS) $(LFLAGS)
 .y.c:
@@ -689,6 +682,7 @@
 	rev=''; list='$(SUBDIRS)'; for subdir in $$list; do \
 	  rev="$$subdir $$rev"; \
 	  test "$$subdir" != "." || dot_seen=yes; \
+	  true; \
 	done; \
 	test "$$dot_seen" = "no" && rev=". $$rev"; \
 	target=`echo $@ | sed s/-recursive//`; \
@@ -1069,7 +1063,7 @@
 install-exec-local: install-binPROGRAMS $(bin_PROGRAMS) $(noinst_PROGRAMS)
 	@list='$(noinst_PROGRAMS)'; for p in $$list; do \
 	  if test -f $$p; then \
-	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//' -e 's/cxxfilt/$(DEMANGLER_NAME)/'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
+	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//' -e 's/cxxfilt/$(DEMANGLER_NAME)/'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
 	    $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//' -e 's/cxxfilt/$(DEMANGLER_NAME)/'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
 	  else :; fi; \
 	done
--- binutils-2.15.orig/binutils/ar.c
+++ binutils-2.15/binutils/ar.c
@@ -1068,7 +1068,7 @@
 
   old_name = xmalloc (strlen (bfd_get_filename (iarch)) + 1);
   strcpy (old_name, bfd_get_filename (iarch));
-  new_name = make_tempname (old_name);
+  new_name = make_tempname (old_name, 0);
 
   output_filename = new_name;
 
--- binutils-2.15.orig/binutils/bucomm.c
+++ binutils-2.15/binutils/bucomm.c
@@ -388,11 +388,12 @@
 /* Return the name of a temporary file in the same directory as FILENAME.  */
 
 char *
-make_tempname (char *filename)
+make_tempname (char *filename, int isdir)
 {
   static char template[] = "stXXXXXX";
   char *tmpname;
   char *slash = strrchr (filename, '/');
+  char c;
 
 #ifdef HAVE_DOS_BASED_FILE_SYSTEM
   {
@@ -407,8 +408,6 @@
 
   if (slash != (char *) NULL)
     {
-      char c;
-
       c = *slash;
       *slash = 0;
       tmpname = xmalloc (strlen (filename) + sizeof (template) + 2);
@@ -422,15 +421,31 @@
 #endif
       strcat (tmpname, "/");
       strcat (tmpname, template);
-      mktemp (tmpname);
-      *slash = c;
     }
   else
     {
       tmpname = xmalloc (sizeof (template));
       strcpy (tmpname, template);
-      mktemp (tmpname);
     }
+
+  if (isdir)
+    {
+      if (mkdtemp (tmpname) == (char *) NULL)
+      tmpname = NULL;
+    }
+  else
+    {
+      int fd;
+
+      fd = mkstemp (tmpname);
+      if (fd == -1)
+      tmpname = NULL;
+      else
+      close (fd);
+    }
+  if (slash != (char *) NULL)
+    *slash = c;
+
   return tmpname;
 }
 
--- binutils-2.15.orig/binutils/bucomm.h
+++ binutils-2.15/binutils/bucomm.h
@@ -170,7 +170,7 @@
 
 void print_arelt_descr (FILE *, bfd *, bfd_boolean);
 
-char *make_tempname (char *);
+char *make_tempname (char *, int);
 
 bfd_vma parse_vma (const char *, const char *);
 
--- binutils-2.15.orig/binutils/dlltool.c
+++ binutils-2.15/binutils/dlltool.c
@@ -1128,7 +1128,11 @@
   int i;
   const char **argv;
   char *errmsg_fmt, *errmsg_arg;
+#if defined(__MSDOS__) && !defined(__GO32__)
   char *temp_base = choose_temp_base ();
+#else
+  char *temp_base = NULL;
+#endif
 
   inform ("run: %s %s", what, args);
 
--- binutils-2.15.orig/binutils/dllwrap.c
+++ binutils-2.15/binutils/dllwrap.c
@@ -357,7 +357,11 @@
   int i;
   const char **argv;
   char *errmsg_fmt, *errmsg_arg;
+#if defined(__MSDOS__) && !defined(__GO32__)
   char *temp_base = choose_temp_base ();
+#else
+  char *temp_base = NULL;
+#endif
   int in_quote;
   char sep;
 
@@ -805,12 +809,9 @@
 
   if (! def_file_seen)
     {
-      char *fileprefix = choose_temp_base ();
-      def_file_name = (char *) xmalloc (strlen (fileprefix) + 5);
-      sprintf (def_file_name, "%s.def",
-	       (dontdeltemps) ? mybasename (fileprefix) : fileprefix);
-      delete_def_file = 1;
-      free (fileprefix);
+      def_file_name = make_temp_file (".def");
+      if (dontdeltemps)
+       def_file_name = mybasename (def_file_name);
       delete_def_file = 1;
       warn (_("no export definition file provided.\n\
 Creating one, but that may not be what you want"));
@@ -993,12 +994,10 @@
 
   if (! base_file_name)
     {
-      char *fileprefix = choose_temp_base ();
-      base_file_name = (char *) xmalloc (strlen (fileprefix) + 6);
-      sprintf (base_file_name, "%s.base",
-	       (dontdeltemps) ? mybasename (fileprefix) : fileprefix);
+      base_file_name = make_temp_file (".base");
+      if (dontdeltemps)
+       base_file_name = mybasename (base_file_name);
       delete_base_file = 1;
-      free (fileprefix);
     }
 
   {
--- binutils-2.15.orig/binutils/objcopy.c
+++ binutils-2.15/binutils/objcopy.c
@@ -1509,13 +1509,6 @@
   return TRUE;
 }
 
-#undef MKDIR
-#if defined (_WIN32) && !defined (__CYGWIN32__)
-#define MKDIR(DIR, MODE) mkdir (DIR)
-#else
-#define MKDIR(DIR, MODE) mkdir (DIR, MODE)
-#endif
-
 /* Read each archive element in turn from IBFD, copy the
    contents to temp file, and keep the temp file handle.  */
 
@@ -1530,12 +1523,12 @@
     } *list, *l;
   bfd **ptr = &obfd->archive_head;
   bfd *this_element;
-  char *dir = make_tempname (bfd_get_filename (obfd));
+  char *dir = make_tempname (bfd_get_filename (obfd), 1);
 
   /* Make a temp directory to hold the contents.  */
-  if (MKDIR (dir, 0700) != 0)
-    fatal (_("cannot mkdir %s for archive copying (error: %s)"),
-	   dir, strerror (errno));
+  if (dir == (char *) NULL)
+    fatal (_("cannot make temp directory for archive copying (error: %s)"),
+	  strerror (errno));
 
   obfd->has_armap = ibfd->has_armap;
 
@@ -1562,10 +1555,10 @@
       /* If the file already exists, make another temp dir.  */
       if (stat (output_name, &buf) >= 0)
 	{
-	  output_name = make_tempname (output_name);
-	  if (MKDIR (output_name, 0700) != 0)
-	    fatal (_("cannot mkdir %s for archive copying (error: %s)"),
-		   output_name, strerror (errno));
+         output_name = make_tempname (output_name, 1);
+         if (output_name == (char *) NULL)
+             fatal (_("cannot make temp directory for archive copying (error: %s)"),
+                    strerror (errno));
 
 	  l = xmalloc (sizeof (struct name_list));
 	  l->name = output_name;
@@ -2384,7 +2377,7 @@
       if (output_file != NULL)
 	tmpname = output_file;
       else
-	tmpname = make_tempname (argv[i]);
+	tmpname = make_tempname (argv[i], 0);
       status = 0;
 
       copy_file (argv[i], tmpname, input_target, output_target);
@@ -2957,7 +2950,7 @@
      are the same, then create a temp and rename the result into the input.  */
   if (output_filename == NULL || strcmp (input_filename, output_filename) == 0)
     {
-      char *tmpname = make_tempname (input_filename);
+      char *tmpname = make_tempname (input_filename, 0);
 
       copy_file (input_filename, tmpname, input_target, output_target);
       if (status == 0)
--- binutils-2.15.orig/binutils/resrc.c
+++ binutils-2.15/binutils/resrc.c
@@ -182,7 +182,11 @@
   int i;
   const char **argv;
   char *errmsg_fmt, *errmsg_arg;
+#if defined(__MSDOS__) && !defined(__GO32__)
   char *temp_base = choose_temp_base ();
+#else
+  char *temp_base = NULL;
+#endif
   int in_quote;
   char sep;
   int redir_handle = -1;
@@ -293,12 +297,7 @@
 {
   if (istream_type == ISTREAM_FILE)
     {
-      char *fileprefix;
-
-      fileprefix = choose_temp_base ();
-      cpp_temp_file = (char *) xmalloc (strlen (fileprefix) + 5);
-      sprintf (cpp_temp_file, "%s.irc", fileprefix);
-      free (fileprefix);
+      cpp_temp_file = make_temp_file (".irc");
 
       if (run_cmd (cmd, cpp_temp_file))
 	fatal (_("can't execute `%s': %s"), cmd, strerror (errno));
--- binutils-2.15.orig/binutils/stabs.c
+++ binutils-2.15/binutils/stabs.c
@@ -2819,7 +2819,6 @@
   bfd_boolean is_full_physname_constructor;
   bfd_boolean is_constructor;
   bfd_boolean is_destructor;
-  bfd_boolean is_v3;
   debug_type *args;
   bfd_boolean varargs;
   unsigned int physname_len = 0;
@@ -2839,9 +2838,8 @@
 		    && (argtypes[1] == '$' || argtypes[1] == '.')
 		    && argtypes[2] == '_')
 		   || strncmp (argtypes, "__dt", 4) == 0);
-  is_v3 = argtypes[0] == '_' && argtypes[1] == 'Z';
 
-  if (is_destructor || is_full_physname_constructor || is_v3)
+  if (is_destructor || is_full_physname_constructor)
     *pphysname = argtypes;
   else
     {
@@ -3704,10 +3702,6 @@
 {
   struct stab_demangle_info minfo;
 
-  /* Check for the g++ V3 ABI.  */
-  if (physname[0] == '_' && physname[1] == 'Z')
-    return stab_demangle_v3_argtypes (dhandle, info, physname, pvarargs);
-
   minfo.dhandle = dhandle;
   minfo.info = info;
   minfo.args = NULL;
@@ -5056,294 +5050,3 @@
 
   return TRUE;
 }
-
-/* Demangle names encoded using the g++ V3 ABI.  The newer versions of
-   g++ which use this ABI do not encode ordinary method argument types
-   in a mangled name; they simply output the argument types.  However,
-   for a static method, g++ simply outputs the return type and the
-   physical name.  So in that case we need to demangle the name here.
-   Here PHYSNAME is the physical name of the function, and we set the
-   variable pointed at by PVARARGS to indicate whether this function
-   is varargs.  This returns NULL, or a NULL terminated array of
-   argument types.  */
-
-static debug_type *
-stab_demangle_v3_argtypes (void *dhandle, struct stab_handle *info,
-			   const char *physname, bfd_boolean *pvarargs)
-{
-  struct demangle_component *dc;
-  void *mem;
-  unsigned int alloc, count;
-  debug_type *pargs;
-
-  dc = cplus_demangle_v3_components (physname, DMGL_PARAMS | DMGL_ANSI, &mem);
-  if (dc == NULL)
-    {
-      stab_bad_demangle (physname);
-      return NULL;
-    }
-
-  /* We expect to see TYPED_NAME, and the right subtree describes the
-     function type.  */
-  if (dc->type != DEMANGLE_COMPONENT_TYPED_NAME
-      || dc->u.s_binary.right->type != DEMANGLE_COMPONENT_FUNCTION_TYPE)
-    {
-      fprintf (stderr, _("Demangled name is not a function\n"));
-      free (mem);
-      return NULL;
-    }
-
-  alloc = 10;
-  pargs = (debug_type *) xmalloc (alloc * sizeof *pargs);
-  *pvarargs = FALSE;
-
-  count = 0;
-
-  for (dc = dc->u.s_binary.right->u.s_binary.right;
-       dc != NULL;
-       dc = dc->u.s_binary.right)
-    {
-      debug_type arg;
-      bfd_boolean varargs;
-
-      if (dc->type != DEMANGLE_COMPONENT_ARGLIST)
-	{
-	  fprintf (stderr, _("Unexpected type in demangle tree\n"));
-	  free (mem);
-	  return NULL;
-	}
-
-      arg = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left,
-				  NULL, &varargs);
-      if (arg == NULL)
-	{
-	  if (varargs)
-	    {
-	      *pvarargs = TRUE;
-	      continue;
-	    }
-	  free (mem);
-	  return NULL;
-	}
-
-      if (count + 1 >= alloc)
-	{
-	  alloc += 10;
-	  pargs = (debug_type *) xrealloc (pargs, alloc * sizeof *pargs);
-	}
-
-      pargs[count] = arg;
-      ++count;
-    }
-
-  pargs[count] = DEBUG_TYPE_NULL;
-
-  free (mem);
-
-  return pargs;
-}
-
-/* Convert a struct demangle_component tree describing an argument
-   type into a debug_type.  */
-
-static debug_type
-stab_demangle_v3_arg (void *dhandle, struct stab_handle *info,
-		      struct demangle_component *dc, debug_type context,
-		      bfd_boolean *pvarargs)
-{
-  debug_type dt;
-
-  if (pvarargs != NULL)
-    *pvarargs = FALSE;
-
-  switch (dc->type)
-    {
-      /* FIXME: These are demangle component types which we probably
-	 need to handle one way or another.  */
-    case DEMANGLE_COMPONENT_LOCAL_NAME:
-    case DEMANGLE_COMPONENT_TYPED_NAME:
-    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
-    case DEMANGLE_COMPONENT_CTOR:
-    case DEMANGLE_COMPONENT_DTOR:
-    case DEMANGLE_COMPONENT_JAVA_CLASS:
-    case DEMANGLE_COMPONENT_RESTRICT_THIS:
-    case DEMANGLE_COMPONENT_VOLATILE_THIS:
-    case DEMANGLE_COMPONENT_CONST_THIS:
-    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
-    case DEMANGLE_COMPONENT_COMPLEX:
-    case DEMANGLE_COMPONENT_IMAGINARY:
-    case DEMANGLE_COMPONENT_VENDOR_TYPE:
-    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
-    case DEMANGLE_COMPONENT_ARRAY_TYPE:
-    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
-    case DEMANGLE_COMPONENT_ARGLIST:
-    default:
-      fprintf (stderr, _("Unrecognized demangle component\n"));
-      return NULL;
-
-    case DEMANGLE_COMPONENT_NAME:
-      if (context != NULL)
-	{
-	  const debug_field *fields;
-
-	  fields = debug_get_fields (dhandle, context);
-	  if (fields != NULL)
-	    {
-	      /* Try to find this type by looking through the context
-		 class.  */
-	      for (; *fields != DEBUG_FIELD_NULL; fields++)
-		{
-		  debug_type ft;
-		  const char *dn;
-
-		  ft = debug_get_field_type (dhandle, *fields);
-		  if (ft == NULL)
-		    return NULL;
-		  dn = debug_get_type_name (dhandle, ft);
-		  if (dn != NULL
-		      && (int) strlen (dn) == dc->u.s_name.len
-		      && strncmp (dn, dc->u.s_name.s, dc->u.s_name.len) == 0)
-		    return ft;
-		}
-	    }
-	}
-      return stab_find_tagged_type (dhandle, info, dc->u.s_name.s,
-				    dc->u.s_name.len, DEBUG_KIND_ILLEGAL);
-
-    case DEMANGLE_COMPONENT_QUAL_NAME:
-      context = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left,
-				      context, NULL);
-      if (context == NULL)
-	return NULL;
-      return stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.right,
-				   context, NULL);
-
-    case DEMANGLE_COMPONENT_TEMPLATE:
-      {
-	char *p;
-	size_t alc;
-
-	/* We print this component to get a class name which we can
-	   use.  FIXME: This probably won't work if the template uses
-	   template parameters which refer to an outer template.  */
-	p = cplus_demangle_print (DMGL_PARAMS | DMGL_ANSI, dc, 20, &alc);
-	if (p == NULL)
-	  {
-	    fprintf (stderr, _("Failed to print demangled template\n"));
-	    return NULL;
-	  }
-	dt = stab_find_tagged_type (dhandle, info, p, strlen (p),
-				    DEBUG_KIND_CLASS);
-	free (p);
-	return dt;
-      }
-
-    case DEMANGLE_COMPONENT_SUB_STD:
-      return stab_find_tagged_type (dhandle, info, dc->u.s_string.string,
-				    dc->u.s_string.len, DEBUG_KIND_ILLEGAL);
-
-    case DEMANGLE_COMPONENT_RESTRICT:
-    case DEMANGLE_COMPONENT_VOLATILE:
-    case DEMANGLE_COMPONENT_CONST:
-    case DEMANGLE_COMPONENT_POINTER:
-    case DEMANGLE_COMPONENT_REFERENCE:
-      dt = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left, NULL,
-				 NULL);
-      if (dt == NULL)
-	return NULL;
-
-      switch (dc->type)
-	{
-	default:
-	  abort ();
-	case DEMANGLE_COMPONENT_RESTRICT:
-	  /* FIXME: We have no way to represent restrict.  */
-	  return dt;
-	case DEMANGLE_COMPONENT_VOLATILE:
-	  return debug_make_volatile_type (dhandle, dt);
-	case DEMANGLE_COMPONENT_CONST:
-	  return debug_make_const_type (dhandle, dt);
-	case DEMANGLE_COMPONENT_POINTER:
-	  return debug_make_pointer_type (dhandle, dt);
-	case DEMANGLE_COMPONENT_REFERENCE:
-	  return debug_make_reference_type (dhandle, dt);
-	}
-
-    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
-      {
-	char *p;
-	size_t alc;
-	debug_type ret;
-
-	/* We print this component in order to find out the type name.
-	   FIXME: Should we instead expose the
-	   demangle_builtin_type_info structure?  */
-	p = cplus_demangle_print (DMGL_PARAMS | DMGL_ANSI, dc, 20, &alc);
-	if (p == NULL)
-	  {
-	    fprintf (stderr, _("Couldn't get demangled builtin type\n"));
-	    return NULL;
-	  }
-
-	/* The mangling is based on the type, but does not itself
-	   indicate what the sizes are.  So we have to guess.  */
-	if (strcmp (p, "signed char") == 0)
-	  ret = debug_make_int_type (dhandle, 1, FALSE);
-	else if (strcmp (p, "bool") == 0)
-	  ret = debug_make_bool_type (dhandle, 1);
-	else if (strcmp (p, "char") == 0)
-	  ret = debug_make_int_type (dhandle, 1, FALSE);
-	else if (strcmp (p, "double") == 0)
-	  ret = debug_make_float_type (dhandle, 8);
-	else if (strcmp (p, "long double") == 0)
-	  ret = debug_make_float_type (dhandle, 8);
-	else if (strcmp (p, "float") == 0)
-	  ret = debug_make_float_type (dhandle, 4);
-	else if (strcmp (p, "__float128") == 0)
-	  ret = debug_make_float_type (dhandle, 16);
-	else if (strcmp (p, "unsigned char") == 0)
-	  ret = debug_make_int_type (dhandle, 1, TRUE);
-	else if (strcmp (p, "int") == 0)
-	  ret = debug_make_int_type (dhandle, 4, FALSE);
-	else if (strcmp (p, "unsigned int") == 0)
-	  ret = debug_make_int_type (dhandle, 4, TRUE);
-	else if (strcmp (p, "long") == 0)
-	  ret = debug_make_int_type (dhandle, 4, FALSE);
-	else if (strcmp (p, "unsigned long") == 0)
-	  ret = debug_make_int_type (dhandle, 4, TRUE);
-	else if (strcmp (p, "__int128") == 0)
-	  ret = debug_make_int_type (dhandle, 16, FALSE);
-	else if (strcmp (p, "unsigned __int128") == 0)
-	  ret = debug_make_int_type (dhandle, 16, TRUE);
-	else if (strcmp (p, "short") == 0)
-	  ret = debug_make_int_type (dhandle, 2, FALSE);
-	else if (strcmp (p, "unsigned short") == 0)
-	  ret = debug_make_int_type (dhandle, 2, TRUE);
-	else if (strcmp (p, "void") == 0)
-	  ret = debug_make_void_type (dhandle);
-	else if (strcmp (p, "wchar_t") == 0)
-	  ret = debug_make_int_type (dhandle, 4, TRUE);
-	else if (strcmp (p, "long long") == 0)
-	  ret = debug_make_int_type (dhandle, 8, FALSE);
-	else if (strcmp (p, "unsigned long long") == 0)
-	  ret = debug_make_int_type (dhandle, 8, TRUE);
-	else if (strcmp (p, "...") == 0)
-	  {
-	    if (pvarargs == NULL)
-	      fprintf (stderr, _("Unexpected demangled varargs\n"));
-	    else
-	      *pvarargs = TRUE;
-	    ret = NULL;
-	  }
-	else
-	  {
-	    fprintf (stderr, _("Unrecognized demangled builtin type\n"));
-	    ret = NULL;
-	  }
-
-	free (p);
-
-	return ret;
-      }
-    }
-}
--- binutils-2.15.orig/config.guess
+++ binutils-2.15/config.guess
@@ -197,53 +197,9 @@
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
 	exit 0 ;;
-    amd64:OpenBSD:*:*)
-	echo x86_64-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    amiga:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    arc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    cats:OpenBSD:*:*)
-	echo arm-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    hp300:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    macppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme88k:OpenBSD:*:*)
-	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvmeppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    pegasos:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    pmax:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sgi:OpenBSD:*:*)
-	echo mipseb-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sun3:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    wgrisc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
     *:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
     *:ekkoBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
--- binutils-2.15.orig/configure
+++ binutils-2.15/configure
@@ -887,8 +887,7 @@
 # these libraries are built for the target environment, and are built after
 # the host libraries and the host tools (which may be a cross compiler)
 #
-target_libraries="target-libiberty \
-		target-libgloss \
+target_libraries="target-libgloss \
 		target-newlib \
 		target-libstdc++-v3 \
 		target-libf2c \
@@ -1099,6 +1098,13 @@
 esac
 
 case "${target}" in
+  *-*-openbsd.*)
+    noconfigdirs="$noconfigdirs target-libiberty"
+    noconfigdirs="$noconfigdirs gdb"
+   ;;
+esac
+
+case "${target}" in
   *-*-chorusos)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss ${libgcj}"
     ;;
@@ -1422,6 +1428,9 @@
   mips*-dec-bsd*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  mips*-*-openbsd*)
+    noconfigdirs="$noconfigdirs target-libgloss ${libgcj}"
+    ;;
   mips*-*-bsd*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
@@ -1480,6 +1489,9 @@
   v850ea-*-*)
     noconfigdirs="$noconfigdirs target-libgloss ${libgcj}"
     ;;
+  vax-*-openbsd*)
+    noconfigdirs="$noconfigdirs ld gas gprof ${libgcj}"
+    ;;
   vax-*-vms)
     noconfigdirs="$noconfigdirs bfd binutils gdb ld target-newlib opcodes target-libgloss ${libgcj}"
     ;;
@@ -2535,6 +2547,8 @@
   olditem=${item}
 done
 serialization_dependencies=serdep.tmp
+# override on OpenBSD
+serialization_dependencies=/dev/null
 
 
 # Base args.  Strip norecursion, cache-file, srcdir, host, build,
--- binutils-2.15.orig/configure.in
+++ binutils-2.15/configure.in
@@ -145,8 +145,7 @@
 # these libraries are built for the target environment, and are built after
 # the host libraries and the host tools (which may be a cross compiler)
 #
-target_libraries="target-libiberty \
-		target-libgloss \
+target_libraries="target-libgloss \
 		target-newlib \
 		target-libstdc++-v3 \
 		target-libf2c \
@@ -332,6 +331,13 @@
 esac
 
 case "${target}" in
+  *-*-openbsd.*)
+    noconfigdirs="$noconfigdirs target-libiberty"
+    noconfigdirs="$noconfigdirs gdb"
+   ;;
+esac
+
+case "${target}" in
   *-*-chorusos)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss ${libgcj}"
     ;;
@@ -655,6 +661,9 @@
   mips*-dec-bsd*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
+  mips*-*-openbsd*)
+    noconfigdirs="$noconfigdirs target-libgloss ${libgcj}"
+    ;;
   mips*-*-bsd*)
     noconfigdirs="$noconfigdirs gprof target-libgloss ${libgcj}"
     ;;
@@ -713,6 +722,9 @@
   v850ea-*-*)
     noconfigdirs="$noconfigdirs target-libgloss ${libgcj}"
     ;;
+  vax-*-openbsd*)
+    noconfigdirs="$noconfigdirs ld gas gprof ${libgcj}"
+    ;;
   vax-*-vms)
     noconfigdirs="$noconfigdirs bfd binutils gdb ld target-newlib opcodes target-libgloss ${libgcj}"
     ;;
@@ -1767,6 +1779,8 @@
   olditem=${item}
 done
 serialization_dependencies=serdep.tmp
+# override on OpenBSD
+serialization_dependencies=/dev/null
 AC_SUBST_FILE(serialization_dependencies)
 
 # Base args.  Strip norecursion, cache-file, srcdir, host, build,
--- binutils-2.15.orig/gas/Makefile.am
+++ binutils-2.15/gas/Makefile.am
@@ -391,6 +391,7 @@
 	config/te-macos.h \
 	config/te-nbsd.h \
 	config/te-nbsd532.h \
+	config/te-obsd.h \
 	config/te-pc532mach.h \
 	config/te-pe.h \
 	config/te-ppcnw.h \
@@ -501,7 +502,8 @@
 # How to link with both our special library facilities
 # and the system's installed libraries.
 
-GASLIBS = @OPCODES_LIB@ @BFDLIB@ ../libiberty/libiberty.a
+GASLIBS = @OPCODES_LIB@ @BFDLIB@ -liberty
+GASLIBSDEP = @OPCODES_LIB@ @BFDLIB@
 
 # Files to be copied away after each stage in building.
 STAGESTUFF = *.o $(noinst_PROGRAMS)
@@ -514,7 +516,7 @@
 as_new_LDADD = $(TARG_CPU_O) $(OBJ_FORMAT_O) $(ATOF_TARG_O) \
 	$(extra_objects) $(GASLIBS) $(INTLLIBS) $(LIBM)
 as_new_DEPENDENCIES = $(TARG_CPU_O) $(OBJ_FORMAT_O) $(ATOF_TARG_O) \
-	$(extra_objects) $(GASLIBS) $(INTLDEPS)
+	$(extra_objects) $(GASLIBSDEP) $(INTLDEPS)
 
 # Stuff that every object file depends upon.  If anything is removed
 # from this list, remove it from dep-in.sed as well.
@@ -695,7 +697,7 @@
 	$(mkinstalldirs) $(DESTDIR)$(bindir)
 	@list='$(noinst_PROGRAMS)'; for p in $$list; do \
 	  if test -f $$p; then \
-	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
+	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
 	    $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
 	  else :; fi; \
 	done
--- binutils-2.15.orig/gas/Makefile.in
+++ binutils-2.15/gas/Makefile.in
@@ -618,6 +618,7 @@
 	config/te-macos.h \
 	config/te-nbsd.h \
 	config/te-nbsd532.h \
+	config/te-obsd.h \
 	config/te-pc532mach.h \
 	config/te-pe.h \
 	config/te-ppcnw.h \
@@ -710,7 +711,8 @@
 
 # How to link with both our special library facilities
 # and the system's installed libraries.
-GASLIBS = @OPCODES_LIB@ @BFDLIB@ ../libiberty/libiberty.a
+GASLIBS = @OPCODES_LIB@ @BFDLIB@ -liberty
+GASLIBSDEP = @OPCODES_LIB@ @BFDLIB@
 
 # Files to be copied away after each stage in building.
 STAGESTUFF = *.o $(noinst_PROGRAMS)
@@ -719,7 +721,7 @@
 	$(extra_objects) $(GASLIBS) $(INTLLIBS) $(LIBM)
 
 as_new_DEPENDENCIES = $(TARG_CPU_O) $(OBJ_FORMAT_O) $(ATOF_TARG_O) \
-	$(extra_objects) $(GASLIBS) $(INTLDEPS)
+	$(extra_objects) $(GASLIBSDEP) $(INTLDEPS)
 
 EXPECT = `if [ -f $${rootme}/../expect/expect ] ; then \
           echo $${rootme}/../expect/expect ; \
@@ -2857,6 +2859,8 @@
 
 install-exec-am: install-exec-local
 
+install-info-am:
+
 install-info: install-info-recursive
 
 install-man:
@@ -3062,7 +3066,7 @@
 	$(mkinstalldirs) $(DESTDIR)$(bindir)
 	@list='$(noinst_PROGRAMS)'; for p in $$list; do \
 	  if test -f $$p; then \
-	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
+	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
 	    $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
 	  else :; fi; \
 	done
--- binutils-2.15.orig/gas/config/obj-aout.c
+++ binutils-2.15/gas/config/obj-aout.c
@@ -486,6 +486,8 @@
 
 	 * symbols with no name (stabd's?)
 	 * symbols with debug info in their N_TYPE
+	 * symbols marked "forceout" (to force out local `L' symbols in Net-
+				      or OpenBSD PIC code)
 
 	 Symbols that don't are:
 	 * symbols that are registers
@@ -502,7 +504,15 @@
 	      || !S_IS_DEFINED (symbolP)
 	      || S_IS_EXTERNAL (symbolP)
 	      || (S_GET_NAME (symbolP)[0] != '\001'
-		  && (flag_keep_locals || !S_LOCAL_NAME (symbolP)))))
+		  && (flag_keep_locals || !S_LOCAL_NAME (symbolP))
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
+		 || (flag_pic && symbolP->sy_forceout)
+#endif
+		 ))
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
+	 && (!flag_pic || symbolP != GOT_symbol || got_referenced != 0)
+#endif
+         )
 	{
 	  symbolP->sy_number = symbol_number++;
 
@@ -520,6 +530,11 @@
 	}
       else
 	{
+	  if (S_IS_EXTERNAL (symbolP) || !S_IS_DEFINED (symbolP)
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
+	     && (!flag_pic || symbolP != GOT_symbol || got_referenced != 0)
+#endif
+	     )
 	  if (S_IS_EXTERNAL (symbolP) || !S_IS_DEFINED (symbolP))
 	    /* This warning should never get triggered any more.
 	       Well, maybe if you're doing twisted things with
--- binutils-2.15.orig/gas/config/tc-alpha.c
+++ binutils-2.15/gas/config/tc-alpha.c
@@ -2392,7 +2392,7 @@
 
       insn = (*operand->insert) (insn, val, &errmsg);
       if (errmsg)
-	as_warn (errmsg);
+	as_warn ("%s", errmsg);
     }
   else
     insn |= ((val & ((1 << operand->bits) - 1)) << operand->shift);
--- binutils-2.15.orig/gas/config/tc-arm.c
+++ binutils-2.15/gas/config/tc-arm.c
@@ -152,7 +152,7 @@
 #define FPU_DEFAULT FPU_ARCH_FPA
 #endif
 
-#ifdef TE_NetBSD
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
 #ifdef OBJ_ELF
 #define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, but VFP order.  */
 #else
@@ -11649,7 +11649,7 @@
     }
   else if (mfpu_opt == -1)
     {
-#if !(defined (TE_LINUX) || defined (TE_NetBSD))
+#if !(defined (TE_LINUX) || defined (TE_NetBSD) || defined(TE_OpenBSD))
       /* Some environments specify a default FPU.  If they don't, infer it
 	 from the processor.  */
       if (mcpu_fpu_opt != -1)
--- binutils-2.15.orig/gas/config/tc-hppa.h
+++ binutils-2.15/gas/config/tc-hppa.h
@@ -68,7 +68,7 @@
 #define TARGET_FORMAT "som"
 #endif
 
-#if defined(TE_LINUX) || defined(TE_NetBSD)
+#if defined(TE_LINUX) || defined(TE_NetBSD) || defined(TE_OpenBSD)
 /* Define to compile in an extra assembler option, -c, which enables a
    warning (once per file) when a comment is encountered.
    The hppa comment char is a `;' which tends to occur in random C asm
@@ -77,6 +77,13 @@
 #define WARN_COMMENTS 1
 #endif
 
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
+/* XXX the original OpenBSD code has labels without colons,
+   so this is required, for now -- fredette@netbsd.org */
+/* Labels are not required to have a colon for a suffix.  */
+#define LABELS_WITHOUT_COLONS 1
+#endif
+
 /* FIXME.  Why oh why aren't these defined somewhere globally?  */
 #ifndef FALSE
 #define FALSE   (0)
--- binutils-2.15.orig/gas/config/tc-i386.c
+++ binutils-2.15/gas/config/tc-i386.c
@@ -189,7 +189,8 @@
      || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))	\
 	 && !defined (TE_LINUX)				\
 	 && !defined (TE_FreeBSD)			\
-	 && !defined (TE_NetBSD)))
+	 && !defined (TE_NetBSD)			\
+	 && !defined (TE_OpenBSD)))
 /* This array holds the chars that always start a comment.  If the
    pre-processor is disabled, these aren't very useful.  */
 const char comment_chars[] = "#/";
@@ -967,6 +968,7 @@
     identifier_chars['@'] = '@';
 #endif
     digit_chars['-'] = '-';
+    mnemonic_chars['-'] = '-';
     identifier_chars['_'] = '_';
     identifier_chars['.'] = '.';
 
--- binutils-2.15.orig/gas/config/tc-i386.h
+++ binutils-2.15/gas/config/tc-i386.h
@@ -44,7 +44,7 @@
 #ifdef TE_FreeBSD
 #define AOUT_TARGET_FORMAT	"a.out-i386-freebsd"
 #endif
-#ifdef TE_NetBSD
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
 #define AOUT_TARGET_FORMAT	"a.out-i386-netbsd"
 #endif
 #ifdef TE_386BSD
@@ -396,7 +396,11 @@
 /* The name of the global offset table generated by the compiler. Allow
    this to be overridden if need be.  */
 #ifndef GLOBAL_OFFSET_TABLE_NAME
+#ifdef OBJ_ELF
 #define GLOBAL_OFFSET_TABLE_NAME "_GLOBAL_OFFSET_TABLE_"
+#else
+#define GLOBAL_OFFSET_TABLE_NAME "__GLOBAL_OFFSET_TABLE_"
+#endif
 #endif
 
 #ifndef LEX_AT
--- binutils-2.15.orig/gas/config/tc-i960.c
+++ binutils-2.15/gas/config/tc-i960.c
@@ -673,7 +673,7 @@
 	case REG:
 	  if (branch_predict)
 	    {
-	      as_warn (bp_error_msg);
+	      as_warn ("%s", bp_error_msg);
 	    }
 	  reg_fmt (args, oP);
 	  break;
@@ -682,7 +682,7 @@
 	    {
 	      if (branch_predict)
 		{
-		  as_warn (bp_error_msg);
+		  as_warn ("%s", bp_error_msg);
 		}
 	      mem_fmt (args, oP, 1);
 	      break;
@@ -694,14 +694,14 @@
 	case MEM16:
 	  if (branch_predict)
 	    {
-	      as_warn (bp_error_msg);
+	      as_warn ("%s", bp_error_msg);
 	    }
 	  mem_fmt (args, oP, 0);
 	  break;
 	case CALLJ:
 	  if (branch_predict)
 	    {
-	      as_warn (bp_error_msg);
+	      as_warn ("%s", bp_error_msg);
 	    }
 	  /* Output opcode & set up "fixup" (relocation); flag
 	     relocation as 'callj' type.  */
--- binutils-2.15.orig/gas/config/tc-m68k.h
+++ binutils-2.15/gas/config/tc-m68k.h
@@ -32,7 +32,7 @@
 #ifdef TE_SUN3
 #define TARGET_FORMAT "a.out-sunos-big"
 #endif
-#ifdef TE_NetBSD
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
 #define TARGET_FORMAT "a.out-m68k-netbsd"
 #endif
 #ifdef TE_LINUX
--- binutils-2.15.orig/gas/config/tc-sparc.c
+++ binutils-2.15/gas/config/tc-sparc.c
@@ -309,7 +309,7 @@
     init_default_arch ();
 
 #ifdef OBJ_AOUT
-#ifdef TE_NetBSD
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
   return "a.out-sparc-netbsd";
 #else
 #ifdef TE_SPARCAOUT
@@ -2146,12 +2146,14 @@
 		      {
 			if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
 			  {
+#if !defined(TE_OpenBSD)
 			    if (*args == 'e' || *args == 'f' || *args == 'g')
 			      {
 				error_message
 				  = _(": There are only 32 single precision f registers; [0-31]");
 				goto error;
 			      }
+#endif
 			    v9_arg_p = 1;
 			    mask -= 31;	/* wrap high bit */
 			  }
--- binutils-2.15.orig/gas/config/tc-vax.c
+++ binutils-2.15/gas/config/tc-vax.c
@@ -3405,7 +3405,7 @@
 tc_headers_hook(headers)
      object_headers *headers;
 {
-#ifdef TE_NetBSD
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
   N_SET_INFO(headers->header, OMAGIC, M_VAX4K_NETBSD, 0);
   headers->header.a_info = htonl(headers->header.a_info);
 #endif
--- binutils-2.15.orig/gas/config/tc-vax.h
+++ binutils-2.15/gas/config/tc-vax.h
@@ -24,7 +24,7 @@
 #define TARGET_BYTES_BIG_ENDIAN 0
 
 #ifdef OBJ_AOUT
-#ifdef TE_NetBSD
+#if defined(TE_NetBSD) || defined(TE_OpenBSD)
 #define TARGET_FORMAT "a.out-vax-netbsd"
 #endif
 #ifndef TARGET_FORMAT
--- binutils-2.15.orig/gas/config/te-obsd.h
+++ binutils-2.15/gas/config/te-obsd.h
@@ -0,0 +1,24 @@
+/* te-obsd.h -- OpenBSD target environment declarations.
+   Copyright 2003
+   Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#define TE_OpenBSD	1
+#define LOCAL_LABELS_FB 1
+#include "obj-format.h"
--- binutils-2.15.orig/gas/config/te-obsdhppa64.h
+++ binutils-2.15/gas/config/te-obsdhppa64.h
@@ -0,0 +1,25 @@
+/* te-obsdhppa64.h -- OpenBSD target environment declarations.
+   Copyright 2005
+   Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#define TE_OpenBSD	1
+#define LOCAL_LABELS_FB 1
+#define TARGET_ARCH_SIZE 64
+#include "obj-format.h"
--- binutils-2.15.orig/gas/configure
+++ binutils-2.15/gas/configure
@@ -4242,7 +4242,8 @@
       arm*-*-linux-gnu*)		fmt=elf  em=linux ;;
       arm*-*-uclinux*)			fmt=elf  em=linux ;;
       arm-*-netbsdelf*)                 fmt=elf  em=nbsd ;;
-      arm-*-*n*bsd*)			fmt=aout em=nbsd ;;
+      arm-*-netbsd*)			fmt=aout em=nbsd ;;
+      arm-*-openbsd*)			fmt=elf  em=obsd ;;
       arm-**-nto*)			fmt=elf ;;
       arm-*-oabi | thumb-*-oabi)	fmt=elf ;;
       arm-epoc-pe | thumb-epoc-pe)	fmt=coff em=epoc-pe ;;
@@ -4270,7 +4271,10 @@
       hppa-*-*elf*)			fmt=elf em=hppa ;;
       hppa-*-lites*)			fmt=elf em=hppa ;;
       hppa-*-netbsd*)			fmt=elf em=nbsd ;;
-      hppa-*-openbsd*)			fmt=elf em=hppa ;;
+      hppa-*-openbsd*)	case ${cpu} in
+			    hppa64)	fmt=elf em=obsdhppa64 ;;
+			    hppa)	fmt=elf em=obsd ;;
+			esac ;;
       hppa-*-osf*)			fmt=som em=hppa ;;
       hppa-*-rtems*)			fmt=elf em=hppa ;;
       hppa-*-hpux11*)	case ${cpu} in
@@ -4302,10 +4306,20 @@
       i386-*-netbsd*-gnu* | \
       i386-*-knetbsd*-gnu | \
       i386-*-netbsdelf*)		fmt=elf em=nbsd ;;
-      i386-*-*n*bsd*)	case ${cpu} in
+      i386-*-netbsd*)	case ${cpu} in
 			    x86_64)	fmt=elf em=nbsd ;;
 			    *)		fmt=aout em=nbsd ;;
 			esac ;;
+      i386-*-openbsd*)			em=obsd bfd_gas=yes
+			case ${cpu} in
+			    x86_64)	fmt=elf ;;
+			    *) case ${os} in
+				openbsd[0-2].* | openbsd3.[0-2])
+					fmt=aout ;;
+			       *)
+					fmt=elf ;;
+			       esac
+			esac ;;
       i386-*-linux*aout*)		fmt=aout em=linux ;;
       i386-*-linux*oldld)		fmt=aout em=linux ;;
       i386-*-linux*coff*)		fmt=coff em=linux ;;
@@ -4402,7 +4416,7 @@
       m68k-*-lynxos*)			fmt=coff em=lynx ;;
       m68k-*-netbsdelf*)		fmt=elf em=nbsd ;;
       m68k-*-netbsd*)			fmt=aout em=nbsd bfd_gas=yes ;;
-      m68k-*-openbsd*)			fmt=aout em=nbsd bfd_gas=yes ;;
+      m68k-*-openbsd*)			fmt=aout em=obsd bfd_gas=yes ;;
       m68k-apple-aux*)			fmt=coff em=aux ;;
       m68k-*-psos*)			fmt=elf em=psos;;
 
@@ -4413,7 +4427,6 @@
       mcore-*-pe)			fmt=coff em=pe bfd_gas=yes ;;
 
       # don't change em like *-*-bsd does
-      mips-dec-openbsd*)		fmt=elf endian=little ;;
       mips-sony-bsd*)			fmt=ecoff ;;
       mips-*-bsd*)
 	    { { echo "$as_me:$LINENO: error: Unknown vendor for mips-bsd configuration." >&5
@@ -4433,7 +4446,7 @@
       mips-*-sysv*)			fmt=ecoff ;;
       mips-*-elf* | mips-*-rtems*)	fmt=elf ;;
       mips-*-netbsd*)			fmt=elf ;;
-      mips-*-openbsd*)			fmt=elf ;;
+      mips-*-openbsd*)			fmt=elf em=tmips ;;
 
       mmix-*-*)				fmt=elf ;;
       mn10200-*-*)			fmt=elf ;;
@@ -4457,7 +4470,8 @@
       ;;
       ppc-*-aix*)			fmt=coff ;;
       ppc-*-beos*)			fmt=coff ;;
-      ppc-*-*n*bsd* | ppc-*-elf*)	fmt=elf ;;
+      ppc-*-netbsd* | ppc-*-elf*)	fmt=elf ;;
+      ppc-*-openbsd*)			fmt=elf em=obsd ;;
       ppc-*-eabi* | ppc-*-sysv4*)	fmt=elf ;;
       ppc-*-linux-gnu*)			fmt=elf em=linux
 	    case "$endian" in
@@ -4509,7 +4523,7 @@
       ns32k-pc532-mach*)		fmt=aout em=pc532mach ;;
       ns32k-pc532-ux*)			fmt=aout em=pc532mach ;;
       ns32k-pc532-lites*)		fmt=aout em=nbsd532 ;;
-      ns32k-*-*n*bsd*)			fmt=aout em=nbsd532 ;;
+      ns32k-*-netbsd*)			fmt=aout em=nbsd532 ;;
 
       sparc-*-rtemsaout*)		fmt=aout ;;
       sparc-*-rtemself*)		fmt=elf ;;
@@ -4525,10 +4539,17 @@
       sparc-*-sysv4*)			fmt=elf ;;
       sparc-*-solaris*)			fmt=elf ;;
       sparc-*-netbsdelf*)		fmt=elf em=nbsd ;;
-      sparc-*-*n*bsd*)	case ${cpu} in
+      sparc-*-netbsd*)	case ${cpu} in
 			    sparc64)	fmt=elf em=nbsd ;;
 			    *)		fmt=aout em=nbsd ;;
 			esac ;;
+      sparc-*-openbsd*)			em=obsd bfd_gas=yes
+			case ${os} in
+			    openbsd[0-2].* | openbsd3.[0-1])
+					fmt=aout ;;
+			    *)
+					fmt=elf ;;
+			esac ;;
       strongarm-*-coff)			fmt=coff ;;
       strongarm-*-elf)			fmt=elf ;;
       strongarm-*-kaos*)		fmt=elf ;;
@@ -4663,6 +4684,9 @@
 	  mips*-linux*)
 	    mips_default_abi=O32_ABI
 	    ;;
+	  mips64*-openbsd*)
+	    mips_default_abi=N64_ABI
+	    ;;
 	  *)
 	    mips_default_abi=NO_ABI
 	    ;;
--- binutils-2.15.orig/gas/configure.in
+++ binutils-2.15/gas/configure.in
@@ -212,7 +212,8 @@
       arm*-*-linux-gnu*)		fmt=elf  em=linux ;;
       arm*-*-uclinux*)			fmt=elf  em=linux ;;
       arm-*-netbsdelf*)                 fmt=elf  em=nbsd ;;
-      arm-*-*n*bsd*)			fmt=aout em=nbsd ;;
+      arm-*-netbsd*)			fmt=aout em=nbsd ;;
+      arm-*-openbsd*)			fmt=elf  em=obsd ;;
       arm-**-nto*)			fmt=elf ;;
       arm-*-oabi | thumb-*-oabi)	fmt=elf ;;
       arm-epoc-pe | thumb-epoc-pe)	fmt=coff em=epoc-pe ;;
@@ -240,7 +241,10 @@
       hppa-*-*elf*)			fmt=elf em=hppa ;;
       hppa-*-lites*)			fmt=elf em=hppa ;;
       hppa-*-netbsd*)			fmt=elf em=nbsd ;;
-      hppa-*-openbsd*)			fmt=elf em=hppa ;;
+      hppa-*-openbsd*)	case ${cpu} in
+			    hppa64)	fmt=elf em=obsdhppa64 ;;
+			    hppa)	fmt=elf em=obsd ;;
+			esac ;;
       hppa-*-osf*)			fmt=som em=hppa ;;
       hppa-*-rtems*)			fmt=elf em=hppa ;;
       hppa-*-hpux11*)	case ${cpu} in
@@ -272,10 +276,22 @@
       i386-*-netbsd*-gnu* | \
       i386-*-knetbsd*-gnu | \
       i386-*-netbsdelf*)		fmt=elf em=nbsd ;;
-      i386-*-*n*bsd*)	case ${cpu} in
+      i386-*-netbsd*)	case ${cpu} in
 			    x86_64)	fmt=elf em=nbsd ;;
 			    *)		fmt=aout em=nbsd ;;
 			esac ;;
+changequote(,)dnl
+      i386-*-openbsd*)			em=obsd bfd_gas=yes
+			case ${cpu} in
+			    x86_64)	fmt=elf ;;
+			    *) case ${os} in
+				openbsd[0-2].* | openbsd3.[0-2])
+					fmt=aout ;;
+			       *)
+					fmt=elf ;;
+			       esac
+			esac ;;
+changequote([,])dnl
       i386-*-linux*aout*)		fmt=aout em=linux ;;
       i386-*-linux*oldld)		fmt=aout em=linux ;;
       i386-*-linux*coff*)		fmt=coff em=linux ;;
@@ -365,7 +381,7 @@
       m68k-*-lynxos*)			fmt=coff em=lynx ;;
       m68k-*-netbsdelf*)		fmt=elf em=nbsd ;;
       m68k-*-netbsd*)			fmt=aout em=nbsd bfd_gas=yes ;;
-      m68k-*-openbsd*)			fmt=aout em=nbsd bfd_gas=yes ;;
+      m68k-*-openbsd*)			fmt=aout em=obsd bfd_gas=yes ;;
       m68k-apple-aux*)			fmt=coff em=aux ;;
       m68k-*-psos*)			fmt=elf em=psos;;
 
@@ -376,7 +392,6 @@
       mcore-*-pe)			fmt=coff em=pe bfd_gas=yes ;;
 
       # don't change em like *-*-bsd does
-      mips-dec-openbsd*)		fmt=elf endian=little ;;
       mips-sony-bsd*)			fmt=ecoff ;;
       mips-*-bsd*)
 	    AC_MSG_ERROR(Unknown vendor for mips-bsd configuration.) ;;
@@ -394,7 +409,7 @@
       mips-*-sysv*)			fmt=ecoff ;;
       mips-*-elf* | mips-*-rtems*)	fmt=elf ;;
       mips-*-netbsd*)			fmt=elf ;;
-      mips-*-openbsd*)			fmt=elf ;;
+      mips-*-openbsd*)			fmt=elf em=tmips ;;
 
       mmix-*-*)				fmt=elf ;;
       mn10200-*-*)			fmt=elf ;;
@@ -417,7 +432,8 @@
       ;;
       ppc-*-aix*)			fmt=coff ;;
       ppc-*-beos*)			fmt=coff ;;
-      ppc-*-*n*bsd* | ppc-*-elf*)	fmt=elf ;;
+      ppc-*-netbsd* | ppc-*-elf*)	fmt=elf ;;
+      ppc-*-openbsd*)			fmt=elf em=obsd ;;
       ppc-*-eabi* | ppc-*-sysv4*)	fmt=elf ;;
       ppc-*-linux-gnu*)			fmt=elf em=linux
 	    case "$endian" in
@@ -462,7 +478,7 @@
       ns32k-pc532-mach*)		fmt=aout em=pc532mach ;;
       ns32k-pc532-ux*)			fmt=aout em=pc532mach ;;
       ns32k-pc532-lites*)		fmt=aout em=nbsd532 ;;
-      ns32k-*-*n*bsd*)			fmt=aout em=nbsd532 ;;
+      ns32k-*-netbsd*)			fmt=aout em=nbsd532 ;;
 
       sparc-*-rtemsaout*)		fmt=aout ;;
       sparc-*-rtemself*)		fmt=elf ;;
@@ -478,10 +494,20 @@
       sparc-*-sysv4*)			fmt=elf ;;
       sparc-*-solaris*)			fmt=elf ;;
       sparc-*-netbsdelf*)		fmt=elf em=nbsd ;;
-      sparc-*-*n*bsd*)	case ${cpu} in
+      sparc-*-netbsd*)	case ${cpu} in
 			    sparc64)	fmt=elf em=nbsd ;;
 			    *)		fmt=aout em=nbsd ;;
 			esac ;;
+changequote(,)dnl
+      sparc-*-openbsd*)			em=obsd bfd_gas=yes
+			case ${os} in
+			    openbsd[0-2].* | openbsd3.[0-1])
+					fmt=aout ;;
+			    *)
+					fmt=elf ;;
+			esac ;;
+changequote([,])dnl
+      sparc64-*-openbsd*) em=obsd bfd_gas=yes fmt=elf ;;
       strongarm-*-coff)			fmt=coff ;;
       strongarm-*-elf)			fmt=elf ;;
       strongarm-*-kaos*)		fmt=elf ;;
@@ -615,6 +641,9 @@
 	  mips*-linux*)
 	    mips_default_abi=O32_ABI
 	    ;;
+	  mips64*-openbsd*)
+	    mips_default_abi=N64_ABI
+	    ;;
 	  *)
 	    mips_default_abi=NO_ABI
 	    ;;
--- binutils-2.15.orig/gas/read.c
+++ binutils-2.15/gas/read.c
@@ -4564,7 +4564,7 @@
 	    int i;
 
 	    for (i = 0, number = 0;
-		 ISDIGIT (c) && i < 3;
+		 i < 3 && ISDIGIT (c);
 		 c = *input_line_pointer++, i++)
 	      {
 		number = number * 8 + c - '0';
--- binutils-2.15.orig/gprof/Makefile.am
+++ binutils-2.15/gprof/Makefile.am
@@ -25,8 +25,8 @@
 	search_list.c symtab.c sym_ids.c utils.c \
 	i386.c alpha.c vax.c tahoe.c sparc.c mips.c
 gprof_SOURCES = $(sources) flat_bl.c bsd_callg_bl.c fsf_callg_bl.c
-gprof_DEPENDENCIES = ../bfd/libbfd.la ../libiberty/libiberty.a $(INTLDEPS)
-gprof_LDADD = ../bfd/libbfd.la ../libiberty/libiberty.a $(INTLLIBS)
+gprof_DEPENDENCIES = ../bfd/libbfd.la $(INTLDEPS)
+gprof_LDADD = ../bfd/libbfd.la -liberty $(INTLLIBS)
 
 noinst_HEADERS = \
 	basic_blocks.h call_graph.h cg_arcs.h cg_dfn.h cg_print.h \
--- binutils-2.15.orig/gprof/Makefile.in
+++ binutils-2.15/gprof/Makefile.in
@@ -126,8 +126,8 @@
 	i386.c alpha.c vax.c tahoe.c sparc.c mips.c
 
 gprof_SOURCES = $(sources) flat_bl.c bsd_callg_bl.c fsf_callg_bl.c
-gprof_DEPENDENCIES = ../bfd/libbfd.la ../libiberty/libiberty.a $(INTLDEPS)
-gprof_LDADD = ../bfd/libbfd.la ../libiberty/libiberty.a $(INTLLIBS)
+gprof_DEPENDENCIES = ../bfd/libbfd.la $(INTLDEPS)
+gprof_LDADD = ../bfd/libbfd.la -liberty $(INTLLIBS)
 
 noinst_HEADERS = \
 	basic_blocks.h call_graph.h cg_arcs.h cg_dfn.h cg_print.h \
@@ -504,6 +504,7 @@
 	rev=''; list='$(SUBDIRS)'; for subdir in $$list; do \
 	  rev="$$subdir $$rev"; \
 	  test "$$subdir" != "." || dot_seen=yes; \
+	  true; \
 	done; \
 	test "$$dot_seen" = "no" && rev=". $$rev"; \
 	target=`echo $@ | sed s/-recursive//`; \
--- binutils-2.15.orig/include/gdb/callback.h
+++ binutils-2.15/include/gdb/callback.h
@@ -123,8 +123,15 @@
   int last_errno;		/* host format */
 
   int fdmap[MAX_CALLBACK_FDS];
-  char fdopen[MAX_CALLBACK_FDS];
-  char alwaysopen[MAX_CALLBACK_FDS];
+  /* fd_buddy is used to contruct circular lists of target fds that point to
+     the same host fd.  A uniquely mapped fd points to itself; for a closed
+     one, fd_buddy has the value -1.  The host file descriptors for stdin /
+     stdout / stderr are never closed by the simulators, so they are put
+     in a special fd_buddy circular list which also has MAX_CALLBACK_FDS
+     as a member.  */
+  /* ??? We don't have a callback entry for dup, although it is trival to
+     implement now.  */
+  short fd_buddy[MAX_CALLBACK_FDS+1];
 
   /* System call numbers.  */
   CB_TARGET_DEFS_MAP *syscall_map;
--- binutils-2.15.orig/include/gdb/sim-ppc.h
+++ binutils-2.15/include/gdb/sim-ppc.h
@@ -0,0 +1,771 @@
+/* sim-ppc.h --- interface between PowerPC simulator and GDB.
+
+   Copyright 2004 Free Software Foundation, Inc.
+
+   Contributed by Red Hat.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#if !defined (SIM_PPC_H)
+#define SIM_PPC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The register access functions, sim_fetch_register and
+   sim_store_register, use the following numbering for PowerPC
+   registers.  */
+
+enum sim_ppc_regnum
+  {
+    /* General-purpose registers, r0 -- r31.  */
+    sim_ppc_r0_regnum,
+    sim_ppc_r1_regnum,
+    sim_ppc_r2_regnum,
+    sim_ppc_r3_regnum,
+    sim_ppc_r4_regnum,
+    sim_ppc_r5_regnum,
+    sim_ppc_r6_regnum,
+    sim_ppc_r7_regnum,
+    sim_ppc_r8_regnum,
+    sim_ppc_r9_regnum,
+    sim_ppc_r10_regnum,
+    sim_ppc_r11_regnum,
+    sim_ppc_r12_regnum,
+    sim_ppc_r13_regnum,
+    sim_ppc_r14_regnum,
+    sim_ppc_r15_regnum,
+    sim_ppc_r16_regnum,
+    sim_ppc_r17_regnum,
+    sim_ppc_r18_regnum,
+    sim_ppc_r19_regnum,
+    sim_ppc_r20_regnum,
+    sim_ppc_r21_regnum,
+    sim_ppc_r22_regnum,
+    sim_ppc_r23_regnum,
+    sim_ppc_r24_regnum,
+    sim_ppc_r25_regnum,
+    sim_ppc_r26_regnum,
+    sim_ppc_r27_regnum,
+    sim_ppc_r28_regnum,
+    sim_ppc_r29_regnum,
+    sim_ppc_r30_regnum,
+    sim_ppc_r31_regnum,
+
+    /* Floating-point registers, f0 -- f31.  */
+    sim_ppc_f0_regnum,
+    sim_ppc_f1_regnum,
+    sim_ppc_f2_regnum,
+    sim_ppc_f3_regnum,
+    sim_ppc_f4_regnum,
+    sim_ppc_f5_regnum,
+    sim_ppc_f6_regnum,
+    sim_ppc_f7_regnum,
+    sim_ppc_f8_regnum,
+    sim_ppc_f9_regnum,
+    sim_ppc_f10_regnum,
+    sim_ppc_f11_regnum,
+    sim_ppc_f12_regnum,
+    sim_ppc_f13_regnum,
+    sim_ppc_f14_regnum,
+    sim_ppc_f15_regnum,
+    sim_ppc_f16_regnum,
+    sim_ppc_f17_regnum,
+    sim_ppc_f18_regnum,
+    sim_ppc_f19_regnum,
+    sim_ppc_f20_regnum,
+    sim_ppc_f21_regnum,
+    sim_ppc_f22_regnum,
+    sim_ppc_f23_regnum,
+    sim_ppc_f24_regnum,
+    sim_ppc_f25_regnum,
+    sim_ppc_f26_regnum,
+    sim_ppc_f27_regnum,
+    sim_ppc_f28_regnum,
+    sim_ppc_f29_regnum,
+    sim_ppc_f30_regnum,
+    sim_ppc_f31_regnum,
+
+    /* Altivec vector registers, vr0 -- vr31.  */
+    sim_ppc_vr0_regnum,
+    sim_ppc_vr1_regnum,
+    sim_ppc_vr2_regnum,
+    sim_ppc_vr3_regnum,
+    sim_ppc_vr4_regnum,
+    sim_ppc_vr5_regnum,
+    sim_ppc_vr6_regnum,
+    sim_ppc_vr7_regnum,
+    sim_ppc_vr8_regnum,
+    sim_ppc_vr9_regnum,
+    sim_ppc_vr10_regnum,
+    sim_ppc_vr11_regnum,
+    sim_ppc_vr12_regnum,
+    sim_ppc_vr13_regnum,
+    sim_ppc_vr14_regnum,
+    sim_ppc_vr15_regnum,
+    sim_ppc_vr16_regnum,
+    sim_ppc_vr17_regnum,
+    sim_ppc_vr18_regnum,
+    sim_ppc_vr19_regnum,
+    sim_ppc_vr20_regnum,
+    sim_ppc_vr21_regnum,
+    sim_ppc_vr22_regnum,
+    sim_ppc_vr23_regnum,
+    sim_ppc_vr24_regnum,
+    sim_ppc_vr25_regnum,
+    sim_ppc_vr26_regnum,
+    sim_ppc_vr27_regnum,
+    sim_ppc_vr28_regnum,
+    sim_ppc_vr29_regnum,
+    sim_ppc_vr30_regnum,
+    sim_ppc_vr31_regnum,
+
+    /* SPE APU GPR upper halves.  These are the upper 32 bits of the
+       gprs; there is one upper-half register for each gpr, so it is
+       appropriate to use sim_ppc_num_gprs for iterating through
+       these.  */
+    sim_ppc_rh0_regnum,
+    sim_ppc_rh1_regnum,
+    sim_ppc_rh2_regnum,
+    sim_ppc_rh3_regnum,
+    sim_ppc_rh4_regnum,
+    sim_ppc_rh5_regnum,
+    sim_ppc_rh6_regnum,
+    sim_ppc_rh7_regnum,
+    sim_ppc_rh8_regnum,
+    sim_ppc_rh9_regnum,
+    sim_ppc_rh10_regnum,
+    sim_ppc_rh11_regnum,
+    sim_ppc_rh12_regnum,
+    sim_ppc_rh13_regnum,
+    sim_ppc_rh14_regnum,
+    sim_ppc_rh15_regnum,
+    sim_ppc_rh16_regnum,
+    sim_ppc_rh17_regnum,
+    sim_ppc_rh18_regnum,
+    sim_ppc_rh19_regnum,
+    sim_ppc_rh20_regnum,
+    sim_ppc_rh21_regnum,
+    sim_ppc_rh22_regnum,
+    sim_ppc_rh23_regnum,
+    sim_ppc_rh24_regnum,
+    sim_ppc_rh25_regnum,
+    sim_ppc_rh26_regnum,
+    sim_ppc_rh27_regnum,
+    sim_ppc_rh28_regnum,
+    sim_ppc_rh29_regnum,
+    sim_ppc_rh30_regnum,
+    sim_ppc_rh31_regnum,
+
+    /* SPE APU GPR full registers.  Each of these registers is the
+       64-bit concatenation of a 32-bit GPR (providing the lower bits)
+       and a 32-bit upper-half register (providing the higher bits).
+       As for the upper-half registers, it is appropriate to use
+       sim_ppc_num_gprs with these.  */
+    sim_ppc_ev0_regnum,
+    sim_ppc_ev1_regnum,
+    sim_ppc_ev2_regnum,
+    sim_ppc_ev3_regnum,
+    sim_ppc_ev4_regnum,
+    sim_ppc_ev5_regnum,
+    sim_ppc_ev6_regnum,
+    sim_ppc_ev7_regnum,
+    sim_ppc_ev8_regnum,
+    sim_ppc_ev9_regnum,
+    sim_ppc_ev10_regnum,
+    sim_ppc_ev11_regnum,
+    sim_ppc_ev12_regnum,
+    sim_ppc_ev13_regnum,
+    sim_ppc_ev14_regnum,
+    sim_ppc_ev15_regnum,
+    sim_ppc_ev16_regnum,
+    sim_ppc_ev17_regnum,
+    sim_ppc_ev18_regnum,
+    sim_ppc_ev19_regnum,
+    sim_ppc_ev20_regnum,
+    sim_ppc_ev21_regnum,
+    sim_ppc_ev22_regnum,
+    sim_ppc_ev23_regnum,
+    sim_ppc_ev24_regnum,
+    sim_ppc_ev25_regnum,
+    sim_ppc_ev26_regnum,
+    sim_ppc_ev27_regnum,
+    sim_ppc_ev28_regnum,
+    sim_ppc_ev29_regnum,
+    sim_ppc_ev30_regnum,
+    sim_ppc_ev31_regnum,
+
+    /* Segment registers, sr0 -- sr15.  */
+    sim_ppc_sr0_regnum,
+    sim_ppc_sr1_regnum,
+    sim_ppc_sr2_regnum,
+    sim_ppc_sr3_regnum,
+    sim_ppc_sr4_regnum,
+    sim_ppc_sr5_regnum,
+    sim_ppc_sr6_regnum,
+    sim_ppc_sr7_regnum,
+    sim_ppc_sr8_regnum,
+    sim_ppc_sr9_regnum,
+    sim_ppc_sr10_regnum,
+    sim_ppc_sr11_regnum,
+    sim_ppc_sr12_regnum,
+    sim_ppc_sr13_regnum,
+    sim_ppc_sr14_regnum,
+    sim_ppc_sr15_regnum,
+
+    /* Miscellaneous --- but non-SPR --- registers.  */
+    sim_ppc_pc_regnum,
+    sim_ppc_ps_regnum,
+    sim_ppc_cr_regnum,
+    sim_ppc_fpscr_regnum,
+    sim_ppc_acc_regnum,
+    sim_ppc_vscr_regnum,
+
+    /* Special-purpose registers.  */
+    sim_ppc_spr0_regnum, sim_ppc_spr1_regnum,
+    sim_ppc_spr2_regnum, sim_ppc_spr3_regnum,
+    sim_ppc_spr4_regnum, sim_ppc_spr5_regnum,
+    sim_ppc_spr6_regnum, sim_ppc_spr7_regnum,
+    sim_ppc_spr8_regnum, sim_ppc_spr9_regnum,
+    sim_ppc_spr10_regnum, sim_ppc_spr11_regnum,
+    sim_ppc_spr12_regnum, sim_ppc_spr13_regnum,
+    sim_ppc_spr14_regnum, sim_ppc_spr15_regnum,
+    sim_ppc_spr16_regnum, sim_ppc_spr17_regnum,
+    sim_ppc_spr18_regnum, sim_ppc_spr19_regnum,
+    sim_ppc_spr20_regnum, sim_ppc_spr21_regnum,
+    sim_ppc_spr22_regnum, sim_ppc_spr23_regnum,
+    sim_ppc_spr24_regnum, sim_ppc_spr25_regnum,
+    sim_ppc_spr26_regnum, sim_ppc_spr27_regnum,
+    sim_ppc_spr28_regnum, sim_ppc_spr29_regnum,
+    sim_ppc_spr30_regnum, sim_ppc_spr31_regnum,
+    sim_ppc_spr32_regnum, sim_ppc_spr33_regnum,
+    sim_ppc_spr34_regnum, sim_ppc_spr35_regnum,
+    sim_ppc_spr36_regnum, sim_ppc_spr37_regnum,
+    sim_ppc_spr38_regnum, sim_ppc_spr39_regnum,
+    sim_ppc_spr40_regnum, sim_ppc_spr41_regnum,
+    sim_ppc_spr42_regnum, sim_ppc_spr43_regnum,
+    sim_ppc_spr44_regnum, sim_ppc_spr45_regnum,
+    sim_ppc_spr46_regnum, sim_ppc_spr47_regnum,
+    sim_ppc_spr48_regnum, sim_ppc_spr49_regnum,
+    sim_ppc_spr50_regnum, sim_ppc_spr51_regnum,
+    sim_ppc_spr52_regnum, sim_ppc_spr53_regnum,
+    sim_ppc_spr54_regnum, sim_ppc_spr55_regnum,
+    sim_ppc_spr56_regnum, sim_ppc_spr57_regnum,
+    sim_ppc_spr58_regnum, sim_ppc_spr59_regnum,
+    sim_ppc_spr60_regnum, sim_ppc_spr61_regnum,
+    sim_ppc_spr62_regnum, sim_ppc_spr63_regnum,
+    sim_ppc_spr64_regnum, sim_ppc_spr65_regnum,
+    sim_ppc_spr66_regnum, sim_ppc_spr67_regnum,
+    sim_ppc_spr68_regnum, sim_ppc_spr69_regnum,
+    sim_ppc_spr70_regnum, sim_ppc_spr71_regnum,
+    sim_ppc_spr72_regnum, sim_ppc_spr73_regnum,
+    sim_ppc_spr74_regnum, sim_ppc_spr75_regnum,
+    sim_ppc_spr76_regnum, sim_ppc_spr77_regnum,
+    sim_ppc_spr78_regnum, sim_ppc_spr79_regnum,
+    sim_ppc_spr80_regnum, sim_ppc_spr81_regnum,
+    sim_ppc_spr82_regnum, sim_ppc_spr83_regnum,
+    sim_ppc_spr84_regnum, sim_ppc_spr85_regnum,
+    sim_ppc_spr86_regnum, sim_ppc_spr87_regnum,
+    sim_ppc_spr88_regnum, sim_ppc_spr89_regnum,
+    sim_ppc_spr90_regnum, sim_ppc_spr91_regnum,
+    sim_ppc_spr92_regnum, sim_ppc_spr93_regnum,
+    sim_ppc_spr94_regnum, sim_ppc_spr95_regnum,
+    sim_ppc_spr96_regnum, sim_ppc_spr97_regnum,
+    sim_ppc_spr98_regnum, sim_ppc_spr99_regnum,
+    sim_ppc_spr100_regnum, sim_ppc_spr101_regnum,
+    sim_ppc_spr102_regnum, sim_ppc_spr103_regnum,
+    sim_ppc_spr104_regnum, sim_ppc_spr105_regnum,
+    sim_ppc_spr106_regnum, sim_ppc_spr107_regnum,
+    sim_ppc_spr108_regnum, sim_ppc_spr109_regnum,
+    sim_ppc_spr110_regnum, sim_ppc_spr111_regnum,
+    sim_ppc_spr112_regnum, sim_ppc_spr113_regnum,
+    sim_ppc_spr114_regnum, sim_ppc_spr115_regnum,
+    sim_ppc_spr116_regnum, sim_ppc_spr117_regnum,
+    sim_ppc_spr118_regnum, sim_ppc_spr119_regnum,
+    sim_ppc_spr120_regnum, sim_ppc_spr121_regnum,
+    sim_ppc_spr122_regnum, sim_ppc_spr123_regnum,
+    sim_ppc_spr124_regnum, sim_ppc_spr125_regnum,
+    sim_ppc_spr126_regnum, sim_ppc_spr127_regnum,
+    sim_ppc_spr128_regnum, sim_ppc_spr129_regnum,
+    sim_ppc_spr130_regnum, sim_ppc_spr131_regnum,
+    sim_ppc_spr132_regnum, sim_ppc_spr133_regnum,
+    sim_ppc_spr134_regnum, sim_ppc_spr135_regnum,
+    sim_ppc_spr136_regnum, sim_ppc_spr137_regnum,
+    sim_ppc_spr138_regnum, sim_ppc_spr139_regnum,
+    sim_ppc_spr140_regnum, sim_ppc_spr141_regnum,
+    sim_ppc_spr142_regnum, sim_ppc_spr143_regnum,
+    sim_ppc_spr144_regnum, sim_ppc_spr145_regnum,
+    sim_ppc_spr146_regnum, sim_ppc_spr147_regnum,
+    sim_ppc_spr148_regnum, sim_ppc_spr149_regnum,
+    sim_ppc_spr150_regnum, sim_ppc_spr151_regnum,
+    sim_ppc_spr152_regnum, sim_ppc_spr153_regnum,
+    sim_ppc_spr154_regnum, sim_ppc_spr155_regnum,
+    sim_ppc_spr156_regnum, sim_ppc_spr157_regnum,
+    sim_ppc_spr158_regnum, sim_ppc_spr159_regnum,
+    sim_ppc_spr160_regnum, sim_ppc_spr161_regnum,
+    sim_ppc_spr162_regnum, sim_ppc_spr163_regnum,
+    sim_ppc_spr164_regnum, sim_ppc_spr165_regnum,
+    sim_ppc_spr166_regnum, sim_ppc_spr167_regnum,
+    sim_ppc_spr168_regnum, sim_ppc_spr169_regnum,
+    sim_ppc_spr170_regnum, sim_ppc_spr171_regnum,
+    sim_ppc_spr172_regnum, sim_ppc_spr173_regnum,
+    sim_ppc_spr174_regnum, sim_ppc_spr175_regnum,
+    sim_ppc_spr176_regnum, sim_ppc_spr177_regnum,
+    sim_ppc_spr178_regnum, sim_ppc_spr179_regnum,
+    sim_ppc_spr180_regnum, sim_ppc_spr181_regnum,
+    sim_ppc_spr182_regnum, sim_ppc_spr183_regnum,
+    sim_ppc_spr184_regnum, sim_ppc_spr185_regnum,
+    sim_ppc_spr186_regnum, sim_ppc_spr187_regnum,
+    sim_ppc_spr188_regnum, sim_ppc_spr189_regnum,
+    sim_ppc_spr190_regnum, sim_ppc_spr191_regnum,
+    sim_ppc_spr192_regnum, sim_ppc_spr193_regnum,
+    sim_ppc_spr194_regnum, sim_ppc_spr195_regnum,
+    sim_ppc_spr196_regnum, sim_ppc_spr197_regnum,
+    sim_ppc_spr198_regnum, sim_ppc_spr199_regnum,
+    sim_ppc_spr200_regnum, sim_ppc_spr201_regnum,
+    sim_ppc_spr202_regnum, sim_ppc_spr203_regnum,
+    sim_ppc_spr204_regnum, sim_ppc_spr205_regnum,
+    sim_ppc_spr206_regnum, sim_ppc_spr207_regnum,
+    sim_ppc_spr208_regnum, sim_ppc_spr209_regnum,
+    sim_ppc_spr210_regnum, sim_ppc_spr211_regnum,
+    sim_ppc_spr212_regnum, sim_ppc_spr213_regnum,
+    sim_ppc_spr214_regnum, sim_ppc_spr215_regnum,
+    sim_ppc_spr216_regnum, sim_ppc_spr217_regnum,
+    sim_ppc_spr218_regnum, sim_ppc_spr219_regnum,
+    sim_ppc_spr220_regnum, sim_ppc_spr221_regnum,
+    sim_ppc_spr222_regnum, sim_ppc_spr223_regnum,
+    sim_ppc_spr224_regnum, sim_ppc_spr225_regnum,
+    sim_ppc_spr226_regnum, sim_ppc_spr227_regnum,
+    sim_ppc_spr228_regnum, sim_ppc_spr229_regnum,
+    sim_ppc_spr230_regnum, sim_ppc_spr231_regnum,
+    sim_ppc_spr232_regnum, sim_ppc_spr233_regnum,
+    sim_ppc_spr234_regnum, sim_ppc_spr235_regnum,
+    sim_ppc_spr236_regnum, sim_ppc_spr237_regnum,
+    sim_ppc_spr238_regnum, sim_ppc_spr239_regnum,
+    sim_ppc_spr240_regnum, sim_ppc_spr241_regnum,
+    sim_ppc_spr242_regnum, sim_ppc_spr243_regnum,
+    sim_ppc_spr244_regnum, sim_ppc_spr245_regnum,
+    sim_ppc_spr246_regnum, sim_ppc_spr247_regnum,
+    sim_ppc_spr248_regnum, sim_ppc_spr249_regnum,
+    sim_ppc_spr250_regnum, sim_ppc_spr251_regnum,
+    sim_ppc_spr252_regnum, sim_ppc_spr253_regnum,
+    sim_ppc_spr254_regnum, sim_ppc_spr255_regnum,
+    sim_ppc_spr256_regnum, sim_ppc_spr257_regnum,
+    sim_ppc_spr258_regnum, sim_ppc_spr259_regnum,
+    sim_ppc_spr260_regnum, sim_ppc_spr261_regnum,
+    sim_ppc_spr262_regnum, sim_ppc_spr263_regnum,
+    sim_ppc_spr264_regnum, sim_ppc_spr265_regnum,
+    sim_ppc_spr266_regnum, sim_ppc_spr267_regnum,
+    sim_ppc_spr268_regnum, sim_ppc_spr269_regnum,
+    sim_ppc_spr270_regnum, sim_ppc_spr271_regnum,
+    sim_ppc_spr272_regnum, sim_ppc_spr273_regnum,
+    sim_ppc_spr274_regnum, sim_ppc_spr275_regnum,
+    sim_ppc_spr276_regnum, sim_ppc_spr277_regnum,
+    sim_ppc_spr278_regnum, sim_ppc_spr279_regnum,
+    sim_ppc_spr280_regnum, sim_ppc_spr281_regnum,
+    sim_ppc_spr282_regnum, sim_ppc_spr283_regnum,
+    sim_ppc_spr284_regnum, sim_ppc_spr285_regnum,
+    sim_ppc_spr286_regnum, sim_ppc_spr287_regnum,
+    sim_ppc_spr288_regnum, sim_ppc_spr289_regnum,
+    sim_ppc_spr290_regnum, sim_ppc_spr291_regnum,
+    sim_ppc_spr292_regnum, sim_ppc_spr293_regnum,
+    sim_ppc_spr294_regnum, sim_ppc_spr295_regnum,
+    sim_ppc_spr296_regnum, sim_ppc_spr297_regnum,
+    sim_ppc_spr298_regnum, sim_ppc_spr299_regnum,
+    sim_ppc_spr300_regnum, sim_ppc_spr301_regnum,
+    sim_ppc_spr302_regnum, sim_ppc_spr303_regnum,
+    sim_ppc_spr304_regnum, sim_ppc_spr305_regnum,
+    sim_ppc_spr306_regnum, sim_ppc_spr307_regnum,
+    sim_ppc_spr308_regnum, sim_ppc_spr309_regnum,
+    sim_ppc_spr310_regnum, sim_ppc_spr311_regnum,
+    sim_ppc_spr312_regnum, sim_ppc_spr313_regnum,
+    sim_ppc_spr314_regnum, sim_ppc_spr315_regnum,
+    sim_ppc_spr316_regnum, sim_ppc_spr317_regnum,
+    sim_ppc_spr318_regnum, sim_ppc_spr319_regnum,
+    sim_ppc_spr320_regnum, sim_ppc_spr321_regnum,
+    sim_ppc_spr322_regnum, sim_ppc_spr323_regnum,
+    sim_ppc_spr324_regnum, sim_ppc_spr325_regnum,
+    sim_ppc_spr326_regnum, sim_ppc_spr327_regnum,
+    sim_ppc_spr328_regnum, sim_ppc_spr329_regnum,
+    sim_ppc_spr330_regnum, sim_ppc_spr331_regnum,
+    sim_ppc_spr332_regnum, sim_ppc_spr333_regnum,
+    sim_ppc_spr334_regnum, sim_ppc_spr335_regnum,
+    sim_ppc_spr336_regnum, sim_ppc_spr337_regnum,
+    sim_ppc_spr338_regnum, sim_ppc_spr339_regnum,
+    sim_ppc_spr340_regnum, sim_ppc_spr341_regnum,
+    sim_ppc_spr342_regnum, sim_ppc_spr343_regnum,
+    sim_ppc_spr344_regnum, sim_ppc_spr345_regnum,
+    sim_ppc_spr346_regnum, sim_ppc_spr347_regnum,
+    sim_ppc_spr348_regnum, sim_ppc_spr349_regnum,
+    sim_ppc_spr350_regnum, sim_ppc_spr351_regnum,
+    sim_ppc_spr352_regnum, sim_ppc_spr353_regnum,
+    sim_ppc_spr354_regnum, sim_ppc_spr355_regnum,
+    sim_ppc_spr356_regnum, sim_ppc_spr357_regnum,
+    sim_ppc_spr358_regnum, sim_ppc_spr359_regnum,
+    sim_ppc_spr360_regnum, sim_ppc_spr361_regnum,
+    sim_ppc_spr362_regnum, sim_ppc_spr363_regnum,
+    sim_ppc_spr364_regnum, sim_ppc_spr365_regnum,
+    sim_ppc_spr366_regnum, sim_ppc_spr367_regnum,
+    sim_ppc_spr368_regnum, sim_ppc_spr369_regnum,
+    sim_ppc_spr370_regnum, sim_ppc_spr371_regnum,
+    sim_ppc_spr372_regnum, sim_ppc_spr373_regnum,
+    sim_ppc_spr374_regnum, sim_ppc_spr375_regnum,
+    sim_ppc_spr376_regnum, sim_ppc_spr377_regnum,
+    sim_ppc_spr378_regnum, sim_ppc_spr379_regnum,
+    sim_ppc_spr380_regnum, sim_ppc_spr381_regnum,
+    sim_ppc_spr382_regnum, sim_ppc_spr383_regnum,
+    sim_ppc_spr384_regnum, sim_ppc_spr385_regnum,
+    sim_ppc_spr386_regnum, sim_ppc_spr387_regnum,
+    sim_ppc_spr388_regnum, sim_ppc_spr389_regnum,
+    sim_ppc_spr390_regnum, sim_ppc_spr391_regnum,
+    sim_ppc_spr392_regnum, sim_ppc_spr393_regnum,
+    sim_ppc_spr394_regnum, sim_ppc_spr395_regnum,
+    sim_ppc_spr396_regnum, sim_ppc_spr397_regnum,
+    sim_ppc_spr398_regnum, sim_ppc_spr399_regnum,
+    sim_ppc_spr400_regnum, sim_ppc_spr401_regnum,
+    sim_ppc_spr402_regnum, sim_ppc_spr403_regnum,
+    sim_ppc_spr404_regnum, sim_ppc_spr405_regnum,
+    sim_ppc_spr406_regnum, sim_ppc_spr407_regnum,
+    sim_ppc_spr408_regnum, sim_ppc_spr409_regnum,
+    sim_ppc_spr410_regnum, sim_ppc_spr411_regnum,
+    sim_ppc_spr412_regnum, sim_ppc_spr413_regnum,
+    sim_ppc_spr414_regnum, sim_ppc_spr415_regnum,
+    sim_ppc_spr416_regnum, sim_ppc_spr417_regnum,
+    sim_ppc_spr418_regnum, sim_ppc_spr419_regnum,
+    sim_ppc_spr420_regnum, sim_ppc_spr421_regnum,
+    sim_ppc_spr422_regnum, sim_ppc_spr423_regnum,
+    sim_ppc_spr424_regnum, sim_ppc_spr425_regnum,
+    sim_ppc_spr426_regnum, sim_ppc_spr427_regnum,
+    sim_ppc_spr428_regnum, sim_ppc_spr429_regnum,
+    sim_ppc_spr430_regnum, sim_ppc_spr431_regnum,
+    sim_ppc_spr432_regnum, sim_ppc_spr433_regnum,
+    sim_ppc_spr434_regnum, sim_ppc_spr435_regnum,
+    sim_ppc_spr436_regnum, sim_ppc_spr437_regnum,
+    sim_ppc_spr438_regnum, sim_ppc_spr439_regnum,
+    sim_ppc_spr440_regnum, sim_ppc_spr441_regnum,
+    sim_ppc_spr442_regnum, sim_ppc_spr443_regnum,
+    sim_ppc_spr444_regnum, sim_ppc_spr445_regnum,
+    sim_ppc_spr446_regnum, sim_ppc_spr447_regnum,
+    sim_ppc_spr448_regnum, sim_ppc_spr449_regnum,
+    sim_ppc_spr450_regnum, sim_ppc_spr451_regnum,
+    sim_ppc_spr452_regnum, sim_ppc_spr453_regnum,
+    sim_ppc_spr454_regnum, sim_ppc_spr455_regnum,
+    sim_ppc_spr456_regnum, sim_ppc_spr457_regnum,
+    sim_ppc_spr458_regnum, sim_ppc_spr459_regnum,
+    sim_ppc_spr460_regnum, sim_ppc_spr461_regnum,
+    sim_ppc_spr462_regnum, sim_ppc_spr463_regnum,
+    sim_ppc_spr464_regnum, sim_ppc_spr465_regnum,
+    sim_ppc_spr466_regnum, sim_ppc_spr467_regnum,
+    sim_ppc_spr468_regnum, sim_ppc_spr469_regnum,
+    sim_ppc_spr470_regnum, sim_ppc_spr471_regnum,
+    sim_ppc_spr472_regnum, sim_ppc_spr473_regnum,
+    sim_ppc_spr474_regnum, sim_ppc_spr475_regnum,
+    sim_ppc_spr476_regnum, sim_ppc_spr477_regnum,
+    sim_ppc_spr478_regnum, sim_ppc_spr479_regnum,
+    sim_ppc_spr480_regnum, sim_ppc_spr481_regnum,
+    sim_ppc_spr482_regnum, sim_ppc_spr483_regnum,
+    sim_ppc_spr484_regnum, sim_ppc_spr485_regnum,
+    sim_ppc_spr486_regnum, sim_ppc_spr487_regnum,
+    sim_ppc_spr488_regnum, sim_ppc_spr489_regnum,
+    sim_ppc_spr490_regnum, sim_ppc_spr491_regnum,
+    sim_ppc_spr492_regnum, sim_ppc_spr493_regnum,
+    sim_ppc_spr494_regnum, sim_ppc_spr495_regnum,
+    sim_ppc_spr496_regnum, sim_ppc_spr497_regnum,
+    sim_ppc_spr498_regnum, sim_ppc_spr499_regnum,
+    sim_ppc_spr500_regnum, sim_ppc_spr501_regnum,
+    sim_ppc_spr502_regnum, sim_ppc_spr503_regnum,
+    sim_ppc_spr504_regnum, sim_ppc_spr505_regnum,
+    sim_ppc_spr506_regnum, sim_ppc_spr507_regnum,
+    sim_ppc_spr508_regnum, sim_ppc_spr509_regnum,
+    sim_ppc_spr510_regnum, sim_ppc_spr511_regnum,
+    sim_ppc_spr512_regnum, sim_ppc_spr513_regnum,
+    sim_ppc_spr514_regnum, sim_ppc_spr515_regnum,
+    sim_ppc_spr516_regnum, sim_ppc_spr517_regnum,
+    sim_ppc_spr518_regnum, sim_ppc_spr519_regnum,
+    sim_ppc_spr520_regnum, sim_ppc_spr521_regnum,
+    sim_ppc_spr522_regnum, sim_ppc_spr523_regnum,
+    sim_ppc_spr524_regnum, sim_ppc_spr525_regnum,
+    sim_ppc_spr526_regnum, sim_ppc_spr527_regnum,
+    sim_ppc_spr528_regnum, sim_ppc_spr529_regnum,
+    sim_ppc_spr530_regnum, sim_ppc_spr531_regnum,
+    sim_ppc_spr532_regnum, sim_ppc_spr533_regnum,
+    sim_ppc_spr534_regnum, sim_ppc_spr535_regnum,
+    sim_ppc_spr536_regnum, sim_ppc_spr537_regnum,
+    sim_ppc_spr538_regnum, sim_ppc_spr539_regnum,
+    sim_ppc_spr540_regnum, sim_ppc_spr541_regnum,
+    sim_ppc_spr542_regnum, sim_ppc_spr543_regnum,
+    sim_ppc_spr544_regnum, sim_ppc_spr545_regnum,
+    sim_ppc_spr546_regnum, sim_ppc_spr547_regnum,
+    sim_ppc_spr548_regnum, sim_ppc_spr549_regnum,
+    sim_ppc_spr550_regnum, sim_ppc_spr551_regnum,
+    sim_ppc_spr552_regnum, sim_ppc_spr553_regnum,
+    sim_ppc_spr554_regnum, sim_ppc_spr555_regnum,
+    sim_ppc_spr556_regnum, sim_ppc_spr557_regnum,
+    sim_ppc_spr558_regnum, sim_ppc_spr559_regnum,
+    sim_ppc_spr560_regnum, sim_ppc_spr561_regnum,
+    sim_ppc_spr562_regnum, sim_ppc_spr563_regnum,
+    sim_ppc_spr564_regnum, sim_ppc_spr565_regnum,
+    sim_ppc_spr566_regnum, sim_ppc_spr567_regnum,
+    sim_ppc_spr568_regnum, sim_ppc_spr569_regnum,
+    sim_ppc_spr570_regnum, sim_ppc_spr571_regnum,
+    sim_ppc_spr572_regnum, sim_ppc_spr573_regnum,
+    sim_ppc_spr574_regnum, sim_ppc_spr575_regnum,
+    sim_ppc_spr576_regnum, sim_ppc_spr577_regnum,
+    sim_ppc_spr578_regnum, sim_ppc_spr579_regnum,
+    sim_ppc_spr580_regnum, sim_ppc_spr581_regnum,
+    sim_ppc_spr582_regnum, sim_ppc_spr583_regnum,
+    sim_ppc_spr584_regnum, sim_ppc_spr585_regnum,
+    sim_ppc_spr586_regnum, sim_ppc_spr587_regnum,
+    sim_ppc_spr588_regnum, sim_ppc_spr589_regnum,
+    sim_ppc_spr590_regnum, sim_ppc_spr591_regnum,
+    sim_ppc_spr592_regnum, sim_ppc_spr593_regnum,
+    sim_ppc_spr594_regnum, sim_ppc_spr595_regnum,
+    sim_ppc_spr596_regnum, sim_ppc_spr597_regnum,
+    sim_ppc_spr598_regnum, sim_ppc_spr599_regnum,
+    sim_ppc_spr600_regnum, sim_ppc_spr601_regnum,
+    sim_ppc_spr602_regnum, sim_ppc_spr603_regnum,
+    sim_ppc_spr604_regnum, sim_ppc_spr605_regnum,
+    sim_ppc_spr606_regnum, sim_ppc_spr607_regnum,
+    sim_ppc_spr608_regnum, sim_ppc_spr609_regnum,
+    sim_ppc_spr610_regnum, sim_ppc_spr611_regnum,
+    sim_ppc_spr612_regnum, sim_ppc_spr613_regnum,
+    sim_ppc_spr614_regnum, sim_ppc_spr615_regnum,
+    sim_ppc_spr616_regnum, sim_ppc_spr617_regnum,
+    sim_ppc_spr618_regnum, sim_ppc_spr619_regnum,
+    sim_ppc_spr620_regnum, sim_ppc_spr621_regnum,
+    sim_ppc_spr622_regnum, sim_ppc_spr623_regnum,
+    sim_ppc_spr624_regnum, sim_ppc_spr625_regnum,
+    sim_ppc_spr626_regnum, sim_ppc_spr627_regnum,
+    sim_ppc_spr628_regnum, sim_ppc_spr629_regnum,
+    sim_ppc_spr630_regnum, sim_ppc_spr631_regnum,
+    sim_ppc_spr632_regnum, sim_ppc_spr633_regnum,
+    sim_ppc_spr634_regnum, sim_ppc_spr635_regnum,
+    sim_ppc_spr636_regnum, sim_ppc_spr637_regnum,
+    sim_ppc_spr638_regnum, sim_ppc_spr639_regnum,
+    sim_ppc_spr640_regnum, sim_ppc_spr641_regnum,
+    sim_ppc_spr642_regnum, sim_ppc_spr643_regnum,
+    sim_ppc_spr644_regnum, sim_ppc_spr645_regnum,
+    sim_ppc_spr646_regnum, sim_ppc_spr647_regnum,
+    sim_ppc_spr648_regnum, sim_ppc_spr649_regnum,
+    sim_ppc_spr650_regnum, sim_ppc_spr651_regnum,
+    sim_ppc_spr652_regnum, sim_ppc_spr653_regnum,
+    sim_ppc_spr654_regnum, sim_ppc_spr655_regnum,
+    sim_ppc_spr656_regnum, sim_ppc_spr657_regnum,
+    sim_ppc_spr658_regnum, sim_ppc_spr659_regnum,
+    sim_ppc_spr660_regnum, sim_ppc_spr661_regnum,
+    sim_ppc_spr662_regnum, sim_ppc_spr663_regnum,
+    sim_ppc_spr664_regnum, sim_ppc_spr665_regnum,
+    sim_ppc_spr666_regnum, sim_ppc_spr667_regnum,
+    sim_ppc_spr668_regnum, sim_ppc_spr669_regnum,
+    sim_ppc_spr670_regnum, sim_ppc_spr671_regnum,
+    sim_ppc_spr672_regnum, sim_ppc_spr673_regnum,
+    sim_ppc_spr674_regnum, sim_ppc_spr675_regnum,
+    sim_ppc_spr676_regnum, sim_ppc_spr677_regnum,
+    sim_ppc_spr678_regnum, sim_ppc_spr679_regnum,
+    sim_ppc_spr680_regnum, sim_ppc_spr681_regnum,
+    sim_ppc_spr682_regnum, sim_ppc_spr683_regnum,
+    sim_ppc_spr684_regnum, sim_ppc_spr685_regnum,
+    sim_ppc_spr686_regnum, sim_ppc_spr687_regnum,
+    sim_ppc_spr688_regnum, sim_ppc_spr689_regnum,
+    sim_ppc_spr690_regnum, sim_ppc_spr691_regnum,
+    sim_ppc_spr692_regnum, sim_ppc_spr693_regnum,
+    sim_ppc_spr694_regnum, sim_ppc_spr695_regnum,
+    sim_ppc_spr696_regnum, sim_ppc_spr697_regnum,
+    sim_ppc_spr698_regnum, sim_ppc_spr699_regnum,
+    sim_ppc_spr700_regnum, sim_ppc_spr701_regnum,
+    sim_ppc_spr702_regnum, sim_ppc_spr703_regnum,
+    sim_ppc_spr704_regnum, sim_ppc_spr705_regnum,
+    sim_ppc_spr706_regnum, sim_ppc_spr707_regnum,
+    sim_ppc_spr708_regnum, sim_ppc_spr709_regnum,
+    sim_ppc_spr710_regnum, sim_ppc_spr711_regnum,
+    sim_ppc_spr712_regnum, sim_ppc_spr713_regnum,
+    sim_ppc_spr714_regnum, sim_ppc_spr715_regnum,
+    sim_ppc_spr716_regnum, sim_ppc_spr717_regnum,
+    sim_ppc_spr718_regnum, sim_ppc_spr719_regnum,
+    sim_ppc_spr720_regnum, sim_ppc_spr721_regnum,
+    sim_ppc_spr722_regnum, sim_ppc_spr723_regnum,
+    sim_ppc_spr724_regnum, sim_ppc_spr725_regnum,
+    sim_ppc_spr726_regnum, sim_ppc_spr727_regnum,
+    sim_ppc_spr728_regnum, sim_ppc_spr729_regnum,
+    sim_ppc_spr730_regnum, sim_ppc_spr731_regnum,
+    sim_ppc_spr732_regnum, sim_ppc_spr733_regnum,
+    sim_ppc_spr734_regnum, sim_ppc_spr735_regnum,
+    sim_ppc_spr736_regnum, sim_ppc_spr737_regnum,
+    sim_ppc_spr738_regnum, sim_ppc_spr739_regnum,
+    sim_ppc_spr740_regnum, sim_ppc_spr741_regnum,
+    sim_ppc_spr742_regnum, sim_ppc_spr743_regnum,
+    sim_ppc_spr744_regnum, sim_ppc_spr745_regnum,
+    sim_ppc_spr746_regnum, sim_ppc_spr747_regnum,
+    sim_ppc_spr748_regnum, sim_ppc_spr749_regnum,
+    sim_ppc_spr750_regnum, sim_ppc_spr751_regnum,
+    sim_ppc_spr752_regnum, sim_ppc_spr753_regnum,
+    sim_ppc_spr754_regnum, sim_ppc_spr755_regnum,
+    sim_ppc_spr756_regnum, sim_ppc_spr757_regnum,
+    sim_ppc_spr758_regnum, sim_ppc_spr759_regnum,
+    sim_ppc_spr760_regnum, sim_ppc_spr761_regnum,
+    sim_ppc_spr762_regnum, sim_ppc_spr763_regnum,
+    sim_ppc_spr764_regnum, sim_ppc_spr765_regnum,
+    sim_ppc_spr766_regnum, sim_ppc_spr767_regnum,
+    sim_ppc_spr768_regnum, sim_ppc_spr769_regnum,
+    sim_ppc_spr770_regnum, sim_ppc_spr771_regnum,
+    sim_ppc_spr772_regnum, sim_ppc_spr773_regnum,
+    sim_ppc_spr774_regnum, sim_ppc_spr775_regnum,
+    sim_ppc_spr776_regnum, sim_ppc_spr777_regnum,
+    sim_ppc_spr778_regnum, sim_ppc_spr779_regnum,
+    sim_ppc_spr780_regnum, sim_ppc_spr781_regnum,
+    sim_ppc_spr782_regnum, sim_ppc_spr783_regnum,
+    sim_ppc_spr784_regnum, sim_ppc_spr785_regnum,
+    sim_ppc_spr786_regnum, sim_ppc_spr787_regnum,
+    sim_ppc_spr788_regnum, sim_ppc_spr789_regnum,
+    sim_ppc_spr790_regnum, sim_ppc_spr791_regnum,
+    sim_ppc_spr792_regnum, sim_ppc_spr793_regnum,
+    sim_ppc_spr794_regnum, sim_ppc_spr795_regnum,
+    sim_ppc_spr796_regnum, sim_ppc_spr797_regnum,
+    sim_ppc_spr798_regnum, sim_ppc_spr799_regnum,
+    sim_ppc_spr800_regnum, sim_ppc_spr801_regnum,
+    sim_ppc_spr802_regnum, sim_ppc_spr803_regnum,
+    sim_ppc_spr804_regnum, sim_ppc_spr805_regnum,
+    sim_ppc_spr806_regnum, sim_ppc_spr807_regnum,
+    sim_ppc_spr808_regnum, sim_ppc_spr809_regnum,
+    sim_ppc_spr810_regnum, sim_ppc_spr811_regnum,
+    sim_ppc_spr812_regnum, sim_ppc_spr813_regnum,
+    sim_ppc_spr814_regnum, sim_ppc_spr815_regnum,
+    sim_ppc_spr816_regnum, sim_ppc_spr817_regnum,
+    sim_ppc_spr818_regnum, sim_ppc_spr819_regnum,
+    sim_ppc_spr820_regnum, sim_ppc_spr821_regnum,
+    sim_ppc_spr822_regnum, sim_ppc_spr823_regnum,
+    sim_ppc_spr824_regnum, sim_ppc_spr825_regnum,
+    sim_ppc_spr826_regnum, sim_ppc_spr827_regnum,
+    sim_ppc_spr828_regnum, sim_ppc_spr829_regnum,
+    sim_ppc_spr830_regnum, sim_ppc_spr831_regnum,
+    sim_ppc_spr832_regnum, sim_ppc_spr833_regnum,
+    sim_ppc_spr834_regnum, sim_ppc_spr835_regnum,
+    sim_ppc_spr836_regnum, sim_ppc_spr837_regnum,
+    sim_ppc_spr838_regnum, sim_ppc_spr839_regnum,
+    sim_ppc_spr840_regnum, sim_ppc_spr841_regnum,
+    sim_ppc_spr842_regnum, sim_ppc_spr843_regnum,
+    sim_ppc_spr844_regnum, sim_ppc_spr845_regnum,
+    sim_ppc_spr846_regnum, sim_ppc_spr847_regnum,
+    sim_ppc_spr848_regnum, sim_ppc_spr849_regnum,
+    sim_ppc_spr850_regnum, sim_ppc_spr851_regnum,
+    sim_ppc_spr852_regnum, sim_ppc_spr853_regnum,
+    sim_ppc_spr854_regnum, sim_ppc_spr855_regnum,
+    sim_ppc_spr856_regnum, sim_ppc_spr857_regnum,
+    sim_ppc_spr858_regnum, sim_ppc_spr859_regnum,
+    sim_ppc_spr860_regnum, sim_ppc_spr861_regnum,
+    sim_ppc_spr862_regnum, sim_ppc_spr863_regnum,
+    sim_ppc_spr864_regnum, sim_ppc_spr865_regnum,
+    sim_ppc_spr866_regnum, sim_ppc_spr867_regnum,
+    sim_ppc_spr868_regnum, sim_ppc_spr869_regnum,
+    sim_ppc_spr870_regnum, sim_ppc_spr871_regnum,
+    sim_ppc_spr872_regnum, sim_ppc_spr873_regnum,
+    sim_ppc_spr874_regnum, sim_ppc_spr875_regnum,
+    sim_ppc_spr876_regnum, sim_ppc_spr877_regnum,
+    sim_ppc_spr878_regnum, sim_ppc_spr879_regnum,
+    sim_ppc_spr880_regnum, sim_ppc_spr881_regnum,
+    sim_ppc_spr882_regnum, sim_ppc_spr883_regnum,
+    sim_ppc_spr884_regnum, sim_ppc_spr885_regnum,
+    sim_ppc_spr886_regnum, sim_ppc_spr887_regnum,
+    sim_ppc_spr888_regnum, sim_ppc_spr889_regnum,
+    sim_ppc_spr890_regnum, sim_ppc_spr891_regnum,
+    sim_ppc_spr892_regnum, sim_ppc_spr893_regnum,
+    sim_ppc_spr894_regnum, sim_ppc_spr895_regnum,
+    sim_ppc_spr896_regnum, sim_ppc_spr897_regnum,
+    sim_ppc_spr898_regnum, sim_ppc_spr899_regnum,
+    sim_ppc_spr900_regnum, sim_ppc_spr901_regnum,
+    sim_ppc_spr902_regnum, sim_ppc_spr903_regnum,
+    sim_ppc_spr904_regnum, sim_ppc_spr905_regnum,
+    sim_ppc_spr906_regnum, sim_ppc_spr907_regnum,
+    sim_ppc_spr908_regnum, sim_ppc_spr909_regnum,
+    sim_ppc_spr910_regnum, sim_ppc_spr911_regnum,
+    sim_ppc_spr912_regnum, sim_ppc_spr913_regnum,
+    sim_ppc_spr914_regnum, sim_ppc_spr915_regnum,
+    sim_ppc_spr916_regnum, sim_ppc_spr917_regnum,
+    sim_ppc_spr918_regnum, sim_ppc_spr919_regnum,
+    sim_ppc_spr920_regnum, sim_ppc_spr921_regnum,
+    sim_ppc_spr922_regnum, sim_ppc_spr923_regnum,
+    sim_ppc_spr924_regnum, sim_ppc_spr925_regnum,
+    sim_ppc_spr926_regnum, sim_ppc_spr927_regnum,
+    sim_ppc_spr928_regnum, sim_ppc_spr929_regnum,
+    sim_ppc_spr930_regnum, sim_ppc_spr931_regnum,
+    sim_ppc_spr932_regnum, sim_ppc_spr933_regnum,
+    sim_ppc_spr934_regnum, sim_ppc_spr935_regnum,
+    sim_ppc_spr936_regnum, sim_ppc_spr937_regnum,
+    sim_ppc_spr938_regnum, sim_ppc_spr939_regnum,
+    sim_ppc_spr940_regnum, sim_ppc_spr941_regnum,
+    sim_ppc_spr942_regnum, sim_ppc_spr943_regnum,
+    sim_ppc_spr944_regnum, sim_ppc_spr945_regnum,
+    sim_ppc_spr946_regnum, sim_ppc_spr947_regnum,
+    sim_ppc_spr948_regnum, sim_ppc_spr949_regnum,
+    sim_ppc_spr950_regnum, sim_ppc_spr951_regnum,
+    sim_ppc_spr952_regnum, sim_ppc_spr953_regnum,
+    sim_ppc_spr954_regnum, sim_ppc_spr955_regnum,
+    sim_ppc_spr956_regnum, sim_ppc_spr957_regnum,
+    sim_ppc_spr958_regnum, sim_ppc_spr959_regnum,
+    sim_ppc_spr960_regnum, sim_ppc_spr961_regnum,
+    sim_ppc_spr962_regnum, sim_ppc_spr963_regnum,
+    sim_ppc_spr964_regnum, sim_ppc_spr965_regnum,
+    sim_ppc_spr966_regnum, sim_ppc_spr967_regnum,
+    sim_ppc_spr968_regnum, sim_ppc_spr969_regnum,
+    sim_ppc_spr970_regnum, sim_ppc_spr971_regnum,
+    sim_ppc_spr972_regnum, sim_ppc_spr973_regnum,
+    sim_ppc_spr974_regnum, sim_ppc_spr975_regnum,
+    sim_ppc_spr976_regnum, sim_ppc_spr977_regnum,
+    sim_ppc_spr978_regnum, sim_ppc_spr979_regnum,
+    sim_ppc_spr980_regnum, sim_ppc_spr981_regnum,
+    sim_ppc_spr982_regnum, sim_ppc_spr983_regnum,
+    sim_ppc_spr984_regnum, sim_ppc_spr985_regnum,
+    sim_ppc_spr986_regnum, sim_ppc_spr987_regnum,
+    sim_ppc_spr988_regnum, sim_ppc_spr989_regnum,
+    sim_ppc_spr990_regnum, sim_ppc_spr991_regnum,
+    sim_ppc_spr992_regnum, sim_ppc_spr993_regnum,
+    sim_ppc_spr994_regnum, sim_ppc_spr995_regnum,
+    sim_ppc_spr996_regnum, sim_ppc_spr997_regnum,
+    sim_ppc_spr998_regnum, sim_ppc_spr999_regnum,
+    sim_ppc_spr1000_regnum, sim_ppc_spr1001_regnum,
+    sim_ppc_spr1002_regnum, sim_ppc_spr1003_regnum,
+    sim_ppc_spr1004_regnum, sim_ppc_spr1005_regnum,
+    sim_ppc_spr1006_regnum, sim_ppc_spr1007_regnum,
+    sim_ppc_spr1008_regnum, sim_ppc_spr1009_regnum,
+    sim_ppc_spr1010_regnum, sim_ppc_spr1011_regnum,
+    sim_ppc_spr1012_regnum, sim_ppc_spr1013_regnum,
+    sim_ppc_spr1014_regnum, sim_ppc_spr1015_regnum,
+    sim_ppc_spr1016_regnum, sim_ppc_spr1017_regnum,
+    sim_ppc_spr1018_regnum, sim_ppc_spr1019_regnum,
+    sim_ppc_spr1020_regnum, sim_ppc_spr1021_regnum,
+    sim_ppc_spr1022_regnum, sim_ppc_spr1023_regnum
+  };
+
+
+/* Sizes of various register sets.  */
+enum
+  {
+    sim_ppc_num_gprs = 32,
+    sim_ppc_num_fprs = 32,
+    sim_ppc_num_vrs = 32,
+    sim_ppc_num_srs = 16,
+    sim_ppc_num_sprs = 1024,
+  };
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SIM_PPC_H */
--- binutils-2.15.orig/include/gdb/sim-sh.h
+++ binutils-2.15/include/gdb/sim-sh.h
@@ -1,5 +1,5 @@
 /* This file defines the interface between the sh simulator and gdb.
-   Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2002, 2004 Free Software Foundation, Inc.
 
 This file is part of GDB.
 
@@ -129,8 +129,17 @@
   SIM_SH_R4_BANK_REGNUM,
   SIM_SH_R5_BANK_REGNUM,
   SIM_SH_R6_BANK_REGNUM,
-  SIM_SH_R7_BANK_REGNUM
-  /* 100..127: room for expansion.  */
+  SIM_SH_R7_BANK_REGNUM,
+  /* 109..127: room for expansion.  */
+  SIM_SH_TBR_REGNUM,
+  SIM_SH_IBNR_REGNUM,
+  SIM_SH_IBCR_REGNUM,
+  SIM_SH_BANK_REGNUM,
+  SIM_SH_BANK_MACL_REGNUM,
+  SIM_SH_BANK_GBR_REGNUM,
+  SIM_SH_BANK_PR_REGNUM,
+  SIM_SH_BANK_IVN_REGNUM,
+  SIM_SH_BANK_MACH_REGNUM
 };
 
 enum
--- binutils-2.15.orig/include/opcode/i386.h
+++ binutils-2.15/include/opcode/i386.h
@@ -908,6 +908,13 @@
 /* 2nd. official undefined instr. */
 {"ud2b",    0, 0x0fb9, X, Cpu686, NoSuf,		{ 0, 0, 0} },
 
+/* VIA C3 extensions */
+{"xstore-rng",0, 0x0fa7, 0xc0, Cpu686, ImmExt|NoSuf|IsString,  { 0, 0, 0} },
+{"xcrypt-ecb",0, 0x0fa7, 0xc8, Cpu686, ImmExt|NoSuf|IsString,  { 0, 0, 0} },
+{"xcrypt-cbc",0, 0x0fa7, 0xd0, Cpu686, ImmExt|NoSuf|IsString,  { 0, 0, 0} },
+{"xcrypt-cfb",0, 0x0fa7, 0xe0, Cpu686, ImmExt|NoSuf|IsString,  { 0, 0, 0} },
+{"xcrypt-ofb",0, 0x0fa7, 0xe8, Cpu686, ImmExt|NoSuf|IsString,  { 0, 0, 0} },
+
 {"cmovo",   2, 0x0f40, X, Cpu686, wlq_Suf|Modrm,	{ WordReg|WordMem, WordReg, 0} },
 {"cmovno",  2, 0x0f41, X, Cpu686, wlq_Suf|Modrm,	{ WordReg|WordMem, WordReg, 0} },
 {"cmovb",   2, 0x0f42, X, Cpu686, wlq_Suf|Modrm,	{ WordReg|WordMem, WordReg, 0} },
--- binutils-2.15.orig/include/wait.h
+++ binutils-2.15/include/wait.h
@@ -0,0 +1,63 @@
+/* Define how to access the int that the wait system call stores.
+   This has been compatible in all Unix systems since time immemorial,
+   but various well-meaning people have defined various different
+   words for the same old bits in the same old int (sometimes claimed
+   to be a struct).  We just know it's an int and we use these macros
+   to access the bits.  */
+
+/* The following macros are defined equivalently to their definitions
+   in POSIX.1.  We fail to define WNOHANG and WUNTRACED, which POSIX.1
+   <sys/wait.h> defines, since our code does not use waitpid().  We
+   also fail to declare wait() and waitpid().  */   
+
+#ifndef	WIFEXITED
+#define WIFEXITED(w)	(((w)&0377) == 0)
+#endif
+
+#ifndef	WIFSIGNALED
+#define WIFSIGNALED(w)	(((w)&0377) != 0177 && ((w)&~0377) == 0)
+#endif
+
+#ifndef	WIFSTOPPED
+#ifdef IBM6000
+
+/* Unfortunately, the above comment (about being compatible in all Unix 
+   systems) is not quite correct for AIX, sigh.  And AIX 3.2 can generate
+   status words like 0x57c (sigtrap received after load), and gdb would
+   choke on it. */
+
+#define WIFSTOPPED(w)	((w)&0x40)
+
+#else
+#define WIFSTOPPED(w)	(((w)&0377) == 0177)
+#endif
+#endif
+
+#ifndef	WEXITSTATUS
+#define WEXITSTATUS(w)	(((w) >> 8) & 0377) /* same as WRETCODE */
+#endif
+
+#ifndef	WTERMSIG
+#define WTERMSIG(w)	((w) & 0177)
+#endif
+
+#ifndef	WSTOPSIG
+#define WSTOPSIG	WEXITSTATUS
+#endif
+
+/* These are not defined in POSIX, but are used by our programs.  */
+
+#define WAITTYPE	int
+
+#ifndef	WCOREDUMP
+#define WCOREDUMP(w)	(((w)&0200) != 0)
+#endif
+
+#ifndef	WSETEXIT
+#define WSETEXIT(w,status) ((w) = (0 | ((status) << 8)))
+#endif
+
+#ifndef	WSETSTOP
+#define WSETSTOP(w,sig)	   ((w) = (0177 | ((sig) << 8)))
+#endif
+
--- binutils-2.15.orig/ld/Makefile.am
+++ binutils-2.15/ld/Makefile.am
@@ -105,7 +105,7 @@
 INCLUDES = -D_GNU_SOURCE -I. -I$(srcdir) -I../bfd -I$(BFDDIR) -I$(INCDIR) -I$(top_srcdir)/../intl -I../intl $(HDEFINES) $(CFLAGS) -DLOCALEDIR="\"$(prefix)/share/locale\""
 
 BFDLIB = ../bfd/libbfd.la
-LIBIBERTY = ../libiberty/libiberty.a
+LIBIBERTY = -libiberty
 
 ALL_EMULATIONS = \
 	ea29k.o \
@@ -124,6 +124,8 @@
 	earmelfb_linux.o \
 	earmelf_nbsd.o \
 	earmelfb_nbsd.o \
+	earmelf_obsd.o \
+	earmelfb_obsd.o \
 	earmelf_oabi.o \
 	earmnto.o \
 	earmnbsd.o \
@@ -148,6 +150,7 @@
 	eelf32_i960.o \
 	eelf32_i860.o \
 	eelf32_sparc.o \
+	eelf32_sparc_obsd.o \
 	eelf32b4300.o \
 	eelf32bmip.o \
 	eelf32bmipn32.o \
@@ -173,6 +176,7 @@
 	eelf32openrisc.o \
 	eelf32ppc.o \
 	eelf32ppc_fbsd.o \
+	eelf32ppc_obsd.o \
 	eelf32ppclinux.o \
 	eelf32ppcnto.o \
 	eelf32ppcsim.o \
@@ -184,6 +188,7 @@
 	eelf_i386_be.o \
 	eelf_i386_chaos.o \
 	eelf_i386_fbsd.o \
+	eelf_i386_obsd.o \
 	eelf_i386_ldso.o \
 	eelf_s390.o \
 	egld960.o \
@@ -226,6 +231,7 @@
 	ei386nbsd.o \
 	ei386nto.o \
 	ei386nw.o \
+	ei386obsd.o \
 	ei386pe.o \
 	ei386pe_posix.o \
 	elnk960.o \
@@ -246,6 +252,7 @@
 	em68klinux.o \
 	em68klynx.o \
 	em68knbsd.o \
+	em68kobsd.o \
 	em68kpsos.o \
 	em88kbcs.o \
 	emcorepe.o \
@@ -337,6 +344,7 @@
 	esparclinux.o \
 	esparclynx.o \
 	esparcnbsd.o \
+	esparcobsd.o \
 	est2000.o \
 	esun3.o \
 	esun4.o \
@@ -366,15 +374,20 @@
 	eshlelf64_nbsd.o \
 	eelf_x86_64.o \
 	eelf_x86_64_fbsd.o \
+	eelf_x86_64_obsd.o \
 	eelf64_s390.o \
 	eelf64_sparc.o \
 	eelf64_sparc_fbsd.o \
+	eelf64_sparc_obsd.o \
 	eelf64alpha.o \
 	eelf64alpha_fbsd.o \
 	eelf64alpha_nbsd.o \
+	eelf64alpha_obsd.o \
 	eelf64bmip.o \
 	eelf64btsmip.o \
+	eelf64btsmip_obsd.o \
 	eelf64ltsmip.o \
+	eelf64ltsmip_obsd.o \
 	eelf64hppa.o \
 	eelf64mmix.o \
 	emmo.o \
@@ -502,6 +515,17 @@
   $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/armelf.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} armelfb_nbsd "$(tdir_armelfb_nbsd)"
+earmelf_obsd.c: $(srcdir)/emulparams/armelf_obsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_obsd "$(tdir_armelf_obsd)"
+earmelfb_obsd.c: $(srcdir)/emulparams/armelfb_obsd.sh \
+  $(srcdir)/emulparams/armelf_obsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb_obsd "$(tdir_armelfb_obsd)"
 earmaoutb.c:	$(srcdir)/emulparams/armaoutb.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} armaoutb "$(tdir_armaoutb)"
@@ -619,6 +643,9 @@
 eelf32_sparc.c: $(srcdir)/emulparams/elf32_sparc.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32_sparc "$(tdir_elf32_sparc)"
+eelf32_sparc_obsd.c: $(srcdir)/emulparams/elf32_sparc_obsd.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_sparc_obsd "$(tdir_elf32_sparc_obsd)"
 eelf32_i860.c: $(srcdir)/emulparams/elf32_i860.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32_i860 "$(tdir_elf32_i860)"
@@ -715,6 +742,10 @@
   $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emultempl/ppc32elf.em \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32ppc_fbsd "$(tdir_elf32ppc_fbsd)"
+eelf32ppc_obsd.c: $(srcdir)/emulparams/elf32ppc_obsd.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emultempl/ppc32elf.em \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppc_obsd "$(tdir_elf32ppc_obsd)"
 eelf32ppcsim.c: $(srcdir)/emulparams/elf32ppcsim.sh \
   $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emultempl/ppc32elf.em \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
@@ -749,6 +780,10 @@
   $(srcdir)/emulparams/elf64alpha.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64alpha_fbsd "$(tdir_elf64alpha_fbsd)"
+eelf64alpha_obsd.c: $(srcdir)/emulparams/elf64alpha_obsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64alpha_obsd "$(tdir_elf64alpha_obsd)"
 eelf64alpha_nbsd.c: $(srcdir)/emulparams/elf64alpha_nbsd.sh \
   $(srcdir)/emulparams/elf64alpha.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
@@ -781,6 +816,10 @@
   $(srcdir)/emulparams/elf64_sparc.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64_sparc_fbsd "$(tdir_elf64_sparc_fbsd)"
+eelf64_sparc_obsd.c: $(srcdir)/emulparams/elf64_sparc_obsd.sh \
+  $(srcdir)/emulparams/elf64_sparc.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_sparc_obsd "$(tdir_elf64_sparc_obsd)"
 eelf64bmip.c: $(srcdir)/emulparams/elf64bmip.sh \
   $(srcdir)/emulparams/elf32bmipn32.sh $(srcdir)/emultempl/irix.em \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
@@ -797,10 +836,18 @@
   $(srcdir)/emulparams/elf32bmipn32.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64btsmip "$(tdir_elf64btsmip)"
+eelf64btsmip_obsd.c: $(srcdir)/emulparams/elf64btsmip_obsd.sh \
+  $(srcdir)/emulparams/elf32bmipn32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64btsmip_obsd "$(tdir_elf64btsmip_obsd)"
 eelf64ltsmip.c: $(srcdir)/emulparams/elf64ltsmip.sh \
   $(srcdir)/emulparams/elf64btsmip.sh $(srcdir)/emulparams/elf32bmipn32.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64ltsmip "$(tdir_elf64ltsmip)"
+eelf64ltsmip_obsd.c: $(srcdir)/emulparams/elf64ltsmip_obsd.sh \
+  $(srcdir)/emulparams/elf32bmipn32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64ltsmip_obsd "$(tdir_elf64ltsmip_obsd)"
 eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386 "$(tdir_elf_i386)"
@@ -811,6 +858,10 @@
   $(srcdir)/emulparams/elf_x86_64.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_x86_64_fbsd "$(tdir_elf_x86_64_fbsd)"
+eelf_x86_64_obsd.c: $(srcdir)/emulparams/elf_x86_64_obsd.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_x86_64_obsd "$(tdir_elf_x86_64_obsd)"
 eelf_i386_be.c: $(srcdir)/emulparams/elf_i386_be.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386_be "$(tdir_elf_i386_be)"
@@ -821,6 +872,10 @@
   $(srcdir)/emulparams/elf_i386.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386_fbsd "$(tdir_elf_i386_fbsd)"
+eelf_i386_obsd.c: $(srcdir)/emulparams/elf_i386_obsd.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_obsd "$(tdir_elf_i386_obsd)"
 eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386_ldso "$(tdir_elf_i386_ldso)"
@@ -961,6 +1016,9 @@
 ei386nw.c:	$(srcdir)/emulparams/i386nw.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} i386nw "$(tdir_i386nw)"
+ei386obsd.c:	$(srcdir)/emulparams/i386obsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386obsd "$(tdir_i386obsd)"
 ei386pe.c: $(srcdir)/emulparams/i386pe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} i386pe "$(tdir_i386pe)"
@@ -1016,6 +1074,9 @@
 em68knbsd.c:	$(srcdir)/emulparams/m68knbsd.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} m68knbsd "$(tdir_m68knbsd)"
+em68kobsd.c:	$(srcdir)/emulparams/m68kobsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kobsd "$(tdir_m68kobsd)"
 em68kpsos.c:	$(srcdir)/emulparams/m68kpsos.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/psos.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} m68kpsos "$(tdir_m68kpsos)"
@@ -1382,6 +1443,9 @@
 esparcnbsd.c:	$(srcdir)/emulparams/sparcnbsd.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} sparcnbsd "$(tdir_sparcnbsd)"
+esparcobsd.c:	$(srcdir)/emulparams/sparcobsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sparcobsd "$(tdir_sparcobsd)"
 est2000.c: $(srcdir)/emulparams/st2000.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/st2000.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} st2000 "$(tdir_st2000)"
@@ -1446,7 +1510,7 @@
 
 ld_new_SOURCES = ldgram.y ldlex.l lexsup.c ldlang.c mri.c ldctor.c ldmain.c \
 	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c
-ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(INTLDEPS)
+ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(INTLDEPS)
 ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(INTLLIBS)
 
 # The generated emulation files mostly have the same dependencies.
@@ -1582,7 +1646,7 @@
 	$(mkinstalldirs) $(DESTDIR)$(bindir) $(DESTDIR)$(tooldir)/bin
 	@list='$(noinst_PROGRAMS)'; for p in $$list; do \
 	  if test -f $$p; then \
-	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
+	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
 	    $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
 	  else :; fi; \
 	done
--- binutils-2.15.orig/ld/Makefile.in
+++ binutils-2.15/ld/Makefile.in
@@ -219,7 +219,7 @@
 INCLUDES = -D_GNU_SOURCE -I. -I$(srcdir) -I../bfd -I$(BFDDIR) -I$(INCDIR) -I$(top_srcdir)/../intl -I../intl $(HDEFINES) $(CFLAGS) -DLOCALEDIR="\"$(prefix)/share/locale\""
 
 BFDLIB = ../bfd/libbfd.la
-LIBIBERTY = ../libiberty/libiberty.a
+LIBIBERTY = -liberty
 
 ALL_EMULATIONS = \
 	ea29k.o \
@@ -239,6 +239,8 @@
 	earmelf_nbsd.o \
 	earmelfb_nbsd.o \
 	earmelf_oabi.o \
+	earmelf_obsd.o \
+	earmelfb_obsd.o \
 	earmnto.o \
 	earmnbsd.o \
 	earmpe.o \
@@ -262,6 +264,7 @@
 	eelf32_i960.o \
 	eelf32_i860.o \
 	eelf32_sparc.o \
+	eelf32_sparc_obsd.o \
 	eelf32b4300.o \
 	eelf32bmip.o \
 	eelf32bmipn32.o \
@@ -287,6 +290,7 @@
 	eelf32openrisc.o \
 	eelf32ppc.o \
 	eelf32ppc_fbsd.o \
+	eelf32ppc_obsd.o \
 	eelf32ppclinux.o \
 	eelf32ppcnto.o \
 	eelf32ppcsim.o \
@@ -299,6 +303,7 @@
 	eelf_i386_chaos.o \
 	eelf_i386_fbsd.o \
 	eelf_i386_ldso.o \
+	eelf_i386_obsd.o \
 	eelf_s390.o \
 	egld960.o \
 	egld960coff.o \
@@ -338,6 +343,7 @@
 	ei386moss.o \
 	ei386msdos.o \
 	ei386nbsd.o \
+	ei386obsd.o \
 	ei386nto.o \
 	ei386nw.o \
 	ei386pe.o \
@@ -360,6 +366,7 @@
 	em68klinux.o \
 	em68klynx.o \
 	em68knbsd.o \
+	em68kobsd.o \
 	em68kpsos.o \
 	em88kbcs.o \
 	emcorepe.o \
@@ -451,6 +458,7 @@
 	esparclinux.o \
 	esparclynx.o \
 	esparcnbsd.o \
+	esparcobsd.o \
 	est2000.o \
 	esun3.o \
 	esun4.o \
@@ -481,15 +489,20 @@
 	eshlelf64_nbsd.o \
 	eelf_x86_64.o \
 	eelf_x86_64_fbsd.o \
+	eelf_x86_64_obsd.o \
 	eelf64_s390.o \
 	eelf64_sparc.o \
 	eelf64_sparc_fbsd.o \
+	eelf64_sparc_obsd.o \
 	eelf64alpha.o \
 	eelf64alpha_fbsd.o \
 	eelf64alpha_nbsd.o \
+	eelf64alpha_obsd.o \
 	eelf64bmip.o \
 	eelf64btsmip.o \
+	eelf64btsmip_obsd.o \
 	eelf64ltsmip.o \
+	eelf64ltsmip_obsd.o \
 	eelf64hppa.o \
 	eelf64mmix.o \
 	emmo.o \
@@ -540,7 +553,7 @@
 ld_new_SOURCES = ldgram.y ldlex.l lexsup.c ldlang.c mri.c ldctor.c ldmain.c \
 	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c
 
-ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(INTLDEPS)
+ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(INTLDEPS)
 ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(INTLLIBS)
 
 # This is the real libbfd.a created by libtool.
@@ -862,7 +875,7 @@
 	done
 install-man: $(MANS)
 	@$(NORMAL_INSTALL)
-	$(MAKE) $(AM_MAKEFLAGS) install-man1
+	$(MAKE) $(AM_MAKEFLAGS)
 uninstall-man:
 	@$(NORMAL_UNINSTALL)
 	$(MAKE) $(AM_MAKEFLAGS) uninstall-man1
@@ -1228,6 +1241,17 @@
   $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/armelf.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} armelfb_nbsd "$(tdir_armelfb_nbsd)"
+earmelf_obsd.c: $(srcdir)/emulparams/armelf_obsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_obsd "$(tdir_armelf_obsd)"
+earmelfb_obsd.c: $(srcdir)/emulparams/armelfb_obsd.sh \
+  $(srcdir)/emulparams/armelf_obsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb_obsd "$(tdir_armelfb_obsd)"
 earmaoutb.c:	$(srcdir)/emulparams/armaoutb.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} armaoutb "$(tdir_armaoutb)"
@@ -1345,6 +1369,9 @@
 eelf32_sparc.c: $(srcdir)/emulparams/elf32_sparc.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32_sparc "$(tdir_elf32_sparc)"
+eelf32_sparc_obsd.c: $(srcdir)/emulparams/elf32_sparc_obsd.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_sparc_obsd "$(tdir_elf32_sparc_obsd)"
 eelf32_i860.c: $(srcdir)/emulparams/elf32_i860.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32_i860 "$(tdir_elf32_i860)"
@@ -1441,6 +1468,10 @@
   $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emultempl/ppc32elf.em \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32ppc_fbsd "$(tdir_elf32ppc_fbsd)"
+eelf32ppc_obsd.c: $(srcdir)/emulparams/elf32ppc_obsd.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emultempl/ppc32elf.em \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppc_obsd "$(tdir_elf32ppc_obsd)"
 eelf32ppcsim.c: $(srcdir)/emulparams/elf32ppcsim.sh \
   $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emultempl/ppc32elf.em \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
@@ -1479,6 +1510,10 @@
   $(srcdir)/emulparams/elf64alpha.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64alpha_nbsd "$(tdir_elf64alpha_nbsd)"
+eelf64alpha_obsd.c: $(srcdir)/emulparams/elf64alpha_obsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64alpha_obsd "$(tdir_elf64alpha_obsd)"
 eelf64hppa.c: $(srcdir)/emulparams/elf64hppa.sh \
   $(srcdir)/emulparams/hppa64linux.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
@@ -1507,6 +1542,10 @@
   $(srcdir)/emulparams/elf64_sparc.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64_sparc_fbsd "$(tdir_elf64_sparc_fbsd)"
+eelf64_sparc_obsd.c: $(srcdir)/emulparams/elf64_sparc_obsd.sh \
+  $(srcdir)/emulparams/elf64_sparc.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_sparc_obsd "$(tdir_elf64_sparc_obsd)"
 eelf64bmip.c: $(srcdir)/emulparams/elf64bmip.sh \
   $(srcdir)/emulparams/elf32bmipn32.sh $(srcdir)/emultempl/irix.em \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
@@ -1523,10 +1562,18 @@
   $(srcdir)/emulparams/elf32bmipn32.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64btsmip "$(tdir_elf64btsmip)"
+eelf64btsmip_obsd.c: $(srcdir)/emulparams/elf64btsmip_obsd.sh \
+  $(srcdir)/emulparams/elf32bmipn32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64btsmip_obsd "$(tdir_elf64btsmip_obsd)"
 eelf64ltsmip.c: $(srcdir)/emulparams/elf64ltsmip.sh \
   $(srcdir)/emulparams/elf64btsmip.sh $(srcdir)/emulparams/elf32bmipn32.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64ltsmip "$(tdir_elf64ltsmip)"
+eelf64ltsmip_obsd.c: $(srcdir)/emulparams/elf64ltsmip_obsd.sh \
+  $(srcdir)/emulparams/elf32bmipn32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64ltsmip_obsd "$(tdir_elf64ltsmip_obsd)"
 eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386 "$(tdir_elf_i386)"
@@ -1537,6 +1584,10 @@
   $(srcdir)/emulparams/elf_x86_64.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_x86_64_fbsd "$(tdir_elf_x86_64_fbsd)"
+eelf_x86_64_obsd.c: $(srcdir)/emulparams/elf_x86_64_obsd.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_x86_64_obsd "$(tdir_elf_x86_64_obsd)"
 eelf_i386_be.c: $(srcdir)/emulparams/elf_i386_be.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386_be "$(tdir_elf_i386_be)"
@@ -1550,6 +1601,10 @@
 eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386_ldso "$(tdir_elf_i386_ldso)"
+eelf_i386_obsd.c: $(srcdir)/emulparams/elf_i386_obsd.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_obsd "$(tdir_elf_i386_obsd)"
 eelf_s390.c: $(srcdir)/emulparams/elf_s390.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_s390 "$(tdir_elf_s390)"
@@ -1687,6 +1742,9 @@
 ei386nw.c:	$(srcdir)/emulparams/i386nw.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} i386nw "$(tdir_i386nw)"
+ei386obsd.c:	$(srcdir)/emulparams/i386obsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386obsd "$(tdir_i386obsd)"
 ei386pe.c: $(srcdir)/emulparams/i386pe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} i386pe "$(tdir_i386pe)"
@@ -1742,6 +1800,9 @@
 em68knbsd.c:	$(srcdir)/emulparams/m68knbsd.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} m68knbsd "$(tdir_m68knbsd)"
+em68kobsd.c:	$(srcdir)/emulparams/m68kobsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kobsd "$(tdir_m68kobsd)"
 em68kpsos.c:	$(srcdir)/emulparams/m68kpsos.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/psos.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} m68kpsos "$(tdir_m68kpsos)"
@@ -2108,6 +2169,9 @@
 esparcnbsd.c:	$(srcdir)/emulparams/sparcnbsd.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} sparcnbsd "$(tdir_sparcnbsd)"
+esparcobsd.c:	$(srcdir)/emulparams/sparcobsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sparcobsd "$(tdir_sparcobsd)"
 est2000.c: $(srcdir)/emulparams/st2000.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/st2000.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} st2000 "$(tdir_st2000)"
@@ -2288,7 +2352,7 @@
 	$(mkinstalldirs) $(DESTDIR)$(bindir) $(DESTDIR)$(tooldir)/bin
 	@list='$(noinst_PROGRAMS)'; for p in $$list; do \
 	  if test -f $$p; then \
-	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
+	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
 	    $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/$(EXEEXT)$$//' -e 's/-new//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
 	  else :; fi; \
 	done
--- binutils-2.15.orig/ld/configure.host
+++ binutils-2.15/ld/configure.host
@@ -67,6 +67,10 @@
   fi
   ;;
 
+*-*-openbsd*)
+  HOSTING_CRT0=/usr/lib/crt0.o
+  ;;
+
 esac
 
 #
@@ -240,6 +244,9 @@
 *-*-netbsd*)
   ;;
 
+*-*-openbsd*)
+  ;;
+
 alpha*-*-*)
   HOSTING_CRT0=/usr/ccs/lib/crt0.o
   ;;
--- binutils-2.15.orig/ld/configure.tgt
+++ binutils-2.15/ld/configure.tgt
@@ -74,12 +74,15 @@
 			tdir_sun4=sparc-sun-sunos4
 			;;
 sparc*-*-lynxos*)	targ_emul=sparclynx ;;
-sparc64-*-netbsd* | sparc64-*-openbsd*)
-			targ_emul=elf64_sparc
+sparc64-*-netbsd*)	targ_emul=elf64_sparc
 			targ_extra_emuls="elf32_sparc"
 			;;
+sparc64-*-openbsd*)	targ_emul=elf64_sparc_obsd ;;
 sparc*-*-netbsd*elf*)	targ_emul=elf32_sparc ;;
 sparc*-*-netbsd*)	targ_emul=sparcnbsd ;;
+sparc-*-openbsd[0-2].*|  sparc-*-openbsd3.[0-1])
+			targ_emul=sparcobsd ;;
+sparc-*-openbsd*)	targ_emul=elf32_sparc_obsd ;;
 sparc-*-solaris2.[0-6] | sparc-*-solaris2.[0-6].*)
 			targ_emul=elf32_sparc ;;
 sparc-*-solaris2*)	targ_emul=elf32_sparc
@@ -211,6 +214,14 @@
 			tdir_elf_i386=`echo ${targ_alias} \
 			    | sed -e 's/x86_64/i386/'`
 			;;
+i[3-7]86-*-openbsd[0-2]* | i[3-7]86-*-openbsd3.[0-2])
+			targ_emul=i386obsd ;;
+i[3-7]86-*-openbsd*)	targ_emul=elf_i386_obsd ;;
+x86_64-*-openbsd*)	targ_emul=elf_x86_64_obsd
+			targ_extra_emuls="elf_i386_obsd elf_i386"
+			tdir_elf_i386_obsd=`echo ${targ_alias} | \
+			    sed -e 's/x86_64/i386/'`
+			;;
 i[3-7]86-*-sysv*)	targ_emul=i386coff ;;
 i[3-7]86-*-ptx*)	targ_emul=i386coff ;;
 i[3-7]86-*-mach*)	targ_emul=i386mach ;;
@@ -250,7 +261,10 @@
 arm-*-netbsd*)		targ_emul=armnbsd;
 			targ_extra_emuls="armelf armelf_nbsd armelfb_nbsd"  ;;
 arm-*-nto*)		targ_emul=armnto ;;
-arm-*-openbsd*)		targ_emul=armnbsd ;;
+armeb-*-openbsd*)	targ_emul=armelfb_obsd
+			targ_extra_emuls="armelf_obsd" ;;
+arm-*-openbsd*)		targ_emul=armelf_obsd
+			targ_extra_emuls="armelfb_obsd" ;;
 arm-*-rtems*)		targ_emul=armelf ;;
 armeb-*-elf)		targ_emul=armelfb ;;
 arm-*-elf | arm-*-vxworks)
@@ -378,6 +392,7 @@
 m68*-*-netbsdaout* | m68*-*-netbsd*)
 			targ_emul=m68knbsd
 			targ_extra_emuls="m68kelfnbsd m68k4knbsd" ;;
+m68*-*-openbsd*)	targ_emul=m68kobsd ;;
 m68*-*-psos*)		targ_emul=m68kpsos ;;
 m68*-*-rtemscoff*)	targ_emul=m68kcoff ;;
 m68*-*-rtems*)		targ_emul=m68kelf ;;
@@ -414,6 +429,14 @@
 mips*-*-netbsd*)	targ_emul=elf32bmip
 			targ_extra_emuls="elf32lmip"
 			;;
+mips64*el-*-openbsd*)	targ_emul=elf64ltsmip_obsd
+			targ_extra_emuls="elf32ltsmipn32 elf32btsmipn32 elf32ltsmip elf32btsmip elf64btsmip"
+			;;
+mips64*-*-openbsd*)	targ_emul=elf64btsmip_obsd
+			targ_extra_emuls="elf32btsmipn32 elf32ltsmipn32 elf32btsmip elf32ltsmip elf64ltsmip"
+			;;
+mips*el-*-openbsd*)	targ_emul=elf32ltsmip ;;
+mips*-*-openbsd*)	targ_emul=elf32btsmip ;;
 mips*-*-bsd*)		targ_emul=mipsbig ;;
 mips*vr4300el-*-elf*)	targ_emul=elf32l4300 ;;
 mips*vr4300-*-elf*)	targ_emul=elf32b4300 ;;
@@ -465,7 +488,7 @@
 alpha*-*-gnu*)		targ_emul=elf64alpha ;;
 alpha*-*-netware*)	targ_emul=alpha ;;
 alpha*-*-netbsd*)	targ_emul=elf64alpha_nbsd ;;
-alpha*-*-openbsd*)	targ_emul=elf64alpha ;;
+alpha*-*-openbsd*)	targ_emul=elf64alpha_obsd ;;
 z8k-*-coff) 		targ_emul=z8002; targ_extra_emuls=z8001 ;;
 ns32k-pc532-mach* | ns32k-pc532-ux*)	targ_emul=pc532macha ;;
 ns32k-*-netbsd* | ns32k-pc532-lites*) targ_emul=ns32knbsd ;;
@@ -482,6 +505,7 @@
 			targ_extra_libpath=elf32ppc;
 			tdir_elf32ppcsim=`echo ${targ_alias} | sed -e 's/ppc/ppcsim/'`
 			;;
+powerpc-*-openbsd*)	targ_emul=elf32ppc_obsd ;;
 powerpc*-*-linux*)
 	case "${targ}" in
 	*64*)	targ_emul=elf64ppc
@@ -510,7 +534,7 @@
 		targ_extra_emuls="elf32ppcsim" ;;
 	esac ;;
 powerpc*-*-elf* | powerpc*-*-eabi* | powerpc*-*-sysv* \
-  | powerpc*-*-netbsd* | powerpc-*-openbsd* | powerpc*-*-vxworks* | powerpc*-*-kaos*)
+  | powerpc*-*-netbsd* | powerpc*-*-vxworks* | powerpc*-*-kaos*)
 	case "${targ}" in
 	*64*)	targ_emul=elf64ppc
 		targ_extra_emuls="elf32ppc elf32ppclinux elf32ppcsim"
--- binutils-2.15.orig/ld/emulparams/armelf_obsd.sh
+++ binutils-2.15/ld/emulparams/armelf_obsd.sh
@@ -0,0 +1,7 @@
+. ${srcdir}/emulparams/armelf.sh
+. ${srcdir}/emulparams/elf_obsd.sh
+
+MAXPAGESIZE=0x8000
+TEXT_START_ADDR=0x00008000
+
+unset EMBEDDED
--- binutils-2.15.orig/ld/emulparams/armelfb_obsd.sh
+++ binutils-2.15/ld/emulparams/armelfb_obsd.sh
@@ -0,0 +1,3 @@
+. ${srcdir}/emulparams/armelf_obsd.sh
+
+OUTPUT_FORMAT="elf32-bigarm"
--- binutils-2.15.orig/ld/emulparams/avr1200.sh
+++ binutils-2.15/ld/emulparams/avr1200.sh
@@ -0,0 +1,13 @@
+ARCH=avr:1
+MACHINE=
+SCRIPT_NAME=elf32avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+TEXT_LENGTH=1K
+DATA_LENGTH=0
+EEPROM_LENGTH=64
+DATA_START=0x60
+STACK=0
--- binutils-2.15.orig/ld/emulparams/avr23xx.sh
+++ binutils-2.15/ld/emulparams/avr23xx.sh
@@ -0,0 +1,14 @@
+ARCH=avr:2
+MACHINE=
+SCRIPT_NAME=elf32avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+TEXT_LENGTH=2K
+DATA_LENGTH=128
+EEPROM_LENGTH=128
+DATA_START=0x60
+STACK=0x0DF
+
--- binutils-2.15.orig/ld/emulparams/avr4433.sh
+++ binutils-2.15/ld/emulparams/avr4433.sh
@@ -0,0 +1,14 @@
+ARCH=avr:2
+MACHINE=
+SCRIPT_NAME=elf32avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+TEXT_LENGTH=4K
+DATA_LENGTH=128
+EEPROM_LENGTH=256
+DATA_START=0x60
+STACK=0x0DF
+
--- binutils-2.15.orig/ld/emulparams/avr44x4.sh
+++ binutils-2.15/ld/emulparams/avr44x4.sh
@@ -0,0 +1,14 @@
+ARCH=avr:2
+MACHINE=
+SCRIPT_NAME=elf32avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+TEXT_LENGTH=4K
+DATA_LENGTH=256
+EEPROM_LENGTH=256
+DATA_START=0x60
+STACK=0x15F
+
--- binutils-2.15.orig/ld/emulparams/avr85xx.sh
+++ binutils-2.15/ld/emulparams/avr85xx.sh
@@ -0,0 +1,14 @@
+ARCH=avr:2
+MACHINE=
+SCRIPT_NAME=elf32avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+TEXT_LENGTH=8K
+DATA_LENGTH=512
+EEPROM_LENGTH=512
+DATA_START=0x60
+STACK=0x25F
+
--- binutils-2.15.orig/ld/emulparams/avrmega103.sh
+++ binutils-2.15/ld/emulparams/avrmega103.sh
@@ -0,0 +1,13 @@
+ARCH=avr:3
+MACHINE=
+SCRIPT_NAME=elf32avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+TEXT_LENGTH=128K
+DATA_LENGTH=4000
+EEPROM_LENGTH=4K
+DATA_START=0x60
+STACK=0x0FFF
--- binutils-2.15.orig/ld/emulparams/avrmega161.sh
+++ binutils-2.15/ld/emulparams/avrmega161.sh
@@ -0,0 +1,14 @@
+ARCH=avr:5
+MACHINE=
+SCRIPT_NAME=elf32avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+TEXT_LENGTH=16K
+DATA_LENGTH=1K
+EEPROM_LENGTH=512
+DATA_START=0x60
+STACK=0x45F
+
--- binutils-2.15.orig/ld/emulparams/avrmega603.sh
+++ binutils-2.15/ld/emulparams/avrmega603.sh
@@ -0,0 +1,13 @@
+ARCH=avr:3
+MACHINE=
+SCRIPT_NAME=elf32avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+TEXT_LENGTH=64K
+DATA_LENGTH=4000
+EEPROM_LENGTH=2K
+DATA_START=0x60
+STACK=0x0FFF
--- binutils-2.15.orig/ld/emulparams/elf32_sparc_obsd.sh
+++ binutils-2.15/ld/emulparams/elf32_sparc_obsd.sh
@@ -0,0 +1,4 @@
+. ${srcdir}/emulparams/elf32_sparc.sh
+#override MAXPAGESIZE to avoid cache aliasing.
+MAXPAGESIZE=0x100000
+. ${srcdir}/emulparams/elf_obsd.sh
--- binutils-2.15.orig/ld/emulparams/elf32ppc_obsd.sh
+++ binutils-2.15/ld/emulparams/elf32ppc_obsd.sh
@@ -0,0 +1,2 @@
+. ${srcdir}/emulparams/elf32ppc.sh
+. ${srcdir}/emulparams/elf_obsd.sh
--- binutils-2.15.orig/ld/emulparams/elf64_sparc_obsd.sh
+++ binutils-2.15/ld/emulparams/elf64_sparc_obsd.sh
@@ -0,0 +1,2 @@
+. ${srcdir}/emulparams/elf64_sparc.sh
+. ${srcdir}/emulparams/elf_obsd.sh
--- binutils-2.15.orig/ld/emulparams/elf64alpha_obsd.sh
+++ binutils-2.15/ld/emulparams/elf64alpha_obsd.sh
@@ -0,0 +1,2 @@
+. ${srcdir}/emulparams/elf64alpha.sh
+. ${srcdir}/emulparams/elf_obsd.sh
--- binutils-2.15.orig/ld/emulparams/elf64btsmip_obsd.sh
+++ binutils-2.15/ld/emulparams/elf64btsmip_obsd.sh
@@ -0,0 +1,6 @@
+. ${srcdir}/emulparams/elf64btsmip.sh
+MAXPAGESIZE=0x10000
+TEXT_START_ADDR="0x10000000"
+. ${srcdir}/emulparams/elf_obsd.sh
+# XXX causes GOT oflows
+NO_PAD_CDTOR=y
--- binutils-2.15.orig/ld/emulparams/elf64ltsmip_obsd.sh
+++ binutils-2.15/ld/emulparams/elf64ltsmip_obsd.sh
@@ -0,0 +1,6 @@
+. ${srcdir}/emulparams/elf64ltsmip.sh
+MAXPAGESIZE=0x10000
+TEXT_START_ADDR="0x10000000"
+. ${srcdir}/emulparams/elf_obsd.sh
+# XXX causes GOT oflows
+NO_PAD_CDTOR=y
--- binutils-2.15.orig/ld/emulparams/elf_i386_obsd.sh
+++ binutils-2.15/ld/emulparams/elf_i386_obsd.sh
@@ -0,0 +1,15 @@
+. ${srcdir}/emulparams/elf_i386.sh
+. ${srcdir}/emulparams/elf_obsd.sh
+
+if test "$LD_FLAG" = "Z"
+then
+TEXT_START_ADDR=0x08048000
+else
+TEXT_START_ADDR=0x1C000000
+fi
+
+RODATA_PADSIZE=0x20000000
+RODATA_ALIGN=". = ALIGN(${RODATA_PADSIZE})"
+RODATA_ALIGN_ADD="${TEXT_START_ADDR}"
+
+unset PAD_PLT
--- binutils-2.15.orig/ld/emulparams/elf_obsd.sh
+++ binutils-2.15/ld/emulparams/elf_obsd.sh
@@ -0,0 +1,7 @@
+LIB_PATH=/usr/lib
+
+PAD_RO=
+RODATA_PADSIZE=${MAXPAGESIZE}
+RODATA_ALIGN=". = ALIGN(${RODATA_PADSIZE}) + (. & (${RODATA_PADSIZE} - 1))"
+PAD_GOT=
+PAD_PLT=
--- binutils-2.15.orig/ld/emulparams/elf_x86_64_obsd.sh
+++ binutils-2.15/ld/emulparams/elf_x86_64_obsd.sh
@@ -0,0 +1,2 @@
+. ${srcdir}/emulparams/elf_x86_64.sh
+. ${srcdir}/emulparams/elf_obsd.sh
--- binutils-2.15.orig/ld/emulparams/hppaobsd.sh
+++ binutils-2.15/ld/emulparams/hppaobsd.sh
@@ -1,6 +1,17 @@
-. ${srcdir}/emulparams/hppanbsd.sh
-
+. ${srcdir}/emulparams/hppaelf.sh
+ 
+#override hppaelf.sh
+SCRIPT_NAME=elf
+ELFSIZE=32
 OUTPUT_FORMAT="elf32-hppa"
-TEXT_START_ADDR=0x1000
-TARGET_PAGE_SIZE=0x1000
+
+# other necessary defines, similar but not the same as linux.
 MAXPAGESIZE=0x1000
+ENTRY="__start"
+MACHINE=hppa1.1    # We use 1.1 specific features.
+OTHER_READONLY_SECTIONS=".PARISC.unwind ${RELOCATING-0} : { *(.PARISC.unwind) }"
+DATA_START_SYMBOLS='PROVIDE ($global$ = .);'
+DATA_NONEXEC_PLT=
+GENERATE_SHLIB_SCRIPT=yes
+
+. ${srcdir}/emulparams/elf_obsd.sh
--- binutils-2.15.orig/ld/emulparams/i386obsd.sh
+++ binutils-2.15/ld/emulparams/i386obsd.sh
@@ -0,0 +1,8 @@
+SCRIPT_NAME=aout
+TEXT_START_ADDR=0x1020
+OUTPUT_FORMAT="a.out-i386-netbsd"
+TARGET_PAGE_SIZE=0x1000
+ARCH=i386
+EXECUTABLE_SYMBOLS='__DYNAMIC = 0;'
+
+LIB_PATH=/usr/lib
--- binutils-2.15.orig/ld/emulparams/m68kobsd.sh
+++ binutils-2.15/ld/emulparams/m68kobsd.sh
@@ -0,0 +1,9 @@
+SCRIPT_NAME=aout
+TEXT_START_ADDR=0x2020
+NONPAGED_TEXT_START_ADDR=0x2000
+OUTPUT_FORMAT="a.out-m68k-netbsd"
+TARGET_PAGE_SIZE=0x2000
+ARCH=m68k
+EXECUTABLE_SYMBOLS='__DYNAMIC = 0;'
+
+LIB_PATH=/usr/lib
--- binutils-2.15.orig/ld/emulparams/msp430x110.sh
+++ binutils-2.15/ld/emulparams/msp430x110.sh
@@ -0,0 +1,14 @@
+ARCH=msp:11
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xfc00
+ROM_SIZE=0x3e0
+RAM_START=0x0200
+RAM_SIZE=128
+
+STACK=0x280
--- binutils-2.15.orig/ld/emulparams/msp430x1101.sh
+++ binutils-2.15/ld/emulparams/msp430x1101.sh
@@ -0,0 +1,14 @@
+ARCH=msp:110
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xfc00
+ROM_SIZE=0x3e0
+RAM_START=0x0200
+RAM_SIZE=128
+
+STACK=0x280
--- binutils-2.15.orig/ld/emulparams/msp430x1111.sh
+++ binutils-2.15/ld/emulparams/msp430x1111.sh
@@ -0,0 +1,14 @@
+ARCH=msp:110
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xf800
+ROM_SIZE=0x07e0
+RAM_START=0x0200
+RAM_SIZE=128
+
+STACK=0x280
--- binutils-2.15.orig/ld/emulparams/msp430x112.sh
+++ binutils-2.15/ld/emulparams/msp430x112.sh
@@ -0,0 +1,14 @@
+ARCH=msp:11
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xf000
+ROM_SIZE=0xfe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x1121.sh
+++ binutils-2.15/ld/emulparams/msp430x1121.sh
@@ -0,0 +1,14 @@
+ARCH=msp:110
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xf000
+ROM_SIZE=0x0fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x1122.sh
+++ binutils-2.15/ld/emulparams/msp430x1122.sh
@@ -0,0 +1,14 @@
+ARCH=msp:110
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xf000
+ROM_SIZE=0x0fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x1132.sh
+++ binutils-2.15/ld/emulparams/msp430x1132.sh
@@ -0,0 +1,14 @@
+ARCH=msp:110
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x122.sh
+++ binutils-2.15/ld/emulparams/msp430x122.sh
@@ -0,0 +1,14 @@
+ARCH=msp:12
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xf000
+ROM_SIZE=0xfe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x1222.sh
+++ binutils-2.15/ld/emulparams/msp430x1222.sh
@@ -0,0 +1,14 @@
+ARCH=msp:12
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xf000
+ROM_SIZE=0xfe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x123.sh
+++ binutils-2.15/ld/emulparams/msp430x123.sh
@@ -0,0 +1,14 @@
+ARCH=msp:12
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x1232.sh
+++ binutils-2.15/ld/emulparams/msp430x1232.sh
@@ -0,0 +1,14 @@
+ARCH=msp:12
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x133.sh
+++ binutils-2.15/ld/emulparams/msp430x133.sh
@@ -0,0 +1,14 @@
+ARCH=msp:13
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x1331.sh
+++ binutils-2.15/ld/emulparams/msp430x1331.sh
@@ -0,0 +1,14 @@
+ARCH=msp:13
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x135.sh
+++ binutils-2.15/ld/emulparams/msp430x135.sh
@@ -0,0 +1,14 @@
+ARCH=msp:13
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+RAM_SIZE=512
+
+STACK=0x400
--- binutils-2.15.orig/ld/emulparams/msp430x1351.sh
+++ binutils-2.15/ld/emulparams/msp430x1351.sh
@@ -0,0 +1,14 @@
+ARCH=msp:13
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+RAM_SIZE=512
+
+STACK=0x400
--- binutils-2.15.orig/ld/emulparams/msp430x147.sh
+++ binutils-2.15/ld/emulparams/msp430x147.sh
@@ -0,0 +1,14 @@
+ARCH=msp:14
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x0200
+RAM_SIZE=1K
+
+STACK=0x600
--- binutils-2.15.orig/ld/emulparams/msp430x148.sh
+++ binutils-2.15/ld/emulparams/msp430x148.sh
@@ -0,0 +1,14 @@
+ARCH=msp:14
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x4000
+ROM_SIZE=0xbef0
+RAM_START=0x0200
+RAM_SIZE=0x07ff
+
+STACK=0xa00
--- binutils-2.15.orig/ld/emulparams/msp430x149.sh
+++ binutils-2.15/ld/emulparams/msp430x149.sh
@@ -0,0 +1,14 @@
+ARCH=msp:14
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x1100
+ROM_SIZE=0xeee0
+RAM_START=0x0200
+RAM_SIZE=0x07ff
+
+STACK=0xa00
--- binutils-2.15.orig/ld/emulparams/msp430x155.sh
+++ binutils-2.15/ld/emulparams/msp430x155.sh
@@ -0,0 +1,14 @@
+ARCH=msp:15
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+RAM_SIZE=512
+
+STACK=0x400
--- binutils-2.15.orig/ld/emulparams/msp430x156.sh
+++ binutils-2.15/ld/emulparams/msp430x156.sh
@@ -0,0 +1,14 @@
+ARCH=msp:15
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xa000
+ROM_SIZE=0x5fe0
+RAM_START=0x0200
+RAM_SIZE=512
+
+STACK=0x400
--- binutils-2.15.orig/ld/emulparams/msp430x157.sh
+++ binutils-2.15/ld/emulparams/msp430x157.sh
@@ -0,0 +1,14 @@
+ARCH=msp:15
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x0200
+RAM_SIZE=1K
+
+STACK=0x600
--- binutils-2.15.orig/ld/emulparams/msp430x167.sh
+++ binutils-2.15/ld/emulparams/msp430x167.sh
@@ -0,0 +1,14 @@
+ARCH=msp:16
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x0200
+RAM_SIZE=1K
+
+STACK=0x600
--- binutils-2.15.orig/ld/emulparams/msp430x168.sh
+++ binutils-2.15/ld/emulparams/msp430x168.sh
@@ -0,0 +1,14 @@
+ARCH=msp:16
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x4000
+ROM_SIZE=0xbef0
+RAM_START=0x0200
+RAM_SIZE=0x07ff
+
+STACK=0xa00
--- binutils-2.15.orig/ld/emulparams/msp430x169.sh
+++ binutils-2.15/ld/emulparams/msp430x169.sh
@@ -0,0 +1,14 @@
+ARCH=msp:16
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x1100
+ROM_SIZE=0xeee0
+RAM_START=0x0200
+RAM_SIZE=0x07ff
+
+STACK=0xa00
--- binutils-2.15.orig/ld/emulparams/msp430x311.sh
+++ binutils-2.15/ld/emulparams/msp430x311.sh
@@ -0,0 +1,14 @@
+ARCH=msp:31
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xf800
+ROM_SIZE=0x07e0
+RAM_START=0x0200
+RAM_SIZE=128
+
+STACK=0x280
--- binutils-2.15.orig/ld/emulparams/msp430x312.sh
+++ binutils-2.15/ld/emulparams/msp430x312.sh
@@ -0,0 +1,14 @@
+ARCH=msp:31
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xf000
+ROM_SIZE=0x0fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x313.sh
+++ binutils-2.15/ld/emulparams/msp430x313.sh
@@ -0,0 +1,14 @@
+ARCH=msp:31
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x314.sh
+++ binutils-2.15/ld/emulparams/msp430x314.sh
@@ -0,0 +1,14 @@
+ARCH=msp:31
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xd000
+ROM_SIZE=0x2fe0
+RAM_START=0x0200
+RAM_SIZE=512
+
+STACK=0x400
--- binutils-2.15.orig/ld/emulparams/msp430x315.sh
+++ binutils-2.15/ld/emulparams/msp430x315.sh
@@ -0,0 +1,14 @@
+ARCH=msp:31
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+RAM_SIZE=512
+
+STACK=0x400
--- binutils-2.15.orig/ld/emulparams/msp430x323.sh
+++ binutils-2.15/ld/emulparams/msp430x323.sh
@@ -0,0 +1,14 @@
+ARCH=msp:32
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x325.sh
+++ binutils-2.15/ld/emulparams/msp430x325.sh
@@ -0,0 +1,14 @@
+ARCH=msp:32
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+RAM_SIZE=512
+
+STACK=0x400
--- binutils-2.15.orig/ld/emulparams/msp430x336.sh
+++ binutils-2.15/ld/emulparams/msp430x336.sh
@@ -0,0 +1,14 @@
+ARCH=msp:33
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xa000
+ROM_SIZE=0x5fe0
+RAM_START=0x0200
+RAM_SIZE=1024
+
+STACK=0x600
--- binutils-2.15.orig/ld/emulparams/msp430x337.sh
+++ binutils-2.15/ld/emulparams/msp430x337.sh
@@ -0,0 +1,14 @@
+ARCH=msp:33
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x0200
+RAM_SIZE=1024
+
+STACK=0x600
--- binutils-2.15.orig/ld/emulparams/msp430x412.sh
+++ binutils-2.15/ld/emulparams/msp430x412.sh
@@ -0,0 +1,14 @@
+ARCH=msp:41
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xf000
+ROM_SIZE=0x0fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x413.sh
+++ binutils-2.15/ld/emulparams/msp430x413.sh
@@ -0,0 +1,14 @@
+ARCH=msp:41
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=256
+
+STACK=0x300
--- binutils-2.15.orig/ld/emulparams/msp430x435.sh
+++ binutils-2.15/ld/emulparams/msp430x435.sh
@@ -0,0 +1,14 @@
+ARCH=msp:43
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+RAM_SIZE=512
+
+STACK=0x400
--- binutils-2.15.orig/ld/emulparams/msp430x436.sh
+++ binutils-2.15/ld/emulparams/msp430x436.sh
@@ -0,0 +1,14 @@
+ARCH=msp:43
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0xa000
+ROM_SIZE=0x5fe0
+RAM_START=0x0200
+RAM_SIZE=1024
+
+STACK=0x600
--- binutils-2.15.orig/ld/emulparams/msp430x437.sh
+++ binutils-2.15/ld/emulparams/msp430x437.sh
@@ -0,0 +1,14 @@
+ARCH=msp:43
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x0200
+RAM_SIZE=1024
+
+STACK=0x600
--- binutils-2.15.orig/ld/emulparams/msp430x447.sh
+++ binutils-2.15/ld/emulparams/msp430x447.sh
@@ -0,0 +1,14 @@
+ARCH=msp:44
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x0200
+RAM_SIZE=1K
+
+STACK=0x600
--- binutils-2.15.orig/ld/emulparams/msp430x448.sh
+++ binutils-2.15/ld/emulparams/msp430x448.sh
@@ -0,0 +1,14 @@
+ARCH=msp:44
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x4000
+ROM_SIZE=0xbef0
+RAM_START=0x0200
+RAM_SIZE=0x07ff
+
+STACK=0xa00
--- binutils-2.15.orig/ld/emulparams/msp430x449.sh
+++ binutils-2.15/ld/emulparams/msp430x449.sh
@@ -0,0 +1,14 @@
+ARCH=msp:44
+MACHINE=
+SCRIPT_NAME=elf32msp430
+OUTPUT_FORMAT="elf32-msp430"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=generic
+
+ROM_START=0x1100
+ROM_SIZE=0xeee0
+RAM_START=0x0200
+RAM_SIZE=0x07ff
+
+STACK=0xa00
--- binutils-2.15.orig/ld/emulparams/sparcobsd.sh
+++ binutils-2.15/ld/emulparams/sparcobsd.sh
@@ -0,0 +1,7 @@
+SCRIPT_NAME=aout
+TEXT_START_ADDR=0x1020
+OUTPUT_FORMAT="a.out-sparc-netbsd"
+TARGET_PAGE_SIZE=0x1000
+ARCH=sparc
+
+LIB_PATH=/usr/lib
--- binutils-2.15.orig/ld/emultempl/elf32.em
+++ binutils-2.15/ld/emultempl/elf32.em
@@ -62,6 +62,237 @@
 static void gld${EMULATION_NAME}_finish (void);
 
 EOF
+case ${target} in
+  *-*-openbsd*)
+    cat >>e${EMULATION_NAME}.c <<EOF
+#include <sys/types.h>
+#include <dirent.h>
+
+/* Search a directory for a .so file.  */
+
+static char * gld${EMULATION_NAME}_search_dir_needed (const char *dirlist, const char *filename);
+
+static char * gld${EMULATION_NAME}_search_dir (const char *dirname,
+  const char *filename, int req_maj, int req_min);
+
+static char * gld${EMULATION_NAME}_split_lib_name (char *name, int *pmaj,
+  int *pmin);
+
+/* THIS FUNCTION MODIFIES THE name ARGUMENT string */
+static char *
+gld${EMULATION_NAME}_split_lib_name (name, pmaj, pmin)
+  char *name;
+  int *pmaj, *pmin;
+{
+  char*eptr, *lib = name;
+  char *s;
+  int found_so = 0;
+
+  *pmaj = -1;
+  *pmin = -1;
+  
+  if (strncmp(lib, "lib", 3) == 0)   
+    lib += 3;
+
+  s = lib;
+  while (found_so == 0)
+    {
+      s = strstr(s, ".so");
+
+      /* if .so not found, return not found, invalid lib name */
+      if (s == NULL)
+	{
+	  return NULL;
+	}
+
+      /* if .so is at end of string, fine return with pmaj/pmin -1 */
+      if (s[3] == '\0')
+	{
+	  *s = '\0';
+	  return lib;
+	}
+
+      if (s[3] == '.')
+	{
+	  *s = '\0';
+	  found_so = 1;
+	}
+      /* skip over the ".so" */
+      s += 3;
+    }
+
+  
+  /* lib[name].so.[M].[N] */
+  /*  s          ^        */
+  s += 1;
+
+  /* lib[name].so.[M].[N] */
+  /*  s           ^       */
+  *pmaj = strtoul (s, &eptr, 10);
+
+  /* lib[name].so.[M]X... */
+  /*  eptr           ^    */
+  if (*eptr != '.' || s == eptr)
+    return NULL; /* invalid, must have minor */
+
+  s = eptr+1;
+
+  /* lib[name].so.[M].[N]  */
+  /*  s               ^    */
+  *pmin = strtoul (s, &eptr, 10);
+
+  /* lib[name].so.[M].[N]  */
+  /*  eptr               ^ */
+  if (*eptr != '\0' || s == eptr)
+    return NULL;  /* minor must be last field of library */
+
+  return lib;
+}
+
+static char *
+gld${EMULATION_NAME}_search_dir_needed (dirlist, filename)
+    const char *dirlist;
+    const char *filename;
+{
+  char *dlist, *dlist_alloc, *dir;
+  char *fnam, *fnam_alloc, *lib;
+  char *found = NULL;
+  int maj = -1, min = -1;
+  
+  dlist_alloc = dlist = xstrdup(dirlist);
+  fnam_alloc = fnam = xstrdup(filename);
+  
+  lib = gld${EMULATION_NAME}_split_lib_name(fnam, &maj, &min);
+  
+  while (lib != NULL && found == NULL)
+    {
+      dir = strsep(&dlist, ":");
+      if (dir == NULL)
+	break;
+      if (*dir == '\0')
+	continue; /* skip dirlist of ...::... */
+      found = gld${EMULATION_NAME}_search_dir(dir, lib, maj, min);
+    }
+  
+  free(dlist_alloc);
+  free(fnam_alloc);
+  return found;
+}
+
+
+static char *
+gld${EMULATION_NAME}_search_dir (dirname, filename, req_maj, req_min)
+     const char *dirname;
+     const char *filename;
+     int req_maj, req_min;
+{
+  const char *dot;
+  unsigned int len;
+  char *found;
+  int max_maj, max_min;
+  DIR *dir;
+  struct dirent *entry;
+  unsigned int dirnamelen;
+  char *full_path;
+  int statval;
+  struct stat st;
+
+  dot = strchr (filename, '.');
+  len = strlen (filename);
+  found = NULL;
+  max_maj = max_min = 0;
+
+  dir = opendir (dirname);
+  if (dir == NULL)
+    return NULL;
+  dirnamelen = strlen (dirname);
+  
+  while ((entry = readdir (dir)) != NULL)
+    {
+      const char *s;
+      char *eptr, *eptr1;
+      int found_maj, found_min;
+
+      if (strncmp (entry->d_name, "lib", 3) != 0
+	  || strncmp (entry->d_name + 3, filename, len) != 0)
+	continue;
+
+      /* We accept libfoo.so without a version number, even though the
+         native linker does not.  This is more convenient for packages
+         which just generate .so files for shared libraries, as on ELF
+         systems.  */
+      if (strncmp (entry->d_name + 3 + len, ".so", 3) != 0)
+	continue;
+
+      if (entry->d_name[6 + len] == '\0')
+	;
+      else if (entry->d_name[6 + len] == '.'
+	       && ISDIGIT ((unsigned char) entry->d_name[7 + len]))
+	;
+      else
+	continue;
+
+      for (s = entry->d_name + 6 + len; *s != '\0'; s++)
+	if (*s != '.' && ! ISDIGIT ((unsigned char) *s))
+	  break;
+      if (*s != '\0')
+	continue;
+
+      /* We've found a .so file.  Work out the major and minor
+	 version numbers.  */
+      found_maj = -1;
+      found_min = -1;
+
+      /* do allow libN.so */
+      if (entry->d_name[6 + len] == '.') {
+	found_maj = strtoul (entry->d_name + 7 + len, &eptr, 10);
+
+	/* do not support libN.so. or libN.so.X */
+	if (*eptr != '.' || ((entry->d_name + 3 + len) == eptr)) 
+	  continue;
+
+	found_min = strtoul (eptr+1, &eptr1, 10);
+
+	/* do not support libN.so.X. or libN.so.X.Y.[anything] */
+	if (*eptr1 != '\0' || (eptr+1 == eptr1)) 
+	  continue;
+      }
+
+      /* Make sure the file really exists (ignore broken symlinks).  */
+      full_path = xmalloc (dirnamelen + 1 + strlen (entry->d_name) + 1);
+      sprintf (full_path, "%s/%s", dirname, entry->d_name);
+      statval = stat (full_path, &st);
+      free (full_path);
+      if (statval != 0)
+	continue;
+
+      /* We've found a match for the name we are searching for.  See
+	 if this is the version we should use.  */
+      if (((req_maj == -1) && (found == NULL
+	    || (found_maj > max_maj)
+	    || (found_maj == max_maj && (found_min > max_min))))
+	  || ((found_maj == req_maj) && (found_min >= req_min)
+	    && (found_min > max_min)))
+	{
+	  if (found != NULL)
+	    free (found);
+	  found = (char *) xmalloc (dirnamelen + strlen (entry->d_name) + 2);
+	  sprintf (found, "%s/%s", dirname, entry->d_name);
+	  max_maj = found_maj;
+	  max_min = found_min;
+	}
+    }
+
+  closedir (dir);
+
+  return found;
+}
+
+EOF
+    ;;
+esac
+cat >>e${EMULATION_NAME}.c <<EOF
+EOF
 
 # Import any needed special functions and/or overrides.
 #
@@ -251,7 +482,7 @@
 gld${EMULATION_NAME}_try_needed (const char *name, int force)
 {
   bfd *abfd;
-  const char *soname;
+  char *soname;
 
   abfd = bfd_openr (name, bfd_get_target (output_bfd));
   if (abfd == NULL)
@@ -344,7 +575,7 @@
     einfo ("%F%P:%B: bfd_stat failed: %E\n", abfd);
 
   /* First strip off everything before the last '/'.  */
-  soname = lbasename (abfd->filename);
+  soname = xstrdup (lbasename (abfd->filename));
 
   if (trace_file_tries)
     info_msg (_("found %s at %s\n"), soname, name);
@@ -355,6 +586,7 @@
     {
       /* Return TRUE to indicate that we found the file, even though
 	 we aren't going to do anything with it.  */
+      free (soname);
       return TRUE;
     }
 
@@ -387,6 +619,25 @@
 
   if (path == NULL || *path == '\0')
     return FALSE;
+
+EOF
+case ${target} in
+  *-*-openbsd*)
+    cat >>e${EMULATION_NAME}.c <<EOF
+  {
+    char *found;
+    if ((found = gld${EMULATION_NAME}_search_dir_needed(path, name)) != NULL) {
+      if (gld${EMULATION_NAME}_try_needed (found, force)) {
+	free(found);
+	return TRUE;
+      }
+      free(found);
+    }
+  }
+
+EOF
+esac
+cat >>e${EMULATION_NAME}.c <<EOF
   len = strlen (name);
   while (1)
     {
@@ -656,7 +907,7 @@
 	 rpath_link, rpath, then the environment variable
 	 LD_LIBRARY_PATH (native only), then the DT_RPATH/DT_RUNPATH
 	 entries (native only), then the linker script LIB_SEARCH_DIRS.
-	 We do not search using the -L arguments.
+	 We look at the -L arguments to build the search path.
 
 	 We search twice.  The first time, we skip objects which may
 	 introduce version mismatches.  The second time, we force
@@ -668,7 +919,7 @@
 EOF
 if [ "x${USE_LIBPATH}" = xyes ] ; then
 cat >>e${EMULATION_NAME}.c <<EOF
-	  const char *lib_path;
+	  char *lib_path;
 	  struct bfd_link_needed_list *rp;
 	  int found;
 EOF
@@ -688,16 +939,39 @@
 fi
 if [ "x${NATIVE}" = xyes ] ; then
 cat >>e${EMULATION_NAME}.c <<EOF
-	  if (command_line.rpath_link == NULL
+	  if (getenv ("LD_RUN_PATH") != NULL
+	      && command_line.rpath_link == NULL
 	      && command_line.rpath == NULL)
 	    {
-	      lib_path = (const char *) getenv ("LD_RUN_PATH");
+	      lib_path = getenv ("LD_RUN_PATH");
 	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
 						      force))
 		break;
 	    }
-	  lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
+
+	 len = strlen(search_head->name);
+	 lib_path = xstrdup(search_head->name);
+	 for (search = search_head->next; search != NULL;
+	      search = search->next)
+	   {
+	     size_t nlen;
+
+	     nlen = strlen(search->name);
+	     lib_path = xrealloc(lib_path, len + nlen + 2);
+	     lib_path[len] = ':';
+	     strcpy(lib_path + len + 1, search->name);
+	     len += nlen + 1;
+	   }
+
 	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
+	   {
+	     free(lib_path);
+	     break;
+	   }
+	 free(lib_path);
+
+	 lib_path = getenv ("LD_LIBRARY_PATH");
+	 if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
 	    break;
 EOF
 fi
@@ -896,10 +1170,8 @@
       {
 	asection *s;
 	bfd_size_type sz;
-	bfd_size_type prefix_len;
 	char *msg;
 	bfd_boolean ret;
-	const char * gnu_warning_prefix = _("warning: ");
 
 	if (is->just_syms_flag)
 	  continue;
@@ -909,14 +1181,11 @@
 	  continue;
 
 	sz = bfd_section_size (is->the_bfd, s);
-	prefix_len = strlen (gnu_warning_prefix);
-	msg = xmalloc ((size_t) (prefix_len + sz + 1));
-	strcpy (msg, gnu_warning_prefix);
-	if (! bfd_get_section_contents (is->the_bfd, s,	msg + prefix_len,
-					(file_ptr) 0, sz))
+	msg = xmalloc ((size_t) (sz + 1));
+	if (! bfd_get_section_contents (is->the_bfd, s,	msg, (file_ptr) 0, sz))
 	  einfo ("%F%B: Can't read contents of section .gnu.warning: %E\n",
 		 is->the_bfd);
-	msg[prefix_len + sz] = '\0';
+	msg[sz] = '\0';
 	ret = link_info.callbacks->warning (&link_info, msg,
 					    (const char *) NULL,
 					    is->the_bfd, (asection *) NULL,
@@ -952,7 +1221,17 @@
     return FALSE;
 
   filename = entry->filename;
-
+EOF
+case ${target} in
+  *-*-openbsd*)
+    cat >>e${EMULATION_NAME}.c <<EOF
+  string = gld${EMULATION_NAME}_search_dir(search->name, filename, -1, -1);
+  if (string == NULL)
+    return FALSE;
+EOF
+   ;;
+  *)
+    cat >>e${EMULATION_NAME}.c <<EOF
   /* This allocates a few bytes too many when EXTRA_SHLIB_EXTENSION
      is defined, but it does not seem worth the headache to optimize
      away those two bytes of space.  */
@@ -966,6 +1245,10 @@
 
   sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);
 
+EOF
+    ;;
+esac
+cat >>e${EMULATION_NAME}.c <<EOF
 #ifdef EXTRA_SHLIB_EXTENSION
   /* Try the .so extension first.  If that fails build a new filename
      using EXTRA_SHLIB_EXTENSION.  */
@@ -1472,6 +1755,8 @@
 echo '  ; else if (link_info.shared) return'	       >> e${EMULATION_NAME}.c
 sed $sc ldscripts/${EMULATION_NAME}.xs                 >> e${EMULATION_NAME}.c
 fi
+echo '  ; else if (config.data_bss_contig == TRUE) return' >> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xz                 >> e${EMULATION_NAME}.c
 if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
 echo '  ; else if (link_info.combreloc) return'        >> e${EMULATION_NAME}.c
 sed $sc ldscripts/${EMULATION_NAME}.xc                 >> e${EMULATION_NAME}.c
@@ -1525,6 +1810,10 @@
     return "ldscripts/${EMULATION_NAME}.xs";
 EOF
 fi
+cat >>e${EMULATION_NAME}.c <<EOF
+  else if (config.data_bss_contig == TRUE)
+    return "ldscripts/${EMULATION_NAME}.xz";
+EOF
 if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
 cat >>e${EMULATION_NAME}.c <<EOF
   else if (link_info.combreloc)
--- binutils-2.15.orig/ld/genscripts.sh
+++ binutils-2.15/ld/genscripts.sh
@@ -178,16 +178,6 @@
   esac
 fi
 
-# Always search $(tooldir)/lib, aka /usr/local/TARGET/lib, except for
-# sysrooted configurations and when LIBPATH=":".
-if [ "x${use_sysroot}" != "xyes" ] ; then
-  case :${LIB_PATH}: in
-  ::: | *:${tool_lib}:*) ;;
-  ::) LIB_PATH=${tool_lib} ;;
-  *) LIB_PATH=${tool_lib}:${LIB_PATH} ;;
-  esac
-fi
-
 LIB_SEARCH_DIRS=`echo ${LIB_PATH} | sed -e 's/:/ /g' -e 's/\([^ ][^ ]*\)/SEARCH_DIR(\\"\1\\");/g'`
 
 # We need it for testsuite.
@@ -334,6 +324,14 @@
   unset CREATE_PIE
 fi
 
+LD_FLAG=Z
+DATA_ALIGNMENT=${DATA_ALIGNMENT_}
+RELOCATING=" "
+( echo "/* Script for -Z: traditional binaries with no PLT/GOT padding */"
+  . ${srcdir}/emulparams/${EMULATION_NAME}.sh
+  . ${srcdir}/scripttempl/${SCRIPT_NAME}.sc
+) | sed -e '/^ *$/d;s/[        ]*$//' > ldscripts/${EMULATION_NAME}.xz
+
 case " $EMULATION_LIBPATH " in
     *" ${EMULATION_NAME} "*) COMPILE_IN=true;;
 esac
--- binutils-2.15.orig/ld/ld.h
+++ binutils-2.15/ld/ld.h
@@ -201,6 +201,10 @@
 
   bfd_boolean text_read_only;
 
+  /* Classic ELF executable which has data and bss next to each
+     other with no padding for GOT/PLT. */
+  bfd_boolean data_bss_contig;
+
   char *map_filename;
   FILE *map_file;
 
--- binutils-2.15.orig/ld/ld.texinfo
+++ binutils-2.15/ld/ld.texinfo
@@ -940,6 +940,11 @@
 
 Other keywords are ignored for Solaris compatibility.  
 
+@kindex -Z
+@item -Z
+Produce 'Standard' executables, disables Writable XOR Executable features
+in resulting binaries.
+
 @kindex -(
 @cindex groups of archives
 @item -( @var{archives} -)
--- binutils-2.15.orig/ld/ldmain.c
+++ binutils-2.15/ld/ldmain.c
@@ -333,6 +333,7 @@
   force_make_executable = FALSE;
   config.magic_demand_paged = TRUE;
   config.text_read_only = TRUE;
+  config.data_bss_contig = FALSE;
 
   emulation = get_emulation (argc, argv);
   ldemul_choose_mode (emulation);
--- binutils-2.15.orig/ld/lexsup.c
+++ binutils-2.15/ld/lexsup.c
@@ -278,6 +278,9 @@
       'y', N_("SYMBOL"), N_("Trace mentions of SYMBOL"), TWO_DASHES },
   { {NULL, required_argument, NULL, '\0'},
       'Y', N_("PATH"), N_("Default search path for Solaris compatibility"), ONE_DASH },
+  { {"Zmagic", no_argument, NULL, 'Z'},
+      'Z', NULL, N_("Do not page align got/plt, old style executable"),
+      EXACTLY_TWO_DASHES },
   { {"start-group", no_argument, NULL, '('},
       '(', NULL, N_("Start a group"), TWO_DASHES },
   { {"end-group", no_argument, NULL, ')'},
@@ -1172,6 +1175,9 @@
 	case 'y':
 	  add_ysym (optarg);
 	  break;
+	case 'Z':
+	  config.data_bss_contig = TRUE;
+	  break;
 	case OPTION_SPARE_DYNAMIC_TAGS:
 	  link_info.spare_dynamic_tags = strtoul (optarg, NULL, 0);
 	  break;
--- binutils-2.15.orig/ld/scripttempl/elf.sc
+++ binutils-2.15/ld/scripttempl/elf.sc
@@ -116,6 +116,17 @@
   REL_SBSS2=".rel.sbss2    ${RELOCATING-0} : { *(.rel.sbss2${RELOCATING+ .rel.sbss2.* .rel.gnu.linkonce.sb2.*}) }
   .rela.sbss2   ${RELOCATING-0} : { *(.rela.sbss2${RELOCATING+ .rela.sbss2.* .rela.gnu.linkonce.sb2.*}) }"
 fi
+RODATA_ALIGN_ADD_VAL="${CREATE_SHLIB-${RODATA_ALIGN_ADD:-0}} ${CREATE_SHLIB+0}"
+test "$LD_FLAG" = "n" || test "$LD_FLAG" = "N" || test "$LD_FLAG" = "Z" || NO_PAD="y"
+if test "$NO_PAD" = "y" ; then
+  PAD_RO0="${RELOCATING+${RODATA_ALIGN} + ${RODATA_ALIGN_ADD_VAL};}"
+  PAD_PLT0="${RELOCATING+. = ALIGN(${MAXPAGESIZE}) + (. & (${MAXPAGESIZE} - 1));} .pltpad0 ${RELOCATING-0} : { ${RELOCATING+__plt_start = .;} }"
+  PAD_PLT1=".pltpad1 ${RELOCATING-0} : { ${RELOCATING+__plt_end = .;}} ${RELOCATING+. = ALIGN(${MAXPAGESIZE}) + (. & (${MAXPAGESIZE} - 1));}"
+  PAD_GOT0="${RELOCATING+. = ALIGN(${MAXPAGESIZE}) + (. & (${MAXPAGESIZE} - 1));} .gotpad0 ${RELOCATING-0} : { ${RELOCATING+__got_start = .;} }"
+  PAD_GOT1=".gotpad1 ${RELOCATING-0} : { ${RELOCATING+__got_end = .;}} ${RELOCATING+. = ALIGN(${MAXPAGESIZE}) + (. & (${MAXPAGESIZE} - 1));}"
+  test "$NO_PAD_CDTOR" = "y" || PAD_CDTOR=
+fi
+
 CTOR=".ctors        ${CONSTRUCTING-0} : 
   {
     ${CONSTRUCTING+${CTOR_START}}
@@ -259,7 +270,7 @@
     ${RELOCATING+${INIT_END}}
   } =${NOP-0}
 
-  ${DATA_PLT-${BSS_PLT-${PLT}}}
+  ${DATA_PLT-${DATA_NONEXEC_PLT-${BSS_PLT-${PLT}}}}
   .text         ${RELOCATING-0} :
   {
     ${RELOCATING+${TEXT_START_SYMBOLS}}
@@ -277,6 +288,7 @@
   ${RELOCATING+PROVIDE (__etext = .);}
   ${RELOCATING+PROVIDE (_etext = .);}
   ${RELOCATING+PROVIDE (etext = .);}
+  ${PAD_RO+${PAD_RO0}}
   ${WRITABLE_RODATA-${RODATA}}
   .rodata1      ${RELOCATING-0} : { *(.rodata1) }
   ${CREATE_SHLIB-${SDATA2}}
@@ -321,13 +333,24 @@
   ${WRITABLE_RODATA+${RODATA}}
   ${OTHER_READWRITE_SECTIONS}
   ${TEXT_DYNAMIC-${DYNAMIC}}
-  ${RELOCATING+${CTOR}}
-  ${RELOCATING+${DTOR}}
+  ${PAD_CDTOR-${RELOCATING+${CTOR}}}
+  ${PAD_CDTOR-${RELOCATING+${DTOR}}}
   .jcr          ${RELOCATING-0} : { KEEP (*(.jcr)) }
+
+  /* pad CTOR/DTOR, GOT (and PLT if DATA_PLT) to page aligned if PAD_GOT */
+  ${DATA_PLT+${PAD_PLT+${PAD_PLT0}}}
   ${DATA_PLT+${PLT}}
+  ${DATA_PLT+${PAD_PLT+${PAD_PLT1}}}
+  ${PAD_GOT+${PAD_GOT0}}
+  ${DATA_NONEXEC_PLT+${PLT}}
   ${RELOCATING+${OTHER_GOT_SYMBOLS}}
   ${GOT}
+  /* If PAD_CDTOR, CTOR and DTOR relocated here to receive mprotect
+     protection after relocation are finished same as GOT  */
+  ${PAD_CDTOR+${RELOCATING+${CTOR}}}
+  ${PAD_CDTOR+${RELOCATING+${DTOR}}}
   ${OTHER_GOT_SECTIONS}
+  ${PAD_GOT+${PAD_GOT1}}
   ${CREATE_SHLIB+${SDATA2}}
   ${CREATE_SHLIB+${SBSS2}}
   ${SDATA}
@@ -337,7 +360,9 @@
   ${RELOCATING+__bss_start = .;}
   ${RELOCATING+${OTHER_BSS_SYMBOLS}}
   ${SBSS}
+  ${BSS_PLT+${PAD_PLT+${PAD_PLT0}}}
   ${BSS_PLT+${PLT}}
+  ${BSS_PLT+${PAD_PLT+${PAD_PLT1}}}
   .bss          ${RELOCATING-0} :
   {
    *(.dynbss)
--- binutils-2.15.orig/ld/scripttempl/elf32avr.sc
+++ binutils-2.15/ld/scripttempl/elf32avr.sc
@@ -0,0 +1,151 @@
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}","${OUTPUT_FORMAT}","${OUTPUT_FORMAT}")
+OUTPUT_ARCH(${ARCH})
+
+MEMORY
+{
+  text   (rx)   : ORIGIN = 0,    LENGTH = $TEXT_LENGTH
+  data   (rw!x) : ORIGIN = (0x800000 + $DATA_START), LENGTH = $DATA_LENGTH
+  eeprom (rw!x) : ORIGIN = 0x810000, LENGTH = $EEPROM_LENGTH
+}
+
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  ${TEXT_DYNAMIC+${DYNAMIC}}
+  .hash        ${RELOCATING-0} : { *(.hash)		}
+  .dynsym      ${RELOCATING-0} : { *(.dynsym)		}
+  .dynstr      ${RELOCATING-0} : { *(.dynstr)		}
+  .gnu.version ${RELOCATING-0} : { *(.gnu.version)	}
+  .gnu.version_d ${RELOCATING-0} : { *(.gnu.version_d)	}
+  .gnu.version_r ${RELOCATING-0} : { *(.gnu.version_r)	}
+
+  .rel.init    ${RELOCATING-0} : { *(.rel.init)	}
+  .rela.init   ${RELOCATING-0} : { *(.rela.init)	}
+  .rel.text    ${RELOCATING-0} :
+    {
+      *(.rel.text)
+      ${RELOCATING+*(.rel.text.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.t*)}
+    }
+  .rela.text   ${RELOCATING-0} :
+    {
+      *(.rela.text)
+      ${RELOCATING+*(.rela.text.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.t*)}
+    }
+  .rel.fini    ${RELOCATING-0} : { *(.rel.fini)	}
+  .rela.fini   ${RELOCATING-0} : { *(.rela.fini)	}
+  .rel.rodata  ${RELOCATING-0} :
+    {
+      *(.rel.rodata)
+      ${RELOCATING+*(.rel.rodata.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.r*)}
+    }
+  .rela.rodata ${RELOCATING-0} :
+    {
+      *(.rela.rodata)
+      ${RELOCATING+*(.rela.rodata.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.r*)}
+    }
+  .rel.data    ${RELOCATING-0} :
+    {
+      *(.rel.data)
+      ${RELOCATING+*(.rel.data.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.d*)}
+    }
+  .rela.data   ${RELOCATING-0} :
+    {
+      *(.rela.data)
+      ${RELOCATING+*(.rela.data.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.d*)}
+    }
+  .rel.ctors   ${RELOCATING-0} : { *(.rel.ctors)	}
+  .rela.ctors  ${RELOCATING-0} : { *(.rela.ctors)	}
+  .rel.dtors   ${RELOCATING-0} : { *(.rel.dtors)	}
+  .rela.dtors  ${RELOCATING-0} : { *(.rela.dtors)	}
+  .rel.got     ${RELOCATING-0} : { *(.rel.got)		}
+  .rela.got    ${RELOCATING-0} : { *(.rela.got)		}
+  .rel.bss     ${RELOCATING-0} : { *(.rel.bss)		}
+  .rela.bss    ${RELOCATING-0} : { *(.rela.bss)		}
+  .rel.plt     ${RELOCATING-0} : { *(.rel.plt)		}
+  .rela.plt    ${RELOCATING-0} : { *(.rela.plt)		}
+
+  /* Internal text space or external memory */
+  .text :
+  {
+    *(.init)
+    *(.progmem.gcc*)
+    *(.progmem*)
+    ${RELOCATING+. = ALIGN(2);}
+    *(.text)
+    ${RELOCATING+. = ALIGN(2);}
+    *(.text.*)
+    ${RELOCATING+. = ALIGN(2);}
+    *(.fini)
+    ${RELOCATING+ _etext = . ; }
+  } ${RELOCATING+ > text}
+
+  .data	${RELOCATING-0} : ${RELOCATING+AT (ADDR (.text) + SIZEOF (.text))}
+  {
+    ${RELOCATING+ PROVIDE (__data_start = .) ; }
+    *(.data)
+    *(.gnu.linkonce.d*)
+    ${RELOCATING+. = ALIGN(2);}
+    ${RELOCATING+ _edata = . ; }
+  } ${RELOCATING+ > data}
+
+  .bss ${RELOCATING+ SIZEOF(.data) + ADDR(.data)} :
+  {
+    ${RELOCATING+ PROVIDE (__bss_start = .) ; }
+    *(.bss)
+    *(COMMON)
+    ${RELOCATING+ PROVIDE (__bss_end = .) ; }
+    ${RELOCATING+ _end = . ;  }
+  } ${RELOCATING+ > data}
+
+  .eeprom ${RELOCATING-0}:
+	${RELOCATING+AT (ADDR (.text) + SIZEOF (.text) + SIZEOF (.data))}
+  {
+    *(.eeprom*)
+    ${RELOCATING+ __eeprom_end = . ; }
+  } ${RELOCATING+ > eeprom}
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+ 
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info) *(.gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+
+  PROVIDE (__stack = ${STACK}) ;
+}
+EOF
+
--- binutils-2.15.orig/opcodes/i386-dis.c
+++ binutils-2.15/opcodes/i386-dis.c
@@ -93,9 +93,10 @@
 static void OP_XS (int, int);
 static void OP_M (int, int);
 static void OP_0fae (int, int);
-static void OP_0f07 (int, int);
 static void NOP_Fixup (int, int);
 static void OP_3DNowSuffix (int, int);
+static void OP_xcrypt2 (int, int);
+static void OP_xcrypt (int, int);
 static void OP_SIMD_Suffix (int, int);
 static void SIMD_Fixup (int, int);
 static void PNI_Fixup (int, int);
@@ -297,6 +298,8 @@
 #define MS OP_MS, v_mode
 #define XS OP_XS, v_mode
 #define OPSUF OP_3DNowSuffix, 0
+#define OPXCRYPT OP_xcrypt, 0
+#define OPXCRYPT2 OP_xcrypt2, 0
 #define OPSIMD OP_SIMD_Suffix, 0
 
 #define cond_jump_flag NULL, cond_jump_mode
@@ -393,7 +396,6 @@
 #define GRP13	  NULL, NULL, USE_GROUPS, NULL, 20, NULL, 0
 #define GRP14	  NULL, NULL, USE_GROUPS, NULL, 21, NULL, 0
 #define GRPAMD	  NULL, NULL, USE_GROUPS, NULL, 22, NULL, 0
-#define GRPPADLCK NULL, NULL, USE_GROUPS, NULL, 23, NULL, 0
 
 #define PREGRP0   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  0, NULL, 0
 #define PREGRP1   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  1, NULL, 0
@@ -952,8 +954,8 @@
   { "btS",		Ev, Gv, XX },
   { "shldS",		Ev, Gv, Ib },
   { "shldS",		Ev, Gv, CL },
-  { "(bad)",		XX, XX, XX },
-  { GRPPADLCK },
+  { "",			OPXCRYPT2, XX, XX },
+  { "",			OPXCRYPT, XX, XX },
   /* a8 */
   { "pushT",		gs, XX, XX },
   { "popT",		gs, XX, XX },
@@ -1455,17 +1457,6 @@
     { "(bad)",	XX, XX, XX },
     { "(bad)",	XX, XX, XX },
   },
-  /* GRPPADLCK */
-  {
-    { "xstorerng", OP_0f07, 0, XX, XX },
-    { "xcryptecb", OP_0f07, 0, XX, XX },
-    { "xcryptcbc", OP_0f07, 0, XX, XX },
-    { "(bad)",	   OP_0f07, 0, XX, XX },
-    { "xcryptcfb", OP_0f07, 0, XX, XX },
-    { "xcryptofb", OP_0f07, 0, XX, XX },
-    { "(bad)",	   OP_0f07, 0, XX, XX },
-    { "(bad)",	   OP_0f07, 0, XX, XX },
-  }
 };
 
 static const struct dis386 prefix_user_table[][4] = {
@@ -3961,15 +3952,6 @@
 }
 
 static void
-OP_0f07 (int bytemode, int sizeflag)
-{
-  if (mod != 3 || rm != 0)
-    BadOp ();
-  else
-    OP_E (bytemode, sizeflag);
-}
-
-static void
 OP_0fae (int bytemode, int sizeflag)
 {
   if (mod == 3)
@@ -4199,6 +4181,75 @@
     OP_E (bytemode, sizeflag);
 }
 
+static struct {
+     unsigned char opc;
+     char *name;
+} xcrypt[] = {
+  {  0xc0, "xstore-rng" },
+  {  0xc8, "xcrypt-ecb" },
+  {  0xd0, "xcrypt-cbc" },
+  {  0xd8, "xcrypt-ctr" },
+  {  0xe0, "xcrypt-cfb" },
+  {  0xe8, "xcrypt-ofb" },
+};
+
+static struct {
+     unsigned char opc;
+     char *name;
+} xcrypt2[] = {
+  {  0xc0, "montmul" },
+  {  0xc8, "xsha1" },
+  {  0xd0, "xsha256" },
+};
+
+static void
+OP_xcrypt (bytemode, sizeflag)
+     int bytemode ATTRIBUTE_UNUSED;
+     int sizeflag ATTRIBUTE_UNUSED;
+{
+  const char *mnemonic = NULL;
+  unsigned int i;
+
+  FETCH_DATA (the_info, codep + 1);
+  /* VIA C3 xcrypt-* & xmove-* instructions are specified by an opcode
+     suffix in the place where an 8-bit immediate would normally go.
+     ie. the last byte of the instruction.  */
+  obufp = obuf + strlen(obuf);
+
+  for (i = 0; i < sizeof(xcrypt) / sizeof(xcrypt[0]); i++)
+    if (xcrypt[i].opc == (*codep & 0xff))
+      mnemonic = xcrypt[i].name;
+  codep++;
+  if (mnemonic)
+    oappend (mnemonic);
+  else
+    BadOp();
+}
+
+static void
+OP_xcrypt2 (bytemode, sizeflag)
+     int bytemode ATTRIBUTE_UNUSED;
+     int sizeflag ATTRIBUTE_UNUSED;
+{
+  const char *mnemonic = NULL;
+  unsigned int i;
+
+  FETCH_DATA (the_info, codep + 1);
+  /* VIA C3 xcrypt2 instructions are specified by an opcode
+     suffix in the place where an 8-bit immediate would normally go.
+     ie. the last byte of the instruction.  */
+  obufp = obuf + strlen(obuf);
+
+  for (i = 0; i < sizeof(xcrypt2) / sizeof(xcrypt2[0]); i++)
+    if (xcrypt2[i].opc == (*codep & 0xff))
+      mnemonic = xcrypt2[i].name;
+  codep++;
+  if (mnemonic)
+    oappend (mnemonic);
+  else
+    BadOp();
+ }
+
 static void
 BadOp (void)
 {

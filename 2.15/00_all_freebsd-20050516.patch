diff -urp --unidirectional-new-file binutils-2.15/bfd/elf.c binutils-freebsd/bfd/elf.c
--- binutils-2.15/bfd/elf.c	2004-05-17 15:35:57.000000000 -0400
+++ binutils-freebsd/bfd/elf.c	2005-05-11 15:52:17.000000000 -0400
@@ -4318,6 +4318,8 @@ prep_headers (bfd *abfd)
     bfd_big_endian (abfd) ? ELFDATA2MSB : ELFDATA2LSB;
   i_ehdrp->e_ident[EI_VERSION] = bed->s->ev_current;
 
+  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
+
   if ((abfd->flags & DYNAMIC) != 0)
     i_ehdrp->e_type = ET_DYN;
   else if ((abfd->flags & EXEC_P) != 0)
diff -urp --unidirectional-new-file binutils-2.15/bfd/elf32-i386-fbsd.c binutils-freebsd/bfd/elf32-i386-fbsd.c
--- binutils-2.15/bfd/elf32-i386-fbsd.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/bfd/elf32-i386-fbsd.c	2002-10-11 05:15:11.000000000 -0400
@@ -0,0 +1,56 @@
+/* Intel IA-32 specific support for 32-bit ELF on FreeBSD.
+   Copyright 2002 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#define TARGET_LITTLE_SYM	bfd_elf32_i386_freebsd_vec
+#define TARGET_LITTLE_NAME	"elf32-i386-freebsd"
+#define ELF_ARCH		bfd_arch_i386
+#define ELF_MACHINE_CODE	EM_386
+#define ELF_MAXPAGESIZE		0x1000
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "elf-bfd.h"
+
+/* The kernel recognizes executables as valid only if they carry a
+   "FreeBSD" label in the ELF header.  So we put this label on all
+   executables and (for simplicity) also all other object files.  */
+
+static void elf_i386_post_process_headers
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+static void
+elf_i386_post_process_headers (abfd, link_info)
+     bfd * abfd;
+     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
+{
+  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */
+
+  i_ehdrp = elf_elfheader (abfd);
+
+  /* Put an ABI label supported by FreeBSD >= 4.1.  */
+  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
+#ifdef OLD_FREEBSD_ABI_LABEL
+  /* The ABI label supported by FreeBSD <= 4.0 is quite nonstandard.  */
+  memcpy (&i_ehdrp->e_ident[EI_ABIVERSION], "FreeBSD", 8);
+#endif
+}
+
+#define elf_backend_post_process_headers	elf_i386_post_process_headers
+
+#include "elf32-i386.c"
diff -urp --unidirectional-new-file binutils-2.15/bfd/elf64-alpha-fbsd.c binutils-freebsd/bfd/elf64-alpha-fbsd.c
--- binutils-2.15/bfd/elf64-alpha-fbsd.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/bfd/elf64-alpha-fbsd.c	2002-10-11 05:15:11.000000000 -0400
@@ -0,0 +1,56 @@
+/* Alpha specific support for 64-bit ELF on FreeBSD.
+   Copyright 2002 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#define TARGET_LITTLE_SYM	bfd_elf64_alpha_freebsd_vec
+#define TARGET_LITTLE_NAME	"elf64-alpha-freebsd"
+#define ELF_ARCH		bfd_arch_alpha
+#define ELF_MACHINE_CODE	EM_ALPHA
+#define ELF_MAXPAGESIZE		0x10000
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "elf-bfd.h"
+
+/* The kernel recognizes executables as valid only if they carry a
+   "FreeBSD" label in the ELF header.  So we put this label on all
+   executables and (for simplicity) also all other object files.  */
+
+static void elf_alpha_post_process_headers
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+static void
+elf_alpha_post_process_headers (abfd, link_info)
+     bfd * abfd;
+     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
+{
+  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */
+
+  i_ehdrp = elf_elfheader (abfd);
+
+  /* Put an ABI label supported by FreeBSD >= 4.1.  */
+  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
+#ifdef OLD_FREEBSD_ABI_LABEL
+  /* The ABI label supported by FreeBSD <= 4.0 is quite nonstandard.  */
+  memcpy (&i_ehdrp->e_ident[EI_ABIVERSION], "FreeBSD", 8);
+#endif
+}
+
+#define elf_backend_post_process_headers	elf_alpha_post_process_headers
+
+#include "elf64-alpha.c"
diff -urp --unidirectional-new-file binutils-2.15/bfd/elflink.h binutils-freebsd/bfd/elflink.h
--- binutils-2.15/bfd/elflink.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/bfd/elflink.h	2002-12-02 04:39:02.000000000 -0500
@@ -0,0 +1,8532 @@
+/* ELF linker support.
+   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
+   Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* ELF linker code.  */
+
+/* This struct is used to pass information to routines called via
+   elf_link_hash_traverse which must return failure.  */
+
+struct elf_info_failed
+{
+  boolean failed;
+  struct bfd_link_info *info;
+  struct bfd_elf_version_tree *verdefs;
+};
+
+static boolean is_global_data_symbol_definition
+  PARAMS ((bfd *, Elf_Internal_Sym *));
+static boolean elf_link_is_defined_archive_symbol
+  PARAMS ((bfd *, carsym *));
+static boolean elf_link_add_object_symbols
+  PARAMS ((bfd *, struct bfd_link_info *));
+static boolean elf_link_add_archive_symbols
+  PARAMS ((bfd *, struct bfd_link_info *));
+static boolean elf_merge_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, const char *,
+	   Elf_Internal_Sym *, asection **, bfd_vma *,
+	   struct elf_link_hash_entry **, boolean *, boolean *,
+	   boolean *, boolean));
+static boolean elf_add_default_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
+	   const char *, Elf_Internal_Sym *, asection **, bfd_vma *,
+	   boolean *, boolean, boolean));
+static boolean elf_export_symbol
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static boolean elf_finalize_dynstr
+  PARAMS ((bfd *, struct bfd_link_info *));
+static boolean elf_fix_symbol_flags
+  PARAMS ((struct elf_link_hash_entry *, struct elf_info_failed *));
+static boolean elf_adjust_dynamic_symbol
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static boolean elf_link_find_version_dependencies
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static boolean elf_link_assign_sym_version
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static boolean elf_collect_hash_codes
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static boolean elf_link_read_relocs_from_section
+  PARAMS ((bfd *, Elf_Internal_Shdr *, PTR, Elf_Internal_Rela *));
+static size_t compute_bucket_count
+  PARAMS ((struct bfd_link_info *));
+static boolean elf_link_output_relocs
+  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *));
+static boolean elf_link_size_reloc_section
+  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
+static void elf_link_adjust_relocs
+  PARAMS ((bfd *, Elf_Internal_Shdr *, unsigned int,
+	   struct elf_link_hash_entry **));
+static int elf_link_sort_cmp1
+  PARAMS ((const void *, const void *));
+static int elf_link_sort_cmp2
+  PARAMS ((const void *, const void *));
+static size_t elf_link_sort_relocs
+  PARAMS ((bfd *, struct bfd_link_info *, asection **));
+static boolean elf_section_ignore_discarded_relocs
+  PARAMS ((asection *));
+
+/* Given an ELF BFD, add symbols to the global hash table as
+   appropriate.  */
+
+boolean
+elf_bfd_link_add_symbols (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  switch (bfd_get_format (abfd))
+    {
+    case bfd_object:
+      return elf_link_add_object_symbols (abfd, info);
+    case bfd_archive:
+      return elf_link_add_archive_symbols (abfd, info);
+    default:
+      bfd_set_error (bfd_error_wrong_format);
+      return false;
+    }
+}
+
+/* Return true iff this is a non-common, definition of a non-function symbol.  */
+static boolean
+is_global_data_symbol_definition (abfd, sym)
+     bfd * abfd ATTRIBUTE_UNUSED;
+     Elf_Internal_Sym * sym;
+{
+  /* Local symbols do not count, but target specific ones might.  */
+  if (ELF_ST_BIND (sym->st_info) != STB_GLOBAL
+      && ELF_ST_BIND (sym->st_info) < STB_LOOS)
+    return false;
+
+  /* Function symbols do not count.  */
+  if (ELF_ST_TYPE (sym->st_info) == STT_FUNC)
+    return false;
+
+  /* If the section is undefined, then so is the symbol.  */
+  if (sym->st_shndx == SHN_UNDEF)
+    return false;
+
+  /* If the symbol is defined in the common section, then
+     it is a common definition and so does not count.  */
+  if (sym->st_shndx == SHN_COMMON)
+    return false;
+
+  /* If the symbol is in a target specific section then we
+     must rely upon the backend to tell us what it is.  */
+  if (sym->st_shndx >= SHN_LORESERVE && sym->st_shndx < SHN_ABS)
+    /* FIXME - this function is not coded yet:
+
+       return _bfd_is_global_symbol_definition (abfd, sym);
+
+       Instead for now assume that the definition is not global,
+       Even if this is wrong, at least the linker will behave
+       in the same way that it used to do.  */
+    return false;
+
+  return true;
+}
+
+/* Search the symbol table of the archive element of the archive ABFD
+   whose archive map contains a mention of SYMDEF, and determine if
+   the symbol is defined in this element.  */
+static boolean
+elf_link_is_defined_archive_symbol (abfd, symdef)
+     bfd * abfd;
+     carsym * symdef;
+{
+  Elf_Internal_Shdr * hdr;
+  bfd_size_type symcount;
+  bfd_size_type extsymcount;
+  bfd_size_type extsymoff;
+  Elf_Internal_Sym *isymbuf;
+  Elf_Internal_Sym *isym;
+  Elf_Internal_Sym *isymend;
+  boolean result;
+
+  abfd = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
+  if (abfd == (bfd *) NULL)
+    return false;
+
+  if (! bfd_check_format (abfd, bfd_object))
+    return false;
+
+  /* If we have already included the element containing this symbol in the
+     link then we do not need to include it again.  Just claim that any symbol
+     it contains is not a definition, so that our caller will not decide to
+     (re)include this element.  */
+  if (abfd->archive_pass)
+    return false;
+
+  /* Select the appropriate symbol table.  */
+  if ((abfd->flags & DYNAMIC) == 0 || elf_dynsymtab (abfd) == 0)
+    hdr = &elf_tdata (abfd)->symtab_hdr;
+  else
+    hdr = &elf_tdata (abfd)->dynsymtab_hdr;
+
+  symcount = hdr->sh_size / sizeof (Elf_External_Sym);
+
+  /* The sh_info field of the symtab header tells us where the
+     external symbols start.  We don't care about the local symbols.  */
+  if (elf_bad_symtab (abfd))
+    {
+      extsymcount = symcount;
+      extsymoff = 0;
+    }
+  else
+    {
+      extsymcount = symcount - hdr->sh_info;
+      extsymoff = hdr->sh_info;
+    }
+
+  if (extsymcount == 0)
+    return false;
+
+  /* Read in the symbol table.  */
+  isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
+				  NULL, NULL, NULL);
+  if (isymbuf == NULL)
+    return false;
+
+  /* Scan the symbol table looking for SYMDEF.  */
+  result = false;
+  for (isym = isymbuf, isymend = isymbuf + extsymcount; isym < isymend; isym++)
+    {
+      const char *name;
+
+      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
+					      isym->st_name);
+      if (name == (const char *) NULL)
+	break;
+
+      if (strcmp (name, symdef->name) == 0)
+	{
+	  result = is_global_data_symbol_definition (abfd, isym);
+	  break;
+	}
+    }
+
+  free (isymbuf);
+
+  return result;
+}
+
+/* Add symbols from an ELF archive file to the linker hash table.  We
+   don't use _bfd_generic_link_add_archive_symbols because of a
+   problem which arises on UnixWare.  The UnixWare libc.so is an
+   archive which includes an entry libc.so.1 which defines a bunch of
+   symbols.  The libc.so archive also includes a number of other
+   object files, which also define symbols, some of which are the same
+   as those defined in libc.so.1.  Correct linking requires that we
+   consider each object file in turn, and include it if it defines any
+   symbols we need.  _bfd_generic_link_add_archive_symbols does not do
+   this; it looks through the list of undefined symbols, and includes
+   any object file which defines them.  When this algorithm is used on
+   UnixWare, it winds up pulling in libc.so.1 early and defining a
+   bunch of symbols.  This means that some of the other objects in the
+   archive are not included in the link, which is incorrect since they
+   precede libc.so.1 in the archive.
+
+   Fortunately, ELF archive handling is simpler than that done by
+   _bfd_generic_link_add_archive_symbols, which has to allow for a.out
+   oddities.  In ELF, if we find a symbol in the archive map, and the
+   symbol is currently undefined, we know that we must pull in that
+   object file.
+
+   Unfortunately, we do have to make multiple passes over the symbol
+   table until nothing further is resolved.  */
+
+static boolean
+elf_link_add_archive_symbols (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  symindex c;
+  boolean *defined = NULL;
+  boolean *included = NULL;
+  carsym *symdefs;
+  boolean loop;
+  bfd_size_type amt;
+
+  if (! bfd_has_map (abfd))
+    {
+      /* An empty archive is a special case.  */
+      if (bfd_openr_next_archived_file (abfd, (bfd *) NULL) == NULL)
+	return true;
+      bfd_set_error (bfd_error_no_armap);
+      return false;
+    }
+
+  /* Keep track of all symbols we know to be already defined, and all
+     files we know to be already included.  This is to speed up the
+     second and subsequent passes.  */
+  c = bfd_ardata (abfd)->symdef_count;
+  if (c == 0)
+    return true;
+  amt = c;
+  amt *= sizeof (boolean);
+  defined = (boolean *) bfd_zmalloc (amt);
+  included = (boolean *) bfd_zmalloc (amt);
+  if (defined == (boolean *) NULL || included == (boolean *) NULL)
+    goto error_return;
+
+  symdefs = bfd_ardata (abfd)->symdefs;
+
+  do
+    {
+      file_ptr last;
+      symindex i;
+      carsym *symdef;
+      carsym *symdefend;
+
+      loop = false;
+      last = -1;
+
+      symdef = symdefs;
+      symdefend = symdef + c;
+      for (i = 0; symdef < symdefend; symdef++, i++)
+	{
+	  struct elf_link_hash_entry *h;
+	  bfd *element;
+	  struct bfd_link_hash_entry *undefs_tail;
+	  symindex mark;
+
+	  if (defined[i] || included[i])
+	    continue;
+	  if (symdef->file_offset == last)
+	    {
+	      included[i] = true;
+	      continue;
+	    }
+
+	  h = elf_link_hash_lookup (elf_hash_table (info), symdef->name,
+				    false, false, false);
+
+	  if (h == NULL)
+	    {
+	      char *p, *copy;
+	      size_t len, first;
+
+	      /* If this is a default version (the name contains @@),
+		 look up the symbol again with only one `@' as well
+		 as without the version.  The effect is that references
+		 to the symbol with and without the version will be
+		 matched by the default symbol in the archive.  */
+
+	      p = strchr (symdef->name, ELF_VER_CHR);
+	      if (p == NULL || p[1] != ELF_VER_CHR)
+		continue;
+
+	      /* First check with only one `@'.  */
+	      len = strlen (symdef->name);
+	      copy = bfd_alloc (abfd, (bfd_size_type) len);
+	      if (copy == NULL)
+		goto error_return;
+	      first = p - symdef->name + 1;
+	      memcpy (copy, symdef->name, first);
+	      memcpy (copy + first, symdef->name + first + 1, len - first);
+
+	      h = elf_link_hash_lookup (elf_hash_table (info), copy,
+					false, false, false);
+
+	      if (h == NULL)
+		{
+		  /* We also need to check references to the symbol
+		     without the version.  */
+
+		  copy[first - 1] = '\0';
+		  h = elf_link_hash_lookup (elf_hash_table (info),
+					    copy, false, false, false);
+		}
+
+	      bfd_release (abfd, copy);
+	    }
+
+	  if (h == NULL)
+	    continue;
+
+	  if (h->root.type == bfd_link_hash_common)
+	    {
+	      /* We currently have a common symbol.  The archive map contains
+		 a reference to this symbol, so we may want to include it.  We
+		 only want to include it however, if this archive element
+		 contains a definition of the symbol, not just another common
+		 declaration of it.
+
+		 Unfortunately some archivers (including GNU ar) will put
+		 declarations of common symbols into their archive maps, as
+		 well as real definitions, so we cannot just go by the archive
+		 map alone.  Instead we must read in the element's symbol
+		 table and check that to see what kind of symbol definition
+		 this is.  */
+	      if (! elf_link_is_defined_archive_symbol (abfd, symdef))
+		continue;
+	    }
+	  else if (h->root.type != bfd_link_hash_undefined)
+	    {
+	      if (h->root.type != bfd_link_hash_undefweak)
+		defined[i] = true;
+	      continue;
+	    }
+
+	  /* We need to include this archive member.  */
+	  element = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
+	  if (element == (bfd *) NULL)
+	    goto error_return;
+
+	  if (! bfd_check_format (element, bfd_object))
+	    goto error_return;
+
+	  /* Doublecheck that we have not included this object
+	     already--it should be impossible, but there may be
+	     something wrong with the archive.  */
+	  if (element->archive_pass != 0)
+	    {
+	      bfd_set_error (bfd_error_bad_value);
+	      goto error_return;
+	    }
+	  element->archive_pass = 1;
+
+	  undefs_tail = info->hash->undefs_tail;
+
+	  if (! (*info->callbacks->add_archive_element) (info, element,
+							 symdef->name))
+	    goto error_return;
+	  if (! elf_link_add_object_symbols (element, info))
+	    goto error_return;
+
+	  /* If there are any new undefined symbols, we need to make
+	     another pass through the archive in order to see whether
+	     they can be defined.  FIXME: This isn't perfect, because
+	     common symbols wind up on undefs_tail and because an
+	     undefined symbol which is defined later on in this pass
+	     does not require another pass.  This isn't a bug, but it
+	     does make the code less efficient than it could be.  */
+	  if (undefs_tail != info->hash->undefs_tail)
+	    loop = true;
+
+	  /* Look backward to mark all symbols from this object file
+	     which we have already seen in this pass.  */
+	  mark = i;
+	  do
+	    {
+	      included[mark] = true;
+	      if (mark == 0)
+		break;
+	      --mark;
+	    }
+	  while (symdefs[mark].file_offset == symdef->file_offset);
+
+	  /* We mark subsequent symbols from this object file as we go
+	     on through the loop.  */
+	  last = symdef->file_offset;
+	}
+    }
+  while (loop);
+
+  free (defined);
+  free (included);
+
+  return true;
+
+ error_return:
+  if (defined != (boolean *) NULL)
+    free (defined);
+  if (included != (boolean *) NULL)
+    free (included);
+  return false;
+}
+
+/* This function is called when we want to define a new symbol.  It
+   handles the various cases which arise when we find a definition in
+   a dynamic object, or when there is already a definition in a
+   dynamic object.  The new symbol is described by NAME, SYM, PSEC,
+   and PVALUE.  We set SYM_HASH to the hash table entry.  We set
+   OVERRIDE if the old symbol is overriding a new definition.  We set
+   TYPE_CHANGE_OK if it is OK for the type to change.  We set
+   SIZE_CHANGE_OK if it is OK for the size to change.  By OK to
+   change, we mean that we shouldn't warn if the type or size does
+   change. DT_NEEDED indicates if it comes from a DT_NEEDED entry of
+   a shared object.  */
+
+static boolean
+elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash,
+		  override, type_change_ok, size_change_ok, dt_needed)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     const char *name;
+     Elf_Internal_Sym *sym;
+     asection **psec;
+     bfd_vma *pvalue;
+     struct elf_link_hash_entry **sym_hash;
+     boolean *override;
+     boolean *type_change_ok;
+     boolean *size_change_ok;
+     boolean dt_needed;
+{
+  asection *sec;
+  struct elf_link_hash_entry *h;
+  int bind;
+  bfd *oldbfd;
+  boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
+
+  *override = false;
+
+  sec = *psec;
+  bind = ELF_ST_BIND (sym->st_info);
+
+  if (! bfd_is_und_section (sec))
+    h = elf_link_hash_lookup (elf_hash_table (info), name, true, false, false);
+  else
+    h = ((struct elf_link_hash_entry *)
+	 bfd_wrapped_link_hash_lookup (abfd, info, name, true, false, false));
+  if (h == NULL)
+    return false;
+  *sym_hash = h;
+
+  /* This code is for coping with dynamic objects, and is only useful
+     if we are doing an ELF link.  */
+  if (info->hash->creator != abfd->xvec)
+    return true;
+
+  /* For merging, we only care about real symbols.  */
+
+  while (h->root.type == bfd_link_hash_indirect
+	 || h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* If we just created the symbol, mark it as being an ELF symbol.
+     Other than that, there is nothing to do--there is no merge issue
+     with a newly defined symbol--so we just return.  */
+
+  if (h->root.type == bfd_link_hash_new)
+    {
+      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
+      return true;
+    }
+
+  /* OLDBFD is a BFD associated with the existing symbol.  */
+
+  switch (h->root.type)
+    {
+    default:
+      oldbfd = NULL;
+      break;
+
+    case bfd_link_hash_undefined:
+    case bfd_link_hash_undefweak:
+      oldbfd = h->root.u.undef.abfd;
+      break;
+
+    case bfd_link_hash_defined:
+    case bfd_link_hash_defweak:
+      oldbfd = h->root.u.def.section->owner;
+      break;
+
+    case bfd_link_hash_common:
+      oldbfd = h->root.u.c.p->section->owner;
+      break;
+    }
+
+  /* In cases involving weak versioned symbols, we may wind up trying
+     to merge a symbol with itself.  Catch that here, to avoid the
+     confusion that results if we try to override a symbol with
+     itself.  The additional tests catch cases like
+     _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a
+     dynamic object, which we do want to handle here.  */
+  if (abfd == oldbfd
+      && ((abfd->flags & DYNAMIC) == 0
+	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
+    return true;
+
+  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
+     respectively, is from a dynamic object.  */
+
+  if ((abfd->flags & DYNAMIC) != 0)
+    newdyn = true;
+  else
+    newdyn = false;
+
+  if (oldbfd != NULL)
+    olddyn = (oldbfd->flags & DYNAMIC) != 0;
+  else
+    {
+      asection *hsec;
+
+      /* This code handles the special SHN_MIPS_{TEXT,DATA} section
+	 indices used by MIPS ELF.  */
+      switch (h->root.type)
+	{
+	default:
+	  hsec = NULL;
+	  break;
+
+	case bfd_link_hash_defined:
+	case bfd_link_hash_defweak:
+	  hsec = h->root.u.def.section;
+	  break;
+
+	case bfd_link_hash_common:
+	  hsec = h->root.u.c.p->section;
+	  break;
+	}
+
+      if (hsec == NULL)
+	olddyn = false;
+      else
+	olddyn = (hsec->symbol->flags & BSF_DYNAMIC) != 0;
+    }
+
+  /* NEWDEF and OLDDEF indicate whether the new or old symbol,
+     respectively, appear to be a definition rather than reference.  */
+
+  if (bfd_is_und_section (sec) || bfd_is_com_section (sec))
+    newdef = false;
+  else
+    newdef = true;
+
+  if (h->root.type == bfd_link_hash_undefined
+      || h->root.type == bfd_link_hash_undefweak
+      || h->root.type == bfd_link_hash_common)
+    olddef = false;
+  else
+    olddef = true;
+
+  /* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old
+     symbol, respectively, appears to be a common symbol in a dynamic
+     object.  If a symbol appears in an uninitialized section, and is
+     not weak, and is not a function, then it may be a common symbol
+     which was resolved when the dynamic object was created.  We want
+     to treat such symbols specially, because they raise special
+     considerations when setting the symbol size: if the symbol
+     appears as a common symbol in a regular object, and the size in
+     the regular object is larger, we must make sure that we use the
+     larger size.  This problematic case can always be avoided in C,
+     but it must be handled correctly when using Fortran shared
+     libraries.
+
+     Note that if NEWDYNCOMMON is set, NEWDEF will be set, and
+     likewise for OLDDYNCOMMON and OLDDEF.
+
+     Note that this test is just a heuristic, and that it is quite
+     possible to have an uninitialized symbol in a shared object which
+     is really a definition, rather than a common symbol.  This could
+     lead to some minor confusion when the symbol really is a common
+     symbol in some regular object.  However, I think it will be
+     harmless.  */
+
+  if (newdyn
+      && newdef
+      && (sec->flags & SEC_ALLOC) != 0
+      && (sec->flags & SEC_LOAD) == 0
+      && sym->st_size > 0
+      && bind != STB_WEAK
+      && ELF_ST_TYPE (sym->st_info) != STT_FUNC)
+    newdyncommon = true;
+  else
+    newdyncommon = false;
+
+  if (olddyn
+      && olddef
+      && h->root.type == bfd_link_hash_defined
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
+      && (h->root.u.def.section->flags & SEC_LOAD) == 0
+      && h->size > 0
+      && h->type != STT_FUNC)
+    olddyncommon = true;
+  else
+    olddyncommon = false;
+
+  /* It's OK to change the type if either the existing symbol or the
+     new symbol is weak unless it comes from a DT_NEEDED entry of
+     a shared object, in which case, the DT_NEEDED entry may not be
+     required at the run time.  */
+
+  if ((! dt_needed && h->root.type == bfd_link_hash_defweak)
+      || h->root.type == bfd_link_hash_undefweak
+      || bind == STB_WEAK)
+    *type_change_ok = true;
+
+  /* It's OK to change the size if either the existing symbol or the
+     new symbol is weak, or if the old symbol is undefined.  */
+
+  if (*type_change_ok
+      || h->root.type == bfd_link_hash_undefined)
+    *size_change_ok = true;
+
+  /* If both the old and the new symbols look like common symbols in a
+     dynamic object, set the size of the symbol to the larger of the
+     two.  */
+
+  if (olddyncommon
+      && newdyncommon
+      && sym->st_size != h->size)
+    {
+      /* Since we think we have two common symbols, issue a multiple
+	 common warning if desired.  Note that we only warn if the
+	 size is different.  If the size is the same, we simply let
+	 the old symbol override the new one as normally happens with
+	 symbols defined in dynamic objects.  */
+
+      if (! ((*info->callbacks->multiple_common)
+	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
+	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
+	return false;
+
+      if (sym->st_size > h->size)
+	h->size = sym->st_size;
+
+      *size_change_ok = true;
+    }
+
+  /* If we are looking at a dynamic object, and we have found a
+     definition, we need to see if the symbol was already defined by
+     some other object.  If so, we want to use the existing
+     definition, and we do not want to report a multiple symbol
+     definition error; we do this by clobbering *PSEC to be
+     bfd_und_section_ptr.
+
+     We treat a common symbol as a definition if the symbol in the
+     shared library is a function, since common symbols always
+     represent variables; this can cause confusion in principle, but
+     any such confusion would seem to indicate an erroneous program or
+     shared library.  We also permit a common symbol in a regular
+     object to override a weak symbol in a shared object.
+
+     We prefer a non-weak definition in a shared library to a weak
+     definition in the executable unless it comes from a DT_NEEDED
+     entry of a shared object, in which case, the DT_NEEDED entry
+     may not be required at the run time.  */
+
+  if (newdyn
+      && newdef
+      && (olddef
+	  || (h->root.type == bfd_link_hash_common
+	      && (bind == STB_WEAK
+		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC)))
+      && (h->root.type != bfd_link_hash_defweak
+	  || dt_needed
+	  || bind == STB_WEAK))
+    {
+      *override = true;
+      newdef = false;
+      newdyncommon = false;
+
+      *psec = sec = bfd_und_section_ptr;
+      *size_change_ok = true;
+
+      /* If we get here when the old symbol is a common symbol, then
+	 we are explicitly letting it override a weak symbol or
+	 function in a dynamic object, and we don't want to warn about
+	 a type change.  If the old symbol is a defined symbol, a type
+	 change warning may still be appropriate.  */
+
+      if (h->root.type == bfd_link_hash_common)
+	*type_change_ok = true;
+    }
+
+  /* Handle the special case of an old common symbol merging with a
+     new symbol which looks like a common symbol in a shared object.
+     We change *PSEC and *PVALUE to make the new symbol look like a
+     common symbol, and let _bfd_generic_link_add_one_symbol will do
+     the right thing.  */
+
+  if (newdyncommon
+      && h->root.type == bfd_link_hash_common)
+    {
+      *override = true;
+      newdef = false;
+      newdyncommon = false;
+      *pvalue = sym->st_size;
+      *psec = sec = bfd_com_section_ptr;
+      *size_change_ok = true;
+    }
+
+  /* If the old symbol is from a dynamic object, and the new symbol is
+     a definition which is not from a dynamic object, then the new
+     symbol overrides the old symbol.  Symbols from regular files
+     always take precedence over symbols from dynamic objects, even if
+     they are defined after the dynamic object in the link.
+
+     As above, we again permit a common symbol in a regular object to
+     override a definition in a shared object if the shared object
+     symbol is a function or is weak.
+
+     As above, we permit a non-weak definition in a shared object to
+     override a weak definition in a regular object.  */
+
+  if (! newdyn
+      && (newdef
+	  || (bfd_is_com_section (sec)
+	      && (h->root.type == bfd_link_hash_defweak
+		  || h->type == STT_FUNC)))
+      && olddyn
+      && olddef
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+      && (bind != STB_WEAK
+	  || h->root.type == bfd_link_hash_defweak))
+    {
+      /* Change the hash table entry to undefined, and let
+	 _bfd_generic_link_add_one_symbol do the right thing with the
+	 new definition.  */
+
+      h->root.type = bfd_link_hash_undefined;
+      h->root.u.undef.abfd = h->root.u.def.section->owner;
+      *size_change_ok = true;
+
+      olddef = false;
+      olddyncommon = false;
+
+      /* We again permit a type change when a common symbol may be
+	 overriding a function.  */
+
+      if (bfd_is_com_section (sec))
+	*type_change_ok = true;
+
+      /* This union may have been set to be non-NULL when this symbol
+	 was seen in a dynamic object.  We must force the union to be
+	 NULL, so that it is correct for a regular symbol.  */
+
+      h->verinfo.vertree = NULL;
+
+      /* In this special case, if H is the target of an indirection,
+	 we want the caller to frob with H rather than with the
+	 indirect symbol.  That will permit the caller to redefine the
+	 target of the indirection, rather than the indirect symbol
+	 itself.  FIXME: This will break the -y option if we store a
+	 symbol with a different name.  */
+      *sym_hash = h;
+    }
+
+  /* Handle the special case of a new common symbol merging with an
+     old symbol that looks like it might be a common symbol defined in
+     a shared object.  Note that we have already handled the case in
+     which a new common symbol should simply override the definition
+     in the shared library.  */
+
+  if (! newdyn
+      && bfd_is_com_section (sec)
+      && olddyncommon)
+    {
+      /* It would be best if we could set the hash table entry to a
+	 common symbol, but we don't know what to use for the section
+	 or the alignment.  */
+      if (! ((*info->callbacks->multiple_common)
+	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
+	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
+	return false;
+
+      /* If the predumed common symbol in the dynamic object is
+	 larger, pretend that the new symbol has its size.  */
+
+      if (h->size > *pvalue)
+	*pvalue = h->size;
+
+      /* FIXME: We no longer know the alignment required by the symbol
+	 in the dynamic object, so we just wind up using the one from
+	 the regular object.  */
+
+      olddef = false;
+      olddyncommon = false;
+
+      h->root.type = bfd_link_hash_undefined;
+      h->root.u.undef.abfd = h->root.u.def.section->owner;
+
+      *size_change_ok = true;
+      *type_change_ok = true;
+
+      h->verinfo.vertree = NULL;
+    }
+
+  /* Handle the special case of a weak definition in a regular object
+     followed by a non-weak definition in a shared object.  In this
+     case, we prefer the definition in the shared object unless it
+     comes from a DT_NEEDED entry of a shared object, in which case,
+     the DT_NEEDED entry may not be required at the run time.  */
+  if (olddef
+      && ! dt_needed
+      && h->root.type == bfd_link_hash_defweak
+      && newdef
+      && newdyn
+      && bind != STB_WEAK)
+    {
+      /* To make this work we have to frob the flags so that the rest
+	 of the code does not think we are using the regular
+	 definition.  */
+      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
+	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
+      else if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
+	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
+      h->elf_link_hash_flags &= ~ (ELF_LINK_HASH_DEF_REGULAR
+				   | ELF_LINK_HASH_DEF_DYNAMIC);
+
+      /* If H is the target of an indirection, we want the caller to
+	 use H rather than the indirect symbol.  Otherwise if we are
+	 defining a new indirect symbol we will wind up attaching it
+	 to the entry we are overriding.  */
+      *sym_hash = h;
+    }
+
+  /* Handle the special case of a non-weak definition in a shared
+     object followed by a weak definition in a regular object.  In
+     this case we prefer to definition in the shared object.  To make
+     this work we have to tell the caller to not treat the new symbol
+     as a definition.  */
+  if (olddef
+      && olddyn
+      && h->root.type != bfd_link_hash_defweak
+      && newdef
+      && ! newdyn
+      && bind == STB_WEAK)
+    *override = true;
+
+  return true;
+}
+
+/* This function is called to create an indirect symbol from the
+   default for the symbol with the default version if needed. The
+   symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We
+   set DYNSYM if the new indirect symbol is dynamic. DT_NEEDED
+   indicates if it comes from a DT_NEEDED entry of a shared object.  */
+
+static boolean
+elf_add_default_symbol (abfd, info, h, name, sym, psec, value,
+			dynsym, override, dt_needed)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *h;
+     const char *name;
+     Elf_Internal_Sym *sym;
+     asection **psec;
+     bfd_vma *value;
+     boolean *dynsym;
+     boolean override;
+     boolean dt_needed;
+{
+  boolean type_change_ok;
+  boolean size_change_ok;
+  char *shortname;
+  struct elf_link_hash_entry *hi;
+  struct bfd_link_hash_entry *bh;
+  struct elf_backend_data *bed;
+  boolean collect;
+  boolean dynamic;
+  char *p;
+  size_t len, shortlen;
+  asection *sec;
+
+  /* If this symbol has a version, and it is the default version, we
+     create an indirect symbol from the default name to the fully
+     decorated name.  This will cause external references which do not
+     specify a version to be bound to this version of the symbol.  */
+  p = strchr (name, ELF_VER_CHR);
+  if (p == NULL || p[1] != ELF_VER_CHR)
+    return true;
+
+  if (override)
+    {
+      /* We are overridden by an old defition. We need to check if we
+	 need to create the indirect symbol from the default name.  */
+      hi = elf_link_hash_lookup (elf_hash_table (info), name, true,
+				 false, false);
+      BFD_ASSERT (hi != NULL);
+      if (hi == h)
+	return true;
+      while (hi->root.type == bfd_link_hash_indirect
+	     || hi->root.type == bfd_link_hash_warning)
+	{
+	  hi = (struct elf_link_hash_entry *) hi->root.u.i.link;
+	  if (hi == h)
+	    return true;
+	}
+    }
+
+  bed = get_elf_backend_data (abfd);
+  collect = bed->collect;
+  dynamic = (abfd->flags & DYNAMIC) != 0;
+
+  shortlen = p - name;
+  shortname = bfd_hash_allocate (&info->hash->table, shortlen + 1);
+  if (shortname == NULL)
+    return false;
+  memcpy (shortname, name, shortlen);
+  shortname[shortlen] = '\0';
+
+  /* We are going to create a new symbol.  Merge it with any existing
+     symbol with this name.  For the purposes of the merge, act as
+     though we were defining the symbol we just defined, although we
+     actually going to define an indirect symbol.  */
+  type_change_ok = false;
+  size_change_ok = false;
+  sec = *psec;
+  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
+			  &hi, &override, &type_change_ok,
+			  &size_change_ok, dt_needed))
+    return false;
+
+  if (! override)
+    {
+      bh = &hi->root;
+      if (! (_bfd_generic_link_add_one_symbol
+	     (info, abfd, shortname, BSF_INDIRECT, bfd_ind_section_ptr,
+	      (bfd_vma) 0, name, false, collect, &bh)))
+	return false;
+      hi = (struct elf_link_hash_entry *) bh;
+    }
+  else
+    {
+      /* In this case the symbol named SHORTNAME is overriding the
+	 indirect symbol we want to add.  We were planning on making
+	 SHORTNAME an indirect symbol referring to NAME.  SHORTNAME
+	 is the name without a version.  NAME is the fully versioned
+	 name, and it is the default version.
+
+	 Overriding means that we already saw a definition for the
+	 symbol SHORTNAME in a regular object, and it is overriding
+	 the symbol defined in the dynamic object.
+
+	 When this happens, we actually want to change NAME, the
+	 symbol we just added, to refer to SHORTNAME.  This will cause
+	 references to NAME in the shared object to become references
+	 to SHORTNAME in the regular object.  This is what we expect
+	 when we override a function in a shared object: that the
+	 references in the shared object will be mapped to the
+	 definition in the regular object.  */
+
+      while (hi->root.type == bfd_link_hash_indirect
+	     || hi->root.type == bfd_link_hash_warning)
+	hi = (struct elf_link_hash_entry *) hi->root.u.i.link;
+
+      h->root.type = bfd_link_hash_indirect;
+      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
+      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
+	{
+	  h->elf_link_hash_flags &=~ ELF_LINK_HASH_DEF_DYNAMIC;
+	  hi->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
+	  if (hi->elf_link_hash_flags
+	      & (ELF_LINK_HASH_REF_REGULAR
+		 | ELF_LINK_HASH_DEF_REGULAR))
+	    {
+	      if (! _bfd_elf_link_record_dynamic_symbol (info, hi))
+		return false;
+	    }
+	}
+
+      /* Now set HI to H, so that the following code will set the
+	 other fields correctly.  */
+      hi = h;
+    }
+
+  /* If there is a duplicate definition somewhere, then HI may not
+     point to an indirect symbol.  We will have reported an error to
+     the user in that case.  */
+
+  if (hi->root.type == bfd_link_hash_indirect)
+    {
+      struct elf_link_hash_entry *ht;
+
+      /* If the symbol became indirect, then we assume that we have
+	 not seen a definition before.  */
+      BFD_ASSERT ((hi->elf_link_hash_flags
+		   & (ELF_LINK_HASH_DEF_DYNAMIC
+		      | ELF_LINK_HASH_DEF_REGULAR)) == 0);
+
+      ht = (struct elf_link_hash_entry *) hi->root.u.i.link;
+      (*bed->elf_backend_copy_indirect_symbol) (bed, ht, hi);
+
+      /* See if the new flags lead us to realize that the symbol must
+	 be dynamic.  */
+      if (! *dynsym)
+	{
+	  if (! dynamic)
+	    {
+	      if (info->shared
+		  || ((hi->elf_link_hash_flags
+		       & ELF_LINK_HASH_REF_DYNAMIC) != 0))
+		*dynsym = true;
+	    }
+	  else
+	    {
+	      if ((hi->elf_link_hash_flags
+		   & ELF_LINK_HASH_REF_REGULAR) != 0)
+		*dynsym = true;
+	    }
+	}
+    }
+
+  /* We also need to define an indirection from the nondefault version
+     of the symbol.  */
+
+  len = strlen (name);
+  shortname = bfd_hash_allocate (&info->hash->table, len);
+  if (shortname == NULL)
+    return false;
+  memcpy (shortname, name, shortlen);
+  memcpy (shortname + shortlen, p + 1, len - shortlen);
+
+  /* Once again, merge with any existing symbol.  */
+  type_change_ok = false;
+  size_change_ok = false;
+  sec = *psec;
+  if (! elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
+			  &hi, &override, &type_change_ok,
+			  &size_change_ok, dt_needed))
+    return false;
+
+  if (override)
+    {
+      /* Here SHORTNAME is a versioned name, so we don't expect to see
+	 the type of override we do in the case above unless it is
+	 overridden by a versioned definiton.  */
+      if (hi->root.type != bfd_link_hash_defined
+	  && hi->root.type != bfd_link_hash_defweak)
+	(*_bfd_error_handler)
+	  (_("%s: warning: unexpected redefinition of indirect versioned symbol `%s'"),
+	   bfd_archive_filename (abfd), shortname);
+    }
+  else
+    {
+      bh = &hi->root;
+      if (! (_bfd_generic_link_add_one_symbol
+	     (info, abfd, shortname, BSF_INDIRECT,
+	      bfd_ind_section_ptr, (bfd_vma) 0, name, false, collect, &bh)))
+	return false;
+      hi = (struct elf_link_hash_entry *) bh;
+
+      /* If there is a duplicate definition somewhere, then HI may not
+	 point to an indirect symbol.  We will have reported an error
+	 to the user in that case.  */
+
+      if (hi->root.type == bfd_link_hash_indirect)
+	{
+	  /* If the symbol became indirect, then we assume that we have
+	     not seen a definition before.  */
+	  BFD_ASSERT ((hi->elf_link_hash_flags
+		       & (ELF_LINK_HASH_DEF_DYNAMIC
+			  | ELF_LINK_HASH_DEF_REGULAR)) == 0);
+
+	  (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
+
+	  /* See if the new flags lead us to realize that the symbol
+	     must be dynamic.  */
+	  if (! *dynsym)
+	    {
+	      if (! dynamic)
+		{
+		  if (info->shared
+		      || ((hi->elf_link_hash_flags
+			   & ELF_LINK_HASH_REF_DYNAMIC) != 0))
+		    *dynsym = true;
+		}
+	      else
+		{
+		  if ((hi->elf_link_hash_flags
+		       & ELF_LINK_HASH_REF_REGULAR) != 0)
+		    *dynsym = true;
+		}
+	    }
+	}
+    }
+
+  return true;
+}
+
+/* Add symbols from an ELF object file to the linker hash table.  */
+
+static boolean
+elf_link_add_object_symbols (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  boolean (*add_symbol_hook) PARAMS ((bfd *, struct bfd_link_info *,
+				      const Elf_Internal_Sym *,
+				      const char **, flagword *,
+				      asection **, bfd_vma *));
+  boolean (*check_relocs) PARAMS ((bfd *, struct bfd_link_info *,
+				   asection *, const Elf_Internal_Rela *));
+  boolean collect;
+  Elf_Internal_Shdr *hdr;
+  bfd_size_type symcount;
+  bfd_size_type extsymcount;
+  bfd_size_type extsymoff;
+  struct elf_link_hash_entry **sym_hash;
+  boolean dynamic;
+  Elf_External_Versym *extversym = NULL;
+  Elf_External_Versym *ever;
+  struct elf_link_hash_entry *weaks;
+  Elf_Internal_Sym *isymbuf = NULL;
+  Elf_Internal_Sym *isym;
+  Elf_Internal_Sym *isymend;
+  struct elf_backend_data *bed;
+  boolean dt_needed;
+  struct elf_link_hash_table * hash_table;
+  bfd_size_type amt;
+
+  hash_table = elf_hash_table (info);
+
+  bed = get_elf_backend_data (abfd);
+  add_symbol_hook = bed->elf_add_symbol_hook;
+  collect = bed->collect;
+
+  if ((abfd->flags & DYNAMIC) == 0)
+    dynamic = false;
+  else
+    {
+      dynamic = true;
+
+      /* You can't use -r against a dynamic object.  Also, there's no
+	 hope of using a dynamic object which does not exactly match
+	 the format of the output file.  */
+      if (info->relocateable || info->hash->creator != abfd->xvec)
+	{
+	  bfd_set_error (bfd_error_invalid_operation);
+	  goto error_return;
+	}
+    }
+
+  /* As a GNU extension, any input sections which are named
+     .gnu.warning.SYMBOL are treated as warning symbols for the given
+     symbol.  This differs from .gnu.warning sections, which generate
+     warnings when they are included in an output file.  */
+  if (! info->shared)
+    {
+      asection *s;
+
+      for (s = abfd->sections; s != NULL; s = s->next)
+	{
+	  const char *name;
+
+	  name = bfd_get_section_name (abfd, s);
+	  if (strncmp (name, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0)
+	    {
+	      char *msg;
+	      bfd_size_type sz;
+
+	      name += sizeof ".gnu.warning." - 1;
+
+	      /* If this is a shared object, then look up the symbol
+		 in the hash table.  If it is there, and it is already
+		 been defined, then we will not be using the entry
+		 from this shared object, so we don't need to warn.
+		 FIXME: If we see the definition in a regular object
+		 later on, we will warn, but we shouldn't.  The only
+		 fix is to keep track of what warnings we are supposed
+		 to emit, and then handle them all at the end of the
+		 link.  */
+	      if (dynamic && abfd->xvec == info->hash->creator)
+		{
+		  struct elf_link_hash_entry *h;
+
+		  h = elf_link_hash_lookup (hash_table, name,
+					    false, false, true);
+
+		  /* FIXME: What about bfd_link_hash_common?  */
+		  if (h != NULL
+		      && (h->root.type == bfd_link_hash_defined
+			  || h->root.type == bfd_link_hash_defweak))
+		    {
+		      /* We don't want to issue this warning.  Clobber
+			 the section size so that the warning does not
+			 get copied into the output file.  */
+		      s->_raw_size = 0;
+		      continue;
+		    }
+		}
+
+	      sz = bfd_section_size (abfd, s);
+	      msg = (char *) bfd_alloc (abfd, sz + 1);
+	      if (msg == NULL)
+		goto error_return;
+
+	      if (! bfd_get_section_contents (abfd, s, msg, (file_ptr) 0, sz))
+		goto error_return;
+
+	      msg[sz] = '\0';
+
+	      if (! (_bfd_generic_link_add_one_symbol
+		     (info, abfd, name, BSF_WARNING, s, (bfd_vma) 0, msg,
+		      false, collect, (struct bfd_link_hash_entry **) NULL)))
+		goto error_return;
+
+	      if (! info->relocateable)
+		{
+		  /* Clobber the section size so that the warning does
+		     not get copied into the output file.  */
+		  s->_raw_size = 0;
+		}
+	    }
+	}
+    }
+
+  dt_needed = false;
+  if (! dynamic)
+    {
+      /* If we are creating a shared library, create all the dynamic
+	 sections immediately.  We need to attach them to something,
+	 so we attach them to this BFD, provided it is the right
+	 format.  FIXME: If there are no input BFD's of the same
+	 format as the output, we can't make a shared library.  */
+      if (info->shared
+	  && is_elf_hash_table (info)
+	  && ! hash_table->dynamic_sections_created
+	  && abfd->xvec == info->hash->creator)
+	{
+	  if (! elf_link_create_dynamic_sections (abfd, info))
+	    goto error_return;
+	}
+    }
+  else if (! is_elf_hash_table (info))
+    goto error_return;
+  else
+    {
+      asection *s;
+      boolean add_needed;
+      const char *name;
+      bfd_size_type oldsize;
+      bfd_size_type strindex;
+      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;
+
+      /* ld --just-symbols and dynamic objects don't mix very well.
+	 Test for --just-symbols by looking at info set up by
+	 _bfd_elf_link_just_syms.  */
+      if ((s = abfd->sections) != NULL
+	  && elf_section_data (s)->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
+	goto error_return;
+
+      /* Find the name to use in a DT_NEEDED entry that refers to this
+	 object.  If the object has a DT_SONAME entry, we use it.
+	 Otherwise, if the generic linker stuck something in
+	 elf_dt_name, we use that.  Otherwise, we just use the file
+	 name.  If the generic linker put a null string into
+	 elf_dt_name, we don't make a DT_NEEDED entry at all, even if
+	 there is a DT_SONAME entry.  */
+      add_needed = true;
+      name = bfd_get_filename (abfd);
+      if (elf_dt_name (abfd) != NULL)
+	{
+	  name = elf_dt_name (abfd);
+	  if (*name == '\0')
+	    {
+	      if (elf_dt_soname (abfd) != NULL)
+		dt_needed = true;
+
+	      add_needed = false;
+	    }
+	}
+      s = bfd_get_section_by_name (abfd, ".dynamic");
+      if (s != NULL)
+	{
+	  Elf_External_Dyn *dynbuf = NULL;
+	  Elf_External_Dyn *extdyn;
+	  Elf_External_Dyn *extdynend;
+	  int elfsec;
+	  unsigned long shlink;
+
+	  dynbuf = (Elf_External_Dyn *) bfd_malloc (s->_raw_size);
+	  if (dynbuf == NULL)
+	    goto error_return;
+
+	  if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf,
+					  (file_ptr) 0, s->_raw_size))
+	    goto error_free_dyn;
+
+	  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
+	  if (elfsec == -1)
+	    goto error_free_dyn;
+	  shlink = elf_elfsections (abfd)[elfsec]->sh_link;
+
+	  extdyn = dynbuf;
+	  extdynend = extdyn + s->_raw_size / sizeof (Elf_External_Dyn);
+	  for (; extdyn < extdynend; extdyn++)
+	    {
+	      Elf_Internal_Dyn dyn;
+
+	      elf_swap_dyn_in (abfd, extdyn, &dyn);
+	      if (dyn.d_tag == DT_SONAME)
+		{
+		  unsigned int tagv = dyn.d_un.d_val;
+		  name = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
+		  if (name == NULL)
+		    goto error_free_dyn;
+		}
+	      if (dyn.d_tag == DT_NEEDED)
+		{
+		  struct bfd_link_needed_list *n, **pn;
+		  char *fnm, *anm;
+		  unsigned int tagv = dyn.d_un.d_val;
+
+		  amt = sizeof (struct bfd_link_needed_list);
+		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
+		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
+		  if (n == NULL || fnm == NULL)
+		    goto error_free_dyn;
+		  amt = strlen (fnm) + 1;
+		  anm = bfd_alloc (abfd, amt);
+		  if (anm == NULL)
+		    goto error_free_dyn;
+		  memcpy (anm, fnm, (size_t) amt);
+		  n->name = anm;
+		  n->by = abfd;
+		  n->next = NULL;
+		  for (pn = & hash_table->needed;
+		       *pn != NULL;
+		       pn = &(*pn)->next)
+		    ;
+		  *pn = n;
+		}
+	      if (dyn.d_tag == DT_RUNPATH)
+		{
+		  struct bfd_link_needed_list *n, **pn;
+		  char *fnm, *anm;
+		  unsigned int tagv = dyn.d_un.d_val;
+
+		  amt = sizeof (struct bfd_link_needed_list);
+		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
+		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
+		  if (n == NULL || fnm == NULL)
+		    goto error_free_dyn;
+		  amt = strlen (fnm) + 1;
+		  anm = bfd_alloc (abfd, amt);
+		  if (anm == NULL)
+		    goto error_free_dyn;
+		  memcpy (anm, fnm, (size_t) amt);
+		  n->name = anm;
+		  n->by = abfd;
+		  n->next = NULL;
+		  for (pn = & runpath;
+		       *pn != NULL;
+		       pn = &(*pn)->next)
+		    ;
+		  *pn = n;
+		}
+	      /* Ignore DT_RPATH if we have seen DT_RUNPATH.  */
+	      if (!runpath && dyn.d_tag == DT_RPATH)
+		{
+		  struct bfd_link_needed_list *n, **pn;
+		  char *fnm, *anm;
+		  unsigned int tagv = dyn.d_un.d_val;
+
+		  amt = sizeof (struct bfd_link_needed_list);
+		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
+		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
+		  if (n == NULL || fnm == NULL)
+		    goto error_free_dyn;
+		  amt = strlen (fnm) + 1;
+		  anm = bfd_alloc (abfd, amt);
+		  if (anm == NULL)
+		    {
+		    error_free_dyn:
+		      free (dynbuf);
+		      goto error_return;
+		    }
+		  memcpy (anm, fnm, (size_t) amt);
+		  n->name = anm;
+		  n->by = abfd;
+		  n->next = NULL;
+		  for (pn = & rpath;
+		       *pn != NULL;
+		       pn = &(*pn)->next)
+		    ;
+		  *pn = n;
+		}
+	    }
+
+	  free (dynbuf);
+	}
+
+      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
+	 frees all more recently bfd_alloc'd blocks as well.  */
+      if (runpath)
+	rpath = runpath;
+
+      if (rpath)
+	{
+	  struct bfd_link_needed_list **pn;
+	  for (pn = & hash_table->runpath;
+	       *pn != NULL;
+	       pn = &(*pn)->next)
+	    ;
+	  *pn = rpath;
+	}
+
+      /* We do not want to include any of the sections in a dynamic
+	 object in the output file.  We hack by simply clobbering the
+	 list of sections in the BFD.  This could be handled more
+	 cleanly by, say, a new section flag; the existing
+	 SEC_NEVER_LOAD flag is not the one we want, because that one
+	 still implies that the section takes up space in the output
+	 file.  */
+      bfd_section_list_clear (abfd);
+
+      /* If this is the first dynamic object found in the link, create
+	 the special sections required for dynamic linking.  */
+      if (! hash_table->dynamic_sections_created)
+	if (! elf_link_create_dynamic_sections (abfd, info))
+	  goto error_return;
+
+      if (add_needed)
+	{
+	  /* Add a DT_NEEDED entry for this dynamic object.  */
+	  oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
+	  strindex = _bfd_elf_strtab_add (hash_table->dynstr, name, false);
+	  if (strindex == (bfd_size_type) -1)
+	    goto error_return;
+
+	  if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
+	    {
+	      asection *sdyn;
+	      Elf_External_Dyn *dyncon, *dynconend;
+
+	      /* The hash table size did not change, which means that
+		 the dynamic object name was already entered.  If we
+		 have already included this dynamic object in the
+		 link, just ignore it.  There is no reason to include
+		 a particular dynamic object more than once.  */
+	      sdyn = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
+	      BFD_ASSERT (sdyn != NULL);
+
+	      dyncon = (Elf_External_Dyn *) sdyn->contents;
+	      dynconend = (Elf_External_Dyn *) (sdyn->contents +
+						sdyn->_raw_size);
+	      for (; dyncon < dynconend; dyncon++)
+		{
+		  Elf_Internal_Dyn dyn;
+
+		  elf_swap_dyn_in (hash_table->dynobj, dyncon, & dyn);
+		  if (dyn.d_tag == DT_NEEDED
+		      && dyn.d_un.d_val == strindex)
+		    {
+		      _bfd_elf_strtab_delref (hash_table->dynstr, strindex);
+		      return true;
+		    }
+		}
+	    }
+
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NEEDED, strindex))
+	    goto error_return;
+	}
+
+      /* Save the SONAME, if there is one, because sometimes the
+	 linker emulation code will need to know it.  */
+      if (*name == '\0')
+	name = basename (bfd_get_filename (abfd));
+      elf_dt_name (abfd) = name;
+    }
+
+  /* If this is a dynamic object, we always link against the .dynsym
+     symbol table, not the .symtab symbol table.  The dynamic linker
+     will only see the .dynsym symbol table, so there is no reason to
+     look at .symtab for a dynamic object.  */
+
+  if (! dynamic || elf_dynsymtab (abfd) == 0)
+    hdr = &elf_tdata (abfd)->symtab_hdr;
+  else
+    hdr = &elf_tdata (abfd)->dynsymtab_hdr;
+
+  symcount = hdr->sh_size / sizeof (Elf_External_Sym);
+
+  /* The sh_info field of the symtab header tells us where the
+     external symbols start.  We don't care about the local symbols at
+     this point.  */
+  if (elf_bad_symtab (abfd))
+    {
+      extsymcount = symcount;
+      extsymoff = 0;
+    }
+  else
+    {
+      extsymcount = symcount - hdr->sh_info;
+      extsymoff = hdr->sh_info;
+    }
+
+  sym_hash = NULL;
+  if (extsymcount != 0)
+    {
+      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
+				      NULL, NULL, NULL);
+      if (isymbuf == NULL)
+	goto error_return;
+
+      /* We store a pointer to the hash table entry for each external
+	 symbol.  */
+      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
+      sym_hash = (struct elf_link_hash_entry **) bfd_alloc (abfd, amt);
+      if (sym_hash == NULL)
+	goto error_free_sym;
+      elf_sym_hashes (abfd) = sym_hash;
+    }
+
+  if (dynamic)
+    {
+      /* Read in any version definitions.  */
+      if (! _bfd_elf_slurp_version_tables (abfd))
+	goto error_free_sym;
+
+      /* Read in the symbol versions, but don't bother to convert them
+	 to internal format.  */
+      if (elf_dynversym (abfd) != 0)
+	{
+	  Elf_Internal_Shdr *versymhdr;
+
+	  versymhdr = &elf_tdata (abfd)->dynversym_hdr;
+	  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
+	  if (extversym == NULL)
+	    goto error_free_sym;
+	  amt = versymhdr->sh_size;
+	  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0
+	      || bfd_bread ((PTR) extversym, amt, abfd) != amt)
+	    goto error_free_vers;
+	}
+    }
+
+  weaks = NULL;
+
+  ever = extversym != NULL ? extversym + extsymoff : NULL;
+  for (isym = isymbuf, isymend = isymbuf + extsymcount;
+       isym < isymend;
+       isym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL))
+    {
+      int bind;
+      bfd_vma value;
+      asection *sec;
+      flagword flags;
+      const char *name;
+      struct elf_link_hash_entry *h;
+      boolean definition;
+      boolean size_change_ok, type_change_ok;
+      boolean new_weakdef;
+      unsigned int old_alignment;
+      boolean override;
+
+      override = false;
+
+      flags = BSF_NO_FLAGS;
+      sec = NULL;
+      value = isym->st_value;
+      *sym_hash = NULL;
+
+      bind = ELF_ST_BIND (isym->st_info);
+      if (bind == STB_LOCAL)
+	{
+	  /* This should be impossible, since ELF requires that all
+	     global symbols follow all local symbols, and that sh_info
+	     point to the first global symbol.  Unfortunatealy, Irix 5
+	     screws this up.  */
+	  continue;
+	}
+      else if (bind == STB_GLOBAL)
+	{
+	  if (isym->st_shndx != SHN_UNDEF
+	      && isym->st_shndx != SHN_COMMON)
+	    flags = BSF_GLOBAL;
+	}
+      else if (bind == STB_WEAK)
+	flags = BSF_WEAK;
+      else
+	{
+	  /* Leave it up to the processor backend.  */
+	}
+
+      if (isym->st_shndx == SHN_UNDEF)
+	sec = bfd_und_section_ptr;
+      else if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
+	{
+	  sec = section_from_elf_index (abfd, isym->st_shndx);
+	  if (sec == NULL)
+	    sec = bfd_abs_section_ptr;
+	  else if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
+	    value -= sec->vma;
+	}
+      else if (isym->st_shndx == SHN_ABS)
+	sec = bfd_abs_section_ptr;
+      else if (isym->st_shndx == SHN_COMMON)
+	{
+	  sec = bfd_com_section_ptr;
+	  /* What ELF calls the size we call the value.  What ELF
+	     calls the value we call the alignment.  */
+	  value = isym->st_size;
+	}
+      else
+	{
+	  /* Leave it up to the processor backend.  */
+	}
+
+      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
+					      isym->st_name);
+      if (name == (const char *) NULL)
+	goto error_free_vers;
+
+      if (isym->st_shndx == SHN_COMMON
+	  && ELF_ST_TYPE (isym->st_info) == STT_TLS)
+	{
+	  asection *tcomm = bfd_get_section_by_name (abfd, ".tcommon");
+
+	  if (tcomm == NULL)
+	    {
+	      tcomm = bfd_make_section (abfd, ".tcommon");
+	      if (tcomm == NULL
+		  || !bfd_set_section_flags (abfd, tcomm, (SEC_ALLOC
+							   | SEC_IS_COMMON
+							   | SEC_LINKER_CREATED
+							   | SEC_THREAD_LOCAL)))
+		goto error_free_vers;
+	    }
+	  sec = tcomm;
+	}
+      else if (add_symbol_hook)
+	{
+	  if (! (*add_symbol_hook) (abfd, info, isym, &name, &flags, &sec,
+				    &value))
+	    goto error_free_vers;
+
+	  /* The hook function sets the name to NULL if this symbol
+	     should be skipped for some reason.  */
+	  if (name == (const char *) NULL)
+	    continue;
+	}
+
+      /* Sanity check that all possibilities were handled.  */
+      if (sec == (asection *) NULL)
+	{
+	  bfd_set_error (bfd_error_bad_value);
+	  goto error_free_vers;
+	}
+
+      if (bfd_is_und_section (sec)
+	  || bfd_is_com_section (sec))
+	definition = false;
+      else
+	definition = true;
+
+      size_change_ok = false;
+      type_change_ok = get_elf_backend_data (abfd)->type_change_ok;
+      old_alignment = 0;
+      if (info->hash->creator->flavour == bfd_target_elf_flavour)
+	{
+	  Elf_Internal_Versym iver;
+	  unsigned int vernum = 0;
+
+	  if (ever != NULL)
+	    {
+	      _bfd_elf_swap_versym_in (abfd, ever, &iver);
+	      vernum = iver.vs_vers & VERSYM_VERSION;
+
+	      /* If this is a hidden symbol, or if it is not version
+		 1, we append the version name to the symbol name.
+		 However, we do not modify a non-hidden absolute
+		 symbol, because it might be the version symbol
+		 itself.  FIXME: What if it isn't?  */
+	      if ((iver.vs_vers & VERSYM_HIDDEN) != 0
+		  || (vernum > 1 && ! bfd_is_abs_section (sec)))
+		{
+		  const char *verstr;
+		  size_t namelen, verlen, newlen;
+		  char *newname, *p;
+
+		  if (isym->st_shndx != SHN_UNDEF)
+		    {
+		      if (vernum > elf_tdata (abfd)->dynverdef_hdr.sh_info)
+			{
+			  (*_bfd_error_handler)
+			    (_("%s: %s: invalid version %u (max %d)"),
+			     bfd_archive_filename (abfd), name, vernum,
+			     elf_tdata (abfd)->dynverdef_hdr.sh_info);
+			  bfd_set_error (bfd_error_bad_value);
+			  goto error_free_vers;
+			}
+		      else if (vernum > 1)
+			verstr =
+			  elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
+		      else
+			verstr = "";
+		    }
+		  else
+		    {
+		      /* We cannot simply test for the number of
+			 entries in the VERNEED section since the
+			 numbers for the needed versions do not start
+			 at 0.  */
+		      Elf_Internal_Verneed *t;
+
+		      verstr = NULL;
+		      for (t = elf_tdata (abfd)->verref;
+			   t != NULL;
+			   t = t->vn_nextref)
+			{
+			  Elf_Internal_Vernaux *a;
+
+			  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+			    {
+			      if (a->vna_other == vernum)
+				{
+				  verstr = a->vna_nodename;
+				  break;
+				}
+			    }
+			  if (a != NULL)
+			    break;
+			}
+		      if (verstr == NULL)
+			{
+			  (*_bfd_error_handler)
+			    (_("%s: %s: invalid needed version %d"),
+			     bfd_archive_filename (abfd), name, vernum);
+			  bfd_set_error (bfd_error_bad_value);
+			  goto error_free_vers;
+			}
+		    }
+
+		  namelen = strlen (name);
+		  verlen = strlen (verstr);
+		  newlen = namelen + verlen + 2;
+		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
+		      && isym->st_shndx != SHN_UNDEF)
+		    ++newlen;
+
+		  newname = (char *) bfd_alloc (abfd, (bfd_size_type) newlen);
+		  if (newname == NULL)
+		    goto error_free_vers;
+		  memcpy (newname, name, namelen);
+		  p = newname + namelen;
+		  *p++ = ELF_VER_CHR;
+		  /* If this is a defined non-hidden version symbol,
+		     we add another @ to the name.  This indicates the
+		     default version of the symbol.  */
+		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
+		      && isym->st_shndx != SHN_UNDEF)
+		    *p++ = ELF_VER_CHR;
+		  memcpy (p, verstr, verlen + 1);
+
+		  name = newname;
+		}
+	    }
+
+	  if (! elf_merge_symbol (abfd, info, name, isym, &sec, &value,
+				  sym_hash, &override, &type_change_ok,
+				  &size_change_ok, dt_needed))
+	    goto error_free_vers;
+
+	  if (override)
+	    definition = false;
+
+	  h = *sym_hash;
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+	  /* Remember the old alignment if this is a common symbol, so
+	     that we don't reduce the alignment later on.  We can't
+	     check later, because _bfd_generic_link_add_one_symbol
+	     will set a default for the alignment which we want to
+	     override.  */
+	  if (h->root.type == bfd_link_hash_common)
+	    old_alignment = h->root.u.c.p->alignment_power;
+
+	  if (elf_tdata (abfd)->verdef != NULL
+	      && ! override
+	      && vernum > 1
+	      && definition)
+	    h->verinfo.verdef = &elf_tdata (abfd)->verdef[vernum - 1];
+	}
+
+      if (! (_bfd_generic_link_add_one_symbol
+	     (info, abfd, name, flags, sec, value, (const char *) NULL,
+	      false, collect, (struct bfd_link_hash_entry **) sym_hash)))
+	goto error_free_vers;
+
+      h = *sym_hash;
+      while (h->root.type == bfd_link_hash_indirect
+	     || h->root.type == bfd_link_hash_warning)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+      *sym_hash = h;
+
+      new_weakdef = false;
+      if (dynamic
+	  && definition
+	  && (flags & BSF_WEAK) != 0
+	  && ELF_ST_TYPE (isym->st_info) != STT_FUNC
+	  && info->hash->creator->flavour == bfd_target_elf_flavour
+	  && h->weakdef == NULL)
+	{
+	  /* Keep a list of all weak defined non function symbols from
+	     a dynamic object, using the weakdef field.  Later in this
+	     function we will set the weakdef field to the correct
+	     value.  We only put non-function symbols from dynamic
+	     objects on this list, because that happens to be the only
+	     time we need to know the normal symbol corresponding to a
+	     weak symbol, and the information is time consuming to
+	     figure out.  If the weakdef field is not already NULL,
+	     then this symbol was already defined by some previous
+	     dynamic object, and we will be using that previous
+	     definition anyhow.  */
+
+	  h->weakdef = weaks;
+	  weaks = h;
+	  new_weakdef = true;
+	}
+
+      /* Set the alignment of a common symbol.  */
+      if (isym->st_shndx == SHN_COMMON
+	  && h->root.type == bfd_link_hash_common)
+	{
+	  unsigned int align;
+
+	  align = bfd_log2 (isym->st_value);
+	  if (align > old_alignment
+	      /* Permit an alignment power of zero if an alignment of one
+		 is specified and no other alignments have been specified.  */
+	      || (isym->st_value == 1 && old_alignment == 0))
+	    h->root.u.c.p->alignment_power = align;
+	}
+
+      if (info->hash->creator->flavour == bfd_target_elf_flavour)
+	{
+	  int old_flags;
+	  boolean dynsym;
+	  int new_flag;
+
+	  /* Remember the symbol size and type.  */
+	  if (isym->st_size != 0
+	      && (definition || h->size == 0))
+	    {
+	      if (h->size != 0 && h->size != isym->st_size && ! size_change_ok)
+		(*_bfd_error_handler)
+		  (_("Warning: size of symbol `%s' changed from %lu to %lu in %s"),
+		   name, (unsigned long) h->size,
+		   (unsigned long) isym->st_size, bfd_archive_filename (abfd));
+
+	      h->size = isym->st_size;
+	    }
+
+	  /* If this is a common symbol, then we always want H->SIZE
+	     to be the size of the common symbol.  The code just above
+	     won't fix the size if a common symbol becomes larger.  We
+	     don't warn about a size change here, because that is
+	     covered by --warn-common.  */
+	  if (h->root.type == bfd_link_hash_common)
+	    h->size = h->root.u.c.size;
+
+	  if (ELF_ST_TYPE (isym->st_info) != STT_NOTYPE
+	      && (definition || h->type == STT_NOTYPE))
+	    {
+	      if (h->type != STT_NOTYPE
+		  && h->type != ELF_ST_TYPE (isym->st_info)
+		  && ! type_change_ok)
+		(*_bfd_error_handler)
+		  (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
+		   name, h->type, ELF_ST_TYPE (isym->st_info),
+		   bfd_archive_filename (abfd));
+
+	      h->type = ELF_ST_TYPE (isym->st_info);
+	    }
+
+	  /* If st_other has a processor-specific meaning, specific code
+	     might be needed here.  */
+	  if (isym->st_other != 0)
+	    {
+	      unsigned char hvis, symvis, other;
+
+	      /* Take the balance of OTHER from the definition.  */
+	      other = (definition ? isym->st_other : h->other);
+	      other &= ~ ELF_ST_VISIBILITY (-1);
+
+	      /* Combine visibilities, using the most constraining one.  */
+	      hvis   = ELF_ST_VISIBILITY (h->other);
+	      symvis = ELF_ST_VISIBILITY (isym->st_other);
+
+	      h->other = other | (hvis > symvis ? hvis : symvis);
+	    }
+
+	  /* Set a flag in the hash table entry indicating the type of
+	     reference or definition we just found.  Keep a count of
+	     the number of dynamic symbols we find.  A dynamic symbol
+	     is one which is referenced or defined by both a regular
+	     object and a shared object.  */
+	  old_flags = h->elf_link_hash_flags;
+	  dynsym = false;
+	  if (! dynamic)
+	    {
+	      if (! definition)
+		{
+		  new_flag = ELF_LINK_HASH_REF_REGULAR;
+		  if (bind != STB_WEAK)
+		    new_flag |= ELF_LINK_HASH_REF_REGULAR_NONWEAK;
+		}
+	      else
+		new_flag = ELF_LINK_HASH_DEF_REGULAR;
+	      if (info->shared
+		  || (old_flags & (ELF_LINK_HASH_DEF_DYNAMIC
+				   | ELF_LINK_HASH_REF_DYNAMIC)) != 0)
+		dynsym = true;
+	    }
+	  else
+	    {
+	      if (! definition)
+		new_flag = ELF_LINK_HASH_REF_DYNAMIC;
+	      else
+		new_flag = ELF_LINK_HASH_DEF_DYNAMIC;
+	      if ((old_flags & (ELF_LINK_HASH_DEF_REGULAR
+				| ELF_LINK_HASH_REF_REGULAR)) != 0
+		  || (h->weakdef != NULL
+		      && ! new_weakdef
+		      && h->weakdef->dynindx != -1))
+		dynsym = true;
+	    }
+
+	  h->elf_link_hash_flags |= new_flag;
+
+	  /* Check to see if we need to add an indirect symbol for
+	     the default name.  */
+	  if (definition || h->root.type == bfd_link_hash_common)
+	    if (! elf_add_default_symbol (abfd, info, h, name, isym,
+					  &sec, &value, &dynsym,
+					  override, dt_needed))
+	      goto error_free_vers;
+
+	  if (dynsym && h->dynindx == -1)
+	    {
+	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+		goto error_free_vers;
+	      if (h->weakdef != NULL
+		  && ! new_weakdef
+		  && h->weakdef->dynindx == -1)
+		{
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
+		    goto error_free_vers;
+		}
+	    }
+	  else if (dynsym && h->dynindx != -1)
+	    /* If the symbol already has a dynamic index, but
+	       visibility says it should not be visible, turn it into
+	       a local symbol.  */
+	    switch (ELF_ST_VISIBILITY (h->other))
+	      {
+	      case STV_INTERNAL:
+	      case STV_HIDDEN:
+		(*bed->elf_backend_hide_symbol) (info, h, true);
+		break;
+	      }
+
+	  if (dt_needed && definition
+	      && (h->elf_link_hash_flags
+		  & ELF_LINK_HASH_REF_REGULAR) != 0)
+	    {
+	      bfd_size_type oldsize;
+	      bfd_size_type strindex;
+
+	      if (! is_elf_hash_table (info))
+		goto error_free_vers;
+
+	      /* The symbol from a DT_NEEDED object is referenced from
+		 the regular object to create a dynamic executable. We
+		 have to make sure there is a DT_NEEDED entry for it.  */
+
+	      dt_needed = false;
+	      oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
+	      strindex = _bfd_elf_strtab_add (hash_table->dynstr,
+					      elf_dt_soname (abfd), false);
+	      if (strindex == (bfd_size_type) -1)
+		goto error_free_vers;
+
+	      if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
+		{
+		  asection *sdyn;
+		  Elf_External_Dyn *dyncon, *dynconend;
+
+		  sdyn = bfd_get_section_by_name (hash_table->dynobj,
+						  ".dynamic");
+		  BFD_ASSERT (sdyn != NULL);
+
+		  dyncon = (Elf_External_Dyn *) sdyn->contents;
+		  dynconend = (Elf_External_Dyn *) (sdyn->contents +
+						    sdyn->_raw_size);
+		  for (; dyncon < dynconend; dyncon++)
+		    {
+		      Elf_Internal_Dyn dyn;
+
+		      elf_swap_dyn_in (hash_table->dynobj,
+				       dyncon, &dyn);
+		      BFD_ASSERT (dyn.d_tag != DT_NEEDED ||
+				  dyn.d_un.d_val != strindex);
+		    }
+		}
+
+	      if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NEEDED, strindex))
+		goto error_free_vers;
+	    }
+	}
+    }
+
+  if (extversym != NULL)
+    {
+      free (extversym);
+      extversym = NULL;
+    }
+
+  if (isymbuf != NULL)
+    free (isymbuf);
+  isymbuf = NULL;
+
+  /* Now set the weakdefs field correctly for all the weak defined
+     symbols we found.  The only way to do this is to search all the
+     symbols.  Since we only need the information for non functions in
+     dynamic objects, that's the only time we actually put anything on
+     the list WEAKS.  We need this information so that if a regular
+     object refers to a symbol defined weakly in a dynamic object, the
+     real symbol in the dynamic object is also put in the dynamic
+     symbols; we also must arrange for both symbols to point to the
+     same memory location.  We could handle the general case of symbol
+     aliasing, but a general symbol alias can only be generated in
+     assembler code, handling it correctly would be very time
+     consuming, and other ELF linkers don't handle general aliasing
+     either.  */
+  while (weaks != NULL)
+    {
+      struct elf_link_hash_entry *hlook;
+      asection *slook;
+      bfd_vma vlook;
+      struct elf_link_hash_entry **hpp;
+      struct elf_link_hash_entry **hppend;
+
+      hlook = weaks;
+      weaks = hlook->weakdef;
+      hlook->weakdef = NULL;
+
+      BFD_ASSERT (hlook->root.type == bfd_link_hash_defined
+		  || hlook->root.type == bfd_link_hash_defweak
+		  || hlook->root.type == bfd_link_hash_common
+		  || hlook->root.type == bfd_link_hash_indirect);
+      slook = hlook->root.u.def.section;
+      vlook = hlook->root.u.def.value;
+
+      hpp = elf_sym_hashes (abfd);
+      hppend = hpp + extsymcount;
+      for (; hpp < hppend; hpp++)
+	{
+	  struct elf_link_hash_entry *h;
+
+	  h = *hpp;
+	  if (h != NULL && h != hlook
+	      && h->root.type == bfd_link_hash_defined
+	      && h->root.u.def.section == slook
+	      && h->root.u.def.value == vlook)
+	    {
+	      hlook->weakdef = h;
+
+	      /* If the weak definition is in the list of dynamic
+		 symbols, make sure the real definition is put there
+		 as well.  */
+	      if (hlook->dynindx != -1
+		  && h->dynindx == -1)
+		{
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+		    goto error_return;
+		}
+
+	      /* If the real definition is in the list of dynamic
+		 symbols, make sure the weak definition is put there
+		 as well.  If we don't do this, then the dynamic
+		 loader might not merge the entries for the real
+		 definition and the weak definition.  */
+	      if (h->dynindx != -1
+		  && hlook->dynindx == -1)
+		{
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, hlook))
+		    goto error_return;
+		}
+	      break;
+	    }
+	}
+    }
+
+  /* If this object is the same format as the output object, and it is
+     not a shared library, then let the backend look through the
+     relocs.
+
+     This is required to build global offset table entries and to
+     arrange for dynamic relocs.  It is not required for the
+     particular common case of linking non PIC code, even when linking
+     against shared libraries, but unfortunately there is no way of
+     knowing whether an object file has been compiled PIC or not.
+     Looking through the relocs is not particularly time consuming.
+     The problem is that we must either (1) keep the relocs in memory,
+     which causes the linker to require additional runtime memory or
+     (2) read the relocs twice from the input file, which wastes time.
+     This would be a good case for using mmap.
+
+     I have no idea how to handle linking PIC code into a file of a
+     different format.  It probably can't be done.  */
+  check_relocs = get_elf_backend_data (abfd)->check_relocs;
+  if (! dynamic
+      && abfd->xvec == info->hash->creator
+      && check_relocs != NULL)
+    {
+      asection *o;
+
+      for (o = abfd->sections; o != NULL; o = o->next)
+	{
+	  Elf_Internal_Rela *internal_relocs;
+	  boolean ok;
+
+	  if ((o->flags & SEC_RELOC) == 0
+	      || o->reloc_count == 0
+	      || ((info->strip == strip_all || info->strip == strip_debugger)
+		  && (o->flags & SEC_DEBUGGING) != 0)
+	      || bfd_is_abs_section (o->output_section))
+	    continue;
+
+	  internal_relocs = (NAME(_bfd_elf,link_read_relocs)
+			     (abfd, o, (PTR) NULL,
+			      (Elf_Internal_Rela *) NULL,
+			      info->keep_memory));
+	  if (internal_relocs == NULL)
+	    goto error_return;
+
+	  ok = (*check_relocs) (abfd, info, o, internal_relocs);
+
+	  if (elf_section_data (o)->relocs != internal_relocs)
+	    free (internal_relocs);
+
+	  if (! ok)
+	    goto error_return;
+	}
+    }
+
+  /* If this is a non-traditional, non-relocateable link, try to
+     optimize the handling of the .stab/.stabstr sections.  */
+  if (! dynamic
+      && ! info->relocateable
+      && ! info->traditional_format
+      && info->hash->creator->flavour == bfd_target_elf_flavour
+      && is_elf_hash_table (info)
+      && (info->strip != strip_all && info->strip != strip_debugger))
+    {
+      asection *stab, *stabstr;
+
+      stab = bfd_get_section_by_name (abfd, ".stab");
+      if (stab != NULL
+	  && (stab->flags & SEC_MERGE) == 0
+	  && !bfd_is_abs_section (stab->output_section))
+	{
+	  stabstr = bfd_get_section_by_name (abfd, ".stabstr");
+
+	  if (stabstr != NULL)
+	    {
+	      struct bfd_elf_section_data *secdata;
+
+	      secdata = elf_section_data (stab);
+	      if (! _bfd_link_section_stabs (abfd,
+					     & hash_table->stab_info,
+					     stab, stabstr,
+					     &secdata->sec_info))
+		goto error_return;
+	      if (secdata->sec_info)
+		secdata->sec_info_type = ELF_INFO_TYPE_STABS;
+	    }
+	}
+    }
+
+  if (! info->relocateable && ! dynamic
+      && is_elf_hash_table (info))
+    {
+      asection *s;
+
+      for (s = abfd->sections; s != NULL; s = s->next)
+	if ((s->flags & SEC_MERGE) != 0
+	    && !bfd_is_abs_section (s->output_section))
+	  {
+	    struct bfd_elf_section_data *secdata;
+
+	    secdata = elf_section_data (s);
+	    if (! _bfd_merge_section (abfd,
+				      & hash_table->merge_info,
+				      s, &secdata->sec_info))
+	      goto error_return;
+	    else if (secdata->sec_info)
+	      secdata->sec_info_type = ELF_INFO_TYPE_MERGE;
+	  }
+    }
+
+  if (is_elf_hash_table (info))
+    {
+      /* Add this bfd to the loaded list.  */
+      struct elf_link_loaded_list *n;
+
+      n = ((struct elf_link_loaded_list *)
+	   bfd_alloc (abfd, sizeof (struct elf_link_loaded_list)));
+      if (n == NULL)
+	goto error_return;
+      n->abfd = abfd;
+      n->next = hash_table->loaded;
+      hash_table->loaded = n;
+    }
+
+  return true;
+
+ error_free_vers:
+  if (extversym != NULL)
+    free (extversym);
+ error_free_sym:
+  if (isymbuf != NULL)
+    free (isymbuf);
+ error_return:
+  return false;
+}
+
+/* Create some sections which will be filled in with dynamic linking
+   information.  ABFD is an input file which requires dynamic sections
+   to be created.  The dynamic sections take up virtual memory space
+   when the final executable is run, so we need to create them before
+   addresses are assigned to the output sections.  We work out the
+   actual contents and size of these sections later.  */
+
+boolean
+elf_link_create_dynamic_sections (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  flagword flags;
+  register asection *s;
+  struct elf_link_hash_entry *h;
+  struct bfd_link_hash_entry *bh;
+  struct elf_backend_data *bed;
+
+  if (! is_elf_hash_table (info))
+    return false;
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    return true;
+
+  /* Make sure that all dynamic sections use the same input BFD.  */
+  if (elf_hash_table (info)->dynobj == NULL)
+    elf_hash_table (info)->dynobj = abfd;
+  else
+    abfd = elf_hash_table (info)->dynobj;
+
+  /* Note that we set the SEC_IN_MEMORY flag for all of these
+     sections.  */
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
+	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);
+
+  /* A dynamically linked executable has a .interp section, but a
+     shared library does not.  */
+  if (! info->shared)
+    {
+      s = bfd_make_section (abfd, ".interp");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
+	return false;
+    }
+
+  if (! info->traditional_format
+      && info->hash->creator->flavour == bfd_target_elf_flavour)
+    {
+      s = bfd_make_section (abfd, ".eh_frame_hdr");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+	  || ! bfd_set_section_alignment (abfd, s, 2))
+	return false;
+    }
+
+  /* Create sections to hold version informations.  These are removed
+     if they are not needed.  */
+  s = bfd_make_section (abfd, ".gnu.version_d");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return false;
+
+  s = bfd_make_section (abfd, ".gnu.version");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, 1))
+    return false;
+
+  s = bfd_make_section (abfd, ".gnu.version_r");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return false;
+
+  s = bfd_make_section (abfd, ".dynsym");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return false;
+
+  s = bfd_make_section (abfd, ".dynstr");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
+    return false;
+
+  /* Create a strtab to hold the dynamic symbol names.  */
+  if (elf_hash_table (info)->dynstr == NULL)
+    {
+      elf_hash_table (info)->dynstr = _bfd_elf_strtab_init ();
+      if (elf_hash_table (info)->dynstr == NULL)
+	return false;
+    }
+
+  s = bfd_make_section (abfd, ".dynamic");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return false;
+
+  /* The special symbol _DYNAMIC is always set to the start of the
+     .dynamic section.  This call occurs before we have processed the
+     symbols for any dynamic object, so we don't have to worry about
+     overriding a dynamic definition.  We could set _DYNAMIC in a
+     linker script, but we only want to define it if we are, in fact,
+     creating a .dynamic section.  We don't want to define it if there
+     is no .dynamic section, since on some ELF platforms the start up
+     code examines it to decide how to initialize the process.  */
+  bh = NULL;
+  if (! (_bfd_generic_link_add_one_symbol
+	 (info, abfd, "_DYNAMIC", BSF_GLOBAL, s, (bfd_vma) 0,
+	  (const char *) 0, false, get_elf_backend_data (abfd)->collect, &bh)))
+    return false;
+  h = (struct elf_link_hash_entry *) bh;
+  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+  h->type = STT_OBJECT;
+
+  if (info->shared
+      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
+    return false;
+
+  bed = get_elf_backend_data (abfd);
+
+  s = bfd_make_section (abfd, ".hash");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, LOG_FILE_ALIGN))
+    return false;
+  elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;
+
+  /* Let the backend create the rest of the sections.  This lets the
+     backend set the right flags.  The backend will normally create
+     the .got and .plt sections.  */
+  if (! (*bed->elf_backend_create_dynamic_sections) (abfd, info))
+    return false;
+
+  elf_hash_table (info)->dynamic_sections_created = true;
+
+  return true;
+}
+
+/* Add an entry to the .dynamic table.  */
+
+boolean
+elf_add_dynamic_entry (info, tag, val)
+     struct bfd_link_info *info;
+     bfd_vma tag;
+     bfd_vma val;
+{
+  Elf_Internal_Dyn dyn;
+  bfd *dynobj;
+  asection *s;
+  bfd_size_type newsize;
+  bfd_byte *newcontents;
+
+  if (! is_elf_hash_table (info))
+    return false;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  s = bfd_get_section_by_name (dynobj, ".dynamic");
+  BFD_ASSERT (s != NULL);
+
+  newsize = s->_raw_size + sizeof (Elf_External_Dyn);
+  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
+  if (newcontents == NULL)
+    return false;
+
+  dyn.d_tag = tag;
+  dyn.d_un.d_val = val;
+  elf_swap_dyn_out (dynobj, &dyn,
+		    (Elf_External_Dyn *) (newcontents + s->_raw_size));
+
+  s->_raw_size = newsize;
+  s->contents = newcontents;
+
+  return true;
+}
+
+/* Read and swap the relocs from the section indicated by SHDR.  This
+   may be either a REL or a RELA section.  The relocations are
+   translated into RELA relocations and stored in INTERNAL_RELOCS,
+   which should have already been allocated to contain enough space.
+   The EXTERNAL_RELOCS are a buffer where the external form of the
+   relocations should be stored.
+
+   Returns false if something goes wrong.  */
+
+static boolean
+elf_link_read_relocs_from_section (abfd, shdr, external_relocs,
+				   internal_relocs)
+     bfd *abfd;
+     Elf_Internal_Shdr *shdr;
+     PTR external_relocs;
+     Elf_Internal_Rela *internal_relocs;
+{
+  struct elf_backend_data *bed;
+  bfd_size_type amt;
+
+  /* If there aren't any relocations, that's OK.  */
+  if (!shdr)
+    return true;
+
+  /* Position ourselves at the start of the section.  */
+  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0)
+    return false;
+
+  /* Read the relocations.  */
+  if (bfd_bread (external_relocs, shdr->sh_size, abfd) != shdr->sh_size)
+    return false;
+
+  bed = get_elf_backend_data (abfd);
+
+  /* Convert the external relocations to the internal format.  */
+  if (shdr->sh_entsize == sizeof (Elf_External_Rel))
+    {
+      Elf_External_Rel *erel;
+      Elf_External_Rel *erelend;
+      Elf_Internal_Rela *irela;
+      Elf_Internal_Rel *irel;
+
+      erel = (Elf_External_Rel *) external_relocs;
+      erelend = erel + NUM_SHDR_ENTRIES (shdr);
+      irela = internal_relocs;
+      amt = bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rel);
+      irel = bfd_alloc (abfd, amt);
+      for (; erel < erelend; erel++, irela += bed->s->int_rels_per_ext_rel)
+	{
+	  unsigned int i;
+
+	  if (bed->s->swap_reloc_in)
+	    (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel, irel);
+	  else
+	    elf_swap_reloc_in (abfd, erel, irel);
+
+	  for (i = 0; i < bed->s->int_rels_per_ext_rel; ++i)
+	    {
+	      irela[i].r_offset = irel[i].r_offset;
+	      irela[i].r_info = irel[i].r_info;
+	      irela[i].r_addend = 0;
+	    }
+	}
+    }
+  else
+    {
+      Elf_External_Rela *erela;
+      Elf_External_Rela *erelaend;
+      Elf_Internal_Rela *irela;
+
+      BFD_ASSERT (shdr->sh_entsize == sizeof (Elf_External_Rela));
+
+      erela = (Elf_External_Rela *) external_relocs;
+      erelaend = erela + NUM_SHDR_ENTRIES (shdr);
+      irela = internal_relocs;
+      for (; erela < erelaend; erela++, irela += bed->s->int_rels_per_ext_rel)
+	{
+	  if (bed->s->swap_reloca_in)
+	    (*bed->s->swap_reloca_in) (abfd, (bfd_byte *) erela, irela);
+	  else
+	    elf_swap_reloca_in (abfd, erela, irela);
+	}
+    }
+
+  return true;
+}
+
+/* Read and swap the relocs for a section O.  They may have been
+   cached.  If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are
+   not NULL, they are used as buffers to read into.  They are known to
+   be large enough.  If the INTERNAL_RELOCS relocs argument is NULL,
+   the return value is allocated using either malloc or bfd_alloc,
+   according to the KEEP_MEMORY argument.  If O has two relocation
+   sections (both REL and RELA relocations), then the REL_HDR
+   relocations will appear first in INTERNAL_RELOCS, followed by the
+   REL_HDR2 relocations.  */
+
+Elf_Internal_Rela *
+NAME(_bfd_elf,link_read_relocs) (abfd, o, external_relocs, internal_relocs,
+				 keep_memory)
+     bfd *abfd;
+     asection *o;
+     PTR external_relocs;
+     Elf_Internal_Rela *internal_relocs;
+     boolean keep_memory;
+{
+  Elf_Internal_Shdr *rel_hdr;
+  PTR alloc1 = NULL;
+  Elf_Internal_Rela *alloc2 = NULL;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+
+  if (elf_section_data (o)->relocs != NULL)
+    return elf_section_data (o)->relocs;
+
+  if (o->reloc_count == 0)
+    return NULL;
+
+  rel_hdr = &elf_section_data (o)->rel_hdr;
+
+  if (internal_relocs == NULL)
+    {
+      bfd_size_type size;
+
+      size = o->reloc_count;
+      size *= bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rela);
+      if (keep_memory)
+	internal_relocs = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
+      else
+	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
+      if (internal_relocs == NULL)
+	goto error_return;
+    }
+
+  if (external_relocs == NULL)
+    {
+      bfd_size_type size = rel_hdr->sh_size;
+
+      if (elf_section_data (o)->rel_hdr2)
+	size += elf_section_data (o)->rel_hdr2->sh_size;
+      alloc1 = (PTR) bfd_malloc (size);
+      if (alloc1 == NULL)
+	goto error_return;
+      external_relocs = alloc1;
+    }
+
+  if (!elf_link_read_relocs_from_section (abfd, rel_hdr,
+					  external_relocs,
+					  internal_relocs))
+    goto error_return;
+  if (!elf_link_read_relocs_from_section
+      (abfd,
+       elf_section_data (o)->rel_hdr2,
+       ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
+       internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
+			  * bed->s->int_rels_per_ext_rel)))
+    goto error_return;
+
+  /* Cache the results for next time, if we can.  */
+  if (keep_memory)
+    elf_section_data (o)->relocs = internal_relocs;
+
+  if (alloc1 != NULL)
+    free (alloc1);
+
+  /* Don't free alloc2, since if it was allocated we are passing it
+     back (under the name of internal_relocs).  */
+
+  return internal_relocs;
+
+ error_return:
+  if (alloc1 != NULL)
+    free (alloc1);
+  if (alloc2 != NULL)
+    free (alloc2);
+  return NULL;
+}
+
+/* Record an assignment to a symbol made by a linker script.  We need
+   this in case some dynamic object refers to this symbol.  */
+
+boolean
+NAME(bfd_elf,record_link_assignment) (output_bfd, info, name, provide)
+     bfd *output_bfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info *info;
+     const char *name;
+     boolean provide;
+{
+  struct elf_link_hash_entry *h;
+
+  if (info->hash->creator->flavour != bfd_target_elf_flavour)
+    return true;
+
+  h = elf_link_hash_lookup (elf_hash_table (info), name, true, true, false);
+  if (h == NULL)
+    return false;
+
+  if (h->root.type == bfd_link_hash_new)
+    h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
+
+  /* If this symbol is being provided by the linker script, and it is
+     currently defined by a dynamic object, but not by a regular
+     object, then mark it as undefined so that the generic linker will
+     force the correct value.  */
+  if (provide
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+    h->root.type = bfd_link_hash_undefined;
+
+  /* If this symbol is not being provided by the linker script, and it is
+     currently defined by a dynamic object, but not by a regular object,
+     then clear out any version information because the symbol will not be
+     associated with the dynamic object any more.  */
+  if (!provide
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+    h->verinfo.verdef = NULL;
+
+  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+
+  if (((h->elf_link_hash_flags & (ELF_LINK_HASH_DEF_DYNAMIC
+				  | ELF_LINK_HASH_REF_DYNAMIC)) != 0
+       || info->shared)
+      && h->dynindx == -1)
+    {
+      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+	return false;
+
+      /* If this is a weak defined symbol, and we know a corresponding
+	 real symbol from the same dynamic object, make sure the real
+	 symbol is also made into a dynamic symbol.  */
+      if (h->weakdef != NULL
+	  && h->weakdef->dynindx == -1)
+	{
+	  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
+	    return false;
+	}
+    }
+
+  return true;
+}
+
+/* This structure is used to pass information to
+   elf_link_assign_sym_version.  */
+
+struct elf_assign_sym_version_info
+{
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* Version tree.  */
+  struct bfd_elf_version_tree *verdefs;
+  /* Whether we had a failure.  */
+  boolean failed;
+};
+
+/* This structure is used to pass information to
+   elf_link_find_version_dependencies.  */
+
+struct elf_find_verdep_info
+{
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* The number of dependencies.  */
+  unsigned int vers;
+  /* Whether we had a failure.  */
+  boolean failed;
+};
+
+/* Array used to determine the number of hash table buckets to use
+   based on the number of symbols there are.  If there are fewer than
+   3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,
+   fewer than 37 we use 17 buckets, and so forth.  We never use more
+   than 32771 buckets.  */
+
+static const size_t elf_buckets[] =
+{
+  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
+  16411, 32771, 0
+};
+
+/* Compute bucket count for hashing table.  We do not use a static set
+   of possible tables sizes anymore.  Instead we determine for all
+   possible reasonable sizes of the table the outcome (i.e., the
+   number of collisions etc) and choose the best solution.  The
+   weighting functions are not too simple to allow the table to grow
+   without bounds.  Instead one of the weighting factors is the size.
+   Therefore the result is always a good payoff between few collisions
+   (= short chain lengths) and table size.  */
+static size_t
+compute_bucket_count (info)
+     struct bfd_link_info *info;
+{
+  size_t dynsymcount = elf_hash_table (info)->dynsymcount;
+  size_t best_size = 0;
+  unsigned long int *hashcodes;
+  unsigned long int *hashcodesp;
+  unsigned long int i;
+  bfd_size_type amt;
+
+  /* Compute the hash values for all exported symbols.  At the same
+     time store the values in an array so that we could use them for
+     optimizations.  */
+  amt = dynsymcount;
+  amt *= sizeof (unsigned long int);
+  hashcodes = (unsigned long int *) bfd_malloc (amt);
+  if (hashcodes == NULL)
+    return 0;
+  hashcodesp = hashcodes;
+
+  /* Put all hash values in HASHCODES.  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_collect_hash_codes, &hashcodesp);
+
+  /* We have a problem here.  The following code to optimize the table
+     size requires an integer type with more the 32 bits.  If
+     BFD_HOST_U_64_BIT is set we know about such a type.  */
+#ifdef BFD_HOST_U_64_BIT
+  if (info->optimize)
+    {
+      unsigned long int nsyms = hashcodesp - hashcodes;
+      size_t minsize;
+      size_t maxsize;
+      BFD_HOST_U_64_BIT best_chlen = ~((BFD_HOST_U_64_BIT) 0);
+      unsigned long int *counts ;
+
+      /* Possible optimization parameters: if we have NSYMS symbols we say
+	 that the hashing table must at least have NSYMS/4 and at most
+	 2*NSYMS buckets.  */
+      minsize = nsyms / 4;
+      if (minsize == 0)
+	minsize = 1;
+      best_size = maxsize = nsyms * 2;
+
+      /* Create array where we count the collisions in.  We must use bfd_malloc
+	 since the size could be large.  */
+      amt = maxsize;
+      amt *= sizeof (unsigned long int);
+      counts = (unsigned long int *) bfd_malloc (amt);
+      if (counts == NULL)
+	{
+	  free (hashcodes);
+	  return 0;
+	}
+
+      /* Compute the "optimal" size for the hash table.  The criteria is a
+	 minimal chain length.  The minor criteria is (of course) the size
+	 of the table.  */
+      for (i = minsize; i < maxsize; ++i)
+	{
+	  /* Walk through the array of hashcodes and count the collisions.  */
+	  BFD_HOST_U_64_BIT max;
+	  unsigned long int j;
+	  unsigned long int fact;
+
+	  memset (counts, '\0', i * sizeof (unsigned long int));
+
+	  /* Determine how often each hash bucket is used.  */
+	  for (j = 0; j < nsyms; ++j)
+	    ++counts[hashcodes[j] % i];
+
+	  /* For the weight function we need some information about the
+	     pagesize on the target.  This is information need not be 100%
+	     accurate.  Since this information is not available (so far) we
+	     define it here to a reasonable default value.  If it is crucial
+	     to have a better value some day simply define this value.  */
+# ifndef BFD_TARGET_PAGESIZE
+#  define BFD_TARGET_PAGESIZE	(4096)
+# endif
+
+	  /* We in any case need 2 + NSYMS entries for the size values and
+	     the chains.  */
+	  max = (2 + nsyms) * (ARCH_SIZE / 8);
+
+# if 1
+	  /* Variant 1: optimize for short chains.  We add the squares
+	     of all the chain lengths (which favous many small chain
+	     over a few long chains).  */
+	  for (j = 0; j < i; ++j)
+	    max += counts[j] * counts[j];
+
+	  /* This adds penalties for the overall size of the table.  */
+	  fact = i / (BFD_TARGET_PAGESIZE / (ARCH_SIZE / 8)) + 1;
+	  max *= fact * fact;
+# else
+	  /* Variant 2: Optimize a lot more for small table.  Here we
+	     also add squares of the size but we also add penalties for
+	     empty slots (the +1 term).  */
+	  for (j = 0; j < i; ++j)
+	    max += (1 + counts[j]) * (1 + counts[j]);
+
+	  /* The overall size of the table is considered, but not as
+	     strong as in variant 1, where it is squared.  */
+	  fact = i / (BFD_TARGET_PAGESIZE / (ARCH_SIZE / 8)) + 1;
+	  max *= fact;
+# endif
+
+	  /* Compare with current best results.  */
+	  if (max < best_chlen)
+	    {
+	      best_chlen = max;
+	      best_size = i;
+	    }
+	}
+
+      free (counts);
+    }
+  else
+#endif /* defined (BFD_HOST_U_64_BIT) */
+    {
+      /* This is the fallback solution if no 64bit type is available or if we
+	 are not supposed to spend much time on optimizations.  We select the
+	 bucket count using a fixed set of numbers.  */
+      for (i = 0; elf_buckets[i] != 0; i++)
+	{
+	  best_size = elf_buckets[i];
+	  if (dynsymcount < elf_buckets[i + 1])
+	    break;
+	}
+    }
+
+  /* Free the arrays we needed.  */
+  free (hashcodes);
+
+  return best_size;
+}
+
+/* Set up the sizes and contents of the ELF dynamic sections.  This is
+   called by the ELF linker emulation before_allocation routine.  We
+   must set the sizes of the sections before the linker sets the
+   addresses of the various sections.  */
+
+boolean
+NAME(bfd_elf,size_dynamic_sections) (output_bfd, soname, rpath,
+				     filter_shlib,
+				     auxiliary_filters, info, sinterpptr,
+				     verdefs)
+     bfd *output_bfd;
+     const char *soname;
+     const char *rpath;
+     const char *filter_shlib;
+     const char * const *auxiliary_filters;
+     struct bfd_link_info *info;
+     asection **sinterpptr;
+     struct bfd_elf_version_tree *verdefs;
+{
+  bfd_size_type soname_indx;
+  bfd *dynobj;
+  struct elf_backend_data *bed;
+  struct elf_assign_sym_version_info asvinfo;
+
+  *sinterpptr = NULL;
+
+  soname_indx = (bfd_size_type) -1;
+
+  if (info->hash->creator->flavour != bfd_target_elf_flavour)
+    return true;
+
+  if (! is_elf_hash_table (info))
+    return true;
+
+  /* Any syms created from now on start with -1 in
+     got.refcount/offset and plt.refcount/offset.  */
+  elf_hash_table (info)->init_refcount = -1;
+
+  /* The backend may have to create some sections regardless of whether
+     we're dynamic or not.  */
+  bed = get_elf_backend_data (output_bfd);
+  if (bed->elf_backend_always_size_sections
+      && ! (*bed->elf_backend_always_size_sections) (output_bfd, info))
+    return false;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* If there were no dynamic objects in the link, there is nothing to
+     do here.  */
+  if (dynobj == NULL)
+    return true;
+
+  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))
+    return false;
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      struct elf_info_failed eif;
+      struct elf_link_hash_entry *h;
+      asection *dynstr;
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_expr *d;
+      boolean all_defined;
+
+      *sinterpptr = bfd_get_section_by_name (dynobj, ".interp");
+      BFD_ASSERT (*sinterpptr != NULL || info->shared);
+
+      if (soname != NULL)
+	{
+	  soname_indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					     soname, true);
+	  if (soname_indx == (bfd_size_type) -1
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_SONAME,
+					  soname_indx))
+	    return false;
+	}
+
+      if (info->symbolic)
+	{
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_SYMBOLIC,
+				       (bfd_vma) 0))
+	    return false;
+	  info->flags |= DF_SYMBOLIC;
+	}
+
+      if (rpath != NULL)
+	{
+	  bfd_size_type indx;
+
+	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, rpath,
+				      true);
+	  if (info->new_dtags)
+	    _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr, indx);
+	  if (indx == (bfd_size_type) -1
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_RPATH, indx)
+	      || (info->new_dtags
+		  && ! elf_add_dynamic_entry (info, (bfd_vma) DT_RUNPATH,
+					      indx)))
+	    return false;
+	}
+
+      if (filter_shlib != NULL)
+	{
+	  bfd_size_type indx;
+
+	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+				      filter_shlib, true);
+	  if (indx == (bfd_size_type) -1
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_FILTER, indx))
+	    return false;
+	}
+
+      if (auxiliary_filters != NULL)
+	{
+	  const char * const *p;
+
+	  for (p = auxiliary_filters; *p != NULL; p++)
+	    {
+	      bfd_size_type indx;
+
+	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					  *p, true);
+	      if (indx == (bfd_size_type) -1
+		  || ! elf_add_dynamic_entry (info, (bfd_vma) DT_AUXILIARY,
+					      indx))
+		return false;
+	    }
+	}
+
+      eif.info = info;
+      eif.verdefs = verdefs;
+      eif.failed = false;
+
+      /* If we are supposed to export all symbols into the dynamic symbol
+	 table (this is not the normal case), then do so.  */
+      if (info->export_dynamic)
+	{
+	  elf_link_hash_traverse (elf_hash_table (info), elf_export_symbol,
+				  (PTR) &eif);
+	  if (eif.failed)
+	    return false;
+	}
+
+      /* Make all global versions with definiton.  */
+      for (t = verdefs; t != NULL; t = t->next)
+	for (d = t->globals; d != NULL; d = d->next)
+	  if (!d->symver && strchr (d->pattern, '*') == NULL)
+	    {
+	      const char *verstr, *name;
+	      size_t namelen, verlen, newlen;
+	      char *newname, *p;
+	      struct elf_link_hash_entry *newh;
+
+	      name = d->pattern;
+	      namelen = strlen (name);
+	      verstr = t->name;
+	      verlen = strlen (verstr);
+	      newlen = namelen + verlen + 3; 
+
+	      newname = (char *) bfd_malloc ((bfd_size_type) newlen);
+	      if (newname == NULL)
+		return false;
+	      memcpy (newname, name, namelen);
+
+	      /* Check the hidden versioned definition.  */
+	      p = newname + namelen;
+	      *p++ = ELF_VER_CHR;
+	      memcpy (p, verstr, verlen + 1);
+	      newh = elf_link_hash_lookup (elf_hash_table (info),
+					   newname, false, false,
+					   false);
+	      if (newh == NULL
+		  || (newh->root.type != bfd_link_hash_defined
+		      && newh->root.type != bfd_link_hash_defweak))
+		{
+		  /* Check the default versioned definition.  */
+		  *p++ = ELF_VER_CHR;
+		  memcpy (p, verstr, verlen + 1);
+		  newh = elf_link_hash_lookup (elf_hash_table (info),
+					       newname, false, false,
+					       false);
+		}
+	      free (newname);
+
+	      /* Mark this version if there is a definition and it is
+		 not defined in a shared object.  */
+	      if (newh != NULL
+		  && ((newh->elf_link_hash_flags
+		       & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
+		  && (newh->root.type == bfd_link_hash_defined
+		      || newh->root.type == bfd_link_hash_defweak))
+		d->symver = 1;
+	    }
+
+      /* Attach all the symbols to their version information.  */
+      asvinfo.output_bfd = output_bfd;
+      asvinfo.info = info;
+      asvinfo.verdefs = verdefs;
+      asvinfo.failed = false;
+
+      elf_link_hash_traverse (elf_hash_table (info),
+			      elf_link_assign_sym_version,
+			      (PTR) &asvinfo);
+      if (asvinfo.failed)
+	return false;
+
+      if (!info->allow_undefined_version)
+	{
+	  /* Check if all global versions have a definiton.  */
+	  all_defined = true;
+	  for (t = verdefs; t != NULL; t = t->next)
+	    for (d = t->globals; d != NULL; d = d->next)
+	      if (!d->symver && !d->script
+		  && strchr (d->pattern, '*') == NULL)
+		{
+		  (*_bfd_error_handler)
+		    (_("%s: undefined version: %s"),
+		     d->pattern, t->name);
+		  all_defined = false;
+		}
+
+	  if (!all_defined)
+	    {
+	      bfd_set_error (bfd_error_bad_value);
+	      return false;
+	    }
+	}
+
+      /* Find all symbols which were defined in a dynamic object and make
+	 the backend pick a reasonable value for them.  */
+      elf_link_hash_traverse (elf_hash_table (info),
+			      elf_adjust_dynamic_symbol,
+			      (PTR) &eif);
+      if (eif.failed)
+	return false;
+
+      /* Add some entries to the .dynamic section.  We fill in some of the
+	 values later, in elf_bfd_final_link, but we must add the entries
+	 now so that we know the final size of the .dynamic section.  */
+
+      /* If there are initialization and/or finalization functions to
+	 call then add the corresponding DT_INIT/DT_FINI entries.  */
+      h = (info->init_function
+	   ? elf_link_hash_lookup (elf_hash_table (info),
+				   info->init_function, false,
+				   false, false)
+	   : NULL);
+      if (h != NULL
+	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
+					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
+	{
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_INIT, (bfd_vma) 0))
+	    return false;
+	}
+      h = (info->fini_function
+	   ? elf_link_hash_lookup (elf_hash_table (info),
+				   info->fini_function, false,
+				   false, false)
+	   : NULL);
+      if (h != NULL
+	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
+					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
+	{
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_FINI, (bfd_vma) 0))
+	    return false;
+	}
+
+      if (bfd_get_section_by_name (output_bfd, ".preinit_array") != NULL)
+	{
+	  /* DT_PREINIT_ARRAY is not allowed in shared library.  */
+	  if (info->shared)
+	    {
+	      bfd *sub;
+	      asection *o;
+
+	      for (sub = info->input_bfds; sub != NULL;
+		   sub = sub->link_next)
+		for (o = sub->sections; o != NULL; o = o->next)
+		  if (elf_section_data (o)->this_hdr.sh_type
+		      == SHT_PREINIT_ARRAY)
+		    {
+		      (*_bfd_error_handler)
+			(_("%s: .preinit_array section is not allowed in DSO"),
+			 bfd_archive_filename (sub));
+		      break;
+		    }
+
+	      bfd_set_error (bfd_error_nonrepresentable_section);
+	      return false;
+	    }
+
+	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAY,
+				      (bfd_vma) 0)
+	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_PREINIT_ARRAYSZ,
+					 (bfd_vma) 0))
+	    return false;
+	}
+      if (bfd_get_section_by_name (output_bfd, ".init_array") != NULL)
+	{
+	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAY,
+				      (bfd_vma) 0)
+	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_INIT_ARRAYSZ,
+					 (bfd_vma) 0))
+	    return false;
+	}
+      if (bfd_get_section_by_name (output_bfd, ".fini_array") != NULL)
+	{
+	  if (!elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAY,
+				      (bfd_vma) 0)
+	      || !elf_add_dynamic_entry (info, (bfd_vma) DT_FINI_ARRAYSZ,
+					 (bfd_vma) 0))
+	    return false;
+	}
+
+      dynstr = bfd_get_section_by_name (dynobj, ".dynstr");
+      /* If .dynstr is excluded from the link, we don't want any of
+	 these tags.  Strictly, we should be checking each section
+	 individually;  This quick check covers for the case where
+	 someone does a /DISCARD/ : { *(*) }.  */
+      if (dynstr != NULL && dynstr->output_section != bfd_abs_section_ptr)
+	{
+	  bfd_size_type strsize;
+
+	  strsize = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_HASH, (bfd_vma) 0)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_STRTAB, (bfd_vma) 0)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_SYMTAB, (bfd_vma) 0)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_STRSZ, strsize)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_SYMENT,
+					  (bfd_vma) sizeof (Elf_External_Sym)))
+	    return false;
+	}
+    }
+
+  /* The backend must work out the sizes of all the other dynamic
+     sections.  */
+  if (bed->elf_backend_size_dynamic_sections
+      && ! (*bed->elf_backend_size_dynamic_sections) (output_bfd, info))
+    return false;
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      bfd_size_type dynsymcount;
+      asection *s;
+      size_t bucketcount = 0;
+      size_t hash_entry_size;
+      unsigned int dtagcount;
+
+      /* Set up the version definition section.  */
+      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
+      BFD_ASSERT (s != NULL);
+
+      /* We may have created additional version definitions if we are
+	 just linking a regular application.  */
+      verdefs = asvinfo.verdefs;
+
+      /* Skip anonymous version tag.  */
+      if (verdefs != NULL && verdefs->vernum == 0)
+	verdefs = verdefs->next;
+
+      if (verdefs == NULL)
+	_bfd_strip_section_from_output (info, s);
+      else
+	{
+	  unsigned int cdefs;
+	  bfd_size_type size;
+	  struct bfd_elf_version_tree *t;
+	  bfd_byte *p;
+	  Elf_Internal_Verdef def;
+	  Elf_Internal_Verdaux defaux;
+
+	  cdefs = 0;
+	  size = 0;
+
+	  /* Make space for the base version.  */
+	  size += sizeof (Elf_External_Verdef);
+	  size += sizeof (Elf_External_Verdaux);
+	  ++cdefs;
+
+	  for (t = verdefs; t != NULL; t = t->next)
+	    {
+	      struct bfd_elf_version_deps *n;
+
+	      size += sizeof (Elf_External_Verdef);
+	      size += sizeof (Elf_External_Verdaux);
+	      ++cdefs;
+
+	      for (n = t->deps; n != NULL; n = n->next)
+		size += sizeof (Elf_External_Verdaux);
+	    }
+
+	  s->_raw_size = size;
+	  s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
+	  if (s->contents == NULL && s->_raw_size != 0)
+	    return false;
+
+	  /* Fill in the version definition section.  */
+
+	  p = s->contents;
+
+	  def.vd_version = VER_DEF_CURRENT;
+	  def.vd_flags = VER_FLG_BASE;
+	  def.vd_ndx = 1;
+	  def.vd_cnt = 1;
+	  def.vd_aux = sizeof (Elf_External_Verdef);
+	  def.vd_next = (sizeof (Elf_External_Verdef)
+			 + sizeof (Elf_External_Verdaux));
+
+	  if (soname_indx != (bfd_size_type) -1)
+	    {
+	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
+				      soname_indx);
+	      def.vd_hash = bfd_elf_hash (soname);
+	      defaux.vda_name = soname_indx;
+	    }
+	  else
+	    {
+	      const char *name;
+	      bfd_size_type indx;
+
+	      name = basename (output_bfd->filename);
+	      def.vd_hash = bfd_elf_hash (name);
+	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					  name, false);
+	      if (indx == (bfd_size_type) -1)
+		return false;
+	      defaux.vda_name = indx;
+	    }
+	  defaux.vda_next = 0;
+
+	  _bfd_elf_swap_verdef_out (output_bfd, &def,
+				    (Elf_External_Verdef *) p);
+	  p += sizeof (Elf_External_Verdef);
+	  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
+				     (Elf_External_Verdaux *) p);
+	  p += sizeof (Elf_External_Verdaux);
+
+	  for (t = verdefs; t != NULL; t = t->next)
+	    {
+	      unsigned int cdeps;
+	      struct bfd_elf_version_deps *n;
+	      struct elf_link_hash_entry *h;
+	      struct bfd_link_hash_entry *bh;
+
+	      cdeps = 0;
+	      for (n = t->deps; n != NULL; n = n->next)
+		++cdeps;
+
+	      /* Add a symbol representing this version.  */
+	      bh = NULL;
+	      if (! (_bfd_generic_link_add_one_symbol
+		     (info, dynobj, t->name, BSF_GLOBAL, bfd_abs_section_ptr,
+		      (bfd_vma) 0, (const char *) NULL, false,
+		      get_elf_backend_data (dynobj)->collect, &bh)))
+		return false;
+	      h = (struct elf_link_hash_entry *) bh;
+	      h->elf_link_hash_flags &= ~ ELF_LINK_NON_ELF;
+	      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+	      h->type = STT_OBJECT;
+	      h->verinfo.vertree = t;
+
+	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+		return false;
+
+	      def.vd_version = VER_DEF_CURRENT;
+	      def.vd_flags = 0;
+	      if (t->globals == NULL && t->locals == NULL && ! t->used)
+		def.vd_flags |= VER_FLG_WEAK;
+	      def.vd_ndx = t->vernum + 1;
+	      def.vd_cnt = cdeps + 1;
+	      def.vd_hash = bfd_elf_hash (t->name);
+	      def.vd_aux = sizeof (Elf_External_Verdef);
+	      if (t->next != NULL)
+		def.vd_next = (sizeof (Elf_External_Verdef)
+			       + (cdeps + 1) * sizeof (Elf_External_Verdaux));
+	      else
+		def.vd_next = 0;
+
+	      _bfd_elf_swap_verdef_out (output_bfd, &def,
+					(Elf_External_Verdef *) p);
+	      p += sizeof (Elf_External_Verdef);
+
+	      defaux.vda_name = h->dynstr_index;
+	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
+				      h->dynstr_index);
+	      if (t->deps == NULL)
+		defaux.vda_next = 0;
+	      else
+		defaux.vda_next = sizeof (Elf_External_Verdaux);
+	      t->name_indx = defaux.vda_name;
+
+	      _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
+					 (Elf_External_Verdaux *) p);
+	      p += sizeof (Elf_External_Verdaux);
+
+	      for (n = t->deps; n != NULL; n = n->next)
+		{
+		  if (n->version_needed == NULL)
+		    {
+		      /* This can happen if there was an error in the
+			 version script.  */
+		      defaux.vda_name = 0;
+		    }
+		  else
+		    {
+		      defaux.vda_name = n->version_needed->name_indx;
+		      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
+					      defaux.vda_name);
+		    }
+		  if (n->next == NULL)
+		    defaux.vda_next = 0;
+		  else
+		    defaux.vda_next = sizeof (Elf_External_Verdaux);
+
+		  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
+					     (Elf_External_Verdaux *) p);
+		  p += sizeof (Elf_External_Verdaux);
+		}
+	    }
+
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_VERDEF, (bfd_vma) 0)
+	      || ! elf_add_dynamic_entry (info, (bfd_vma) DT_VERDEFNUM,
+					  (bfd_vma) cdefs))
+	    return false;
+
+	  elf_tdata (output_bfd)->cverdefs = cdefs;
+	}
+
+      if ((info->new_dtags && info->flags) || (info->flags & DF_STATIC_TLS))
+	{
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_FLAGS, info->flags))
+	    return false;
+	}
+
+      if (info->flags_1)
+	{
+	  if (! info->shared)
+	    info->flags_1 &= ~ (DF_1_INITFIRST
+				| DF_1_NODELETE
+				| DF_1_NOOPEN);
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_FLAGS_1,
+				       info->flags_1))
+	    return false;
+	}
+
+      /* Work out the size of the version reference section.  */
+
+      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
+      BFD_ASSERT (s != NULL);
+      {
+	struct elf_find_verdep_info sinfo;
+
+	sinfo.output_bfd = output_bfd;
+	sinfo.info = info;
+	sinfo.vers = elf_tdata (output_bfd)->cverdefs;
+	if (sinfo.vers == 0)
+	  sinfo.vers = 1;
+	sinfo.failed = false;
+
+	elf_link_hash_traverse (elf_hash_table (info),
+				elf_link_find_version_dependencies,
+				(PTR) &sinfo);
+
+	if (elf_tdata (output_bfd)->verref == NULL)
+	  _bfd_strip_section_from_output (info, s);
+	else
+	  {
+	    Elf_Internal_Verneed *t;
+	    unsigned int size;
+	    unsigned int crefs;
+	    bfd_byte *p;
+
+	    /* Build the version definition section.  */
+	    size = 0;
+	    crefs = 0;
+	    for (t = elf_tdata (output_bfd)->verref;
+		 t != NULL;
+		 t = t->vn_nextref)
+	      {
+		Elf_Internal_Vernaux *a;
+
+		size += sizeof (Elf_External_Verneed);
+		++crefs;
+		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+		  size += sizeof (Elf_External_Vernaux);
+	      }
+
+	    s->_raw_size = size;
+	    s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
+	    if (s->contents == NULL)
+	      return false;
+
+	    p = s->contents;
+	    for (t = elf_tdata (output_bfd)->verref;
+		 t != NULL;
+		 t = t->vn_nextref)
+	      {
+		unsigned int caux;
+		Elf_Internal_Vernaux *a;
+		bfd_size_type indx;
+
+		caux = 0;
+		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+		  ++caux;
+
+		t->vn_version = VER_NEED_CURRENT;
+		t->vn_cnt = caux;
+		indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					    elf_dt_name (t->vn_bfd) != NULL
+					    ? elf_dt_name (t->vn_bfd)
+					    : basename (t->vn_bfd->filename),
+					    false);
+		if (indx == (bfd_size_type) -1)
+		  return false;
+		t->vn_file = indx;
+		t->vn_aux = sizeof (Elf_External_Verneed);
+		if (t->vn_nextref == NULL)
+		  t->vn_next = 0;
+		else
+		  t->vn_next = (sizeof (Elf_External_Verneed)
+				+ caux * sizeof (Elf_External_Vernaux));
+
+		_bfd_elf_swap_verneed_out (output_bfd, t,
+					   (Elf_External_Verneed *) p);
+		p += sizeof (Elf_External_Verneed);
+
+		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+		  {
+		    a->vna_hash = bfd_elf_hash (a->vna_nodename);
+		    indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+						a->vna_nodename, false);
+		    if (indx == (bfd_size_type) -1)
+		      return false;
+		    a->vna_name = indx;
+		    if (a->vna_nextptr == NULL)
+		      a->vna_next = 0;
+		    else
+		      a->vna_next = sizeof (Elf_External_Vernaux);
+
+		    _bfd_elf_swap_vernaux_out (output_bfd, a,
+					       (Elf_External_Vernaux *) p);
+		    p += sizeof (Elf_External_Vernaux);
+		  }
+	      }
+
+	    if (! elf_add_dynamic_entry (info, (bfd_vma) DT_VERNEED,
+					 (bfd_vma) 0)
+		|| ! elf_add_dynamic_entry (info, (bfd_vma) DT_VERNEEDNUM,
+					    (bfd_vma) crefs))
+	      return false;
+
+	    elf_tdata (output_bfd)->cverrefs = crefs;
+	  }
+      }
+
+      /* Assign dynsym indicies.  In a shared library we generate a
+	 section symbol for each output section, which come first.
+	 Next come all of the back-end allocated local dynamic syms,
+	 followed by the rest of the global symbols.  */
+
+      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);
+
+      /* Work out the size of the symbol version section.  */
+      s = bfd_get_section_by_name (dynobj, ".gnu.version");
+      BFD_ASSERT (s != NULL);
+      if (dynsymcount == 0
+	  || (verdefs == NULL && elf_tdata (output_bfd)->verref == NULL))
+	{
+	  _bfd_strip_section_from_output (info, s);
+	  /* The DYNSYMCOUNT might have changed if we were going to
+	     output a dynamic symbol table entry for S.  */
+	  dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);
+	}
+      else
+	{
+	  s->_raw_size = dynsymcount * sizeof (Elf_External_Versym);
+	  s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
+	  if (s->contents == NULL)
+	    return false;
+
+	  if (! elf_add_dynamic_entry (info, (bfd_vma) DT_VERSYM, (bfd_vma) 0))
+	    return false;
+	}
+
+      /* Set the size of the .dynsym and .hash sections.  We counted
+	 the number of dynamic symbols in elf_link_add_object_symbols.
+	 We will build the contents of .dynsym and .hash when we build
+	 the final symbol table, because until then we do not know the
+	 correct value to give the symbols.  We built the .dynstr
+	 section as we went along in elf_link_add_object_symbols.  */
+      s = bfd_get_section_by_name (dynobj, ".dynsym");
+      BFD_ASSERT (s != NULL);
+      s->_raw_size = dynsymcount * sizeof (Elf_External_Sym);
+      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
+      if (s->contents == NULL && s->_raw_size != 0)
+	return false;
+
+      if (dynsymcount != 0)
+	{
+	  Elf_Internal_Sym isym;
+
+	  /* The first entry in .dynsym is a dummy symbol.  */
+	  isym.st_value = 0;
+	  isym.st_size = 0;
+	  isym.st_name = 0;
+	  isym.st_info = 0;
+	  isym.st_other = 0;
+	  isym.st_shndx = 0;
+	  elf_swap_symbol_out (output_bfd, &isym, (PTR) s->contents, (PTR) 0);
+	}
+
+      /* Compute the size of the hashing table.  As a side effect this
+	 computes the hash values for all the names we export.  */
+      bucketcount = compute_bucket_count (info);
+
+      s = bfd_get_section_by_name (dynobj, ".hash");
+      BFD_ASSERT (s != NULL);
+      hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;
+      s->_raw_size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
+      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
+      if (s->contents == NULL)
+	return false;
+
+      bfd_put (8 * hash_entry_size, output_bfd, (bfd_vma) bucketcount,
+	       s->contents);
+      bfd_put (8 * hash_entry_size, output_bfd, (bfd_vma) dynsymcount,
+	       s->contents + hash_entry_size);
+
+      elf_hash_table (info)->bucketcount = bucketcount;
+
+      s = bfd_get_section_by_name (dynobj, ".dynstr");
+      BFD_ASSERT (s != NULL);
+
+      elf_finalize_dynstr (output_bfd, info);
+
+      s->_raw_size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
+
+      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)
+	if (! elf_add_dynamic_entry (info, (bfd_vma) DT_NULL, (bfd_vma) 0))
+	  return false;
+    }
+
+  return true;
+}
+
+/* This function is used to adjust offsets into .dynstr for
+   dynamic symbols.  This is called via elf_link_hash_traverse.  */
+
+static boolean elf_adjust_dynstr_offsets
+PARAMS ((struct elf_link_hash_entry *, PTR));
+
+static boolean
+elf_adjust_dynstr_offsets (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_strtab_hash *dynstr = (struct elf_strtab_hash *) data;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if (h->dynindx != -1)
+    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
+  return true;
+}
+
+/* Assign string offsets in .dynstr, update all structures referencing
+   them.  */
+
+static boolean
+elf_finalize_dynstr (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  struct elf_link_local_dynamic_entry *entry;
+  struct elf_strtab_hash *dynstr = elf_hash_table (info)->dynstr;
+  bfd *dynobj = elf_hash_table (info)->dynobj;
+  asection *sdyn;
+  bfd_size_type size;
+  Elf_External_Dyn *dyncon, *dynconend;
+
+  _bfd_elf_strtab_finalize (dynstr);
+  size = _bfd_elf_strtab_size (dynstr);
+
+  /* Update all .dynamic entries referencing .dynstr strings.  */
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+  BFD_ASSERT (sdyn != NULL);
+
+  dyncon = (Elf_External_Dyn *) sdyn->contents;
+  dynconend = (Elf_External_Dyn *) (sdyn->contents +
+				    sdyn->_raw_size);
+  for (; dyncon < dynconend; dyncon++)
+    {
+      Elf_Internal_Dyn dyn;
+
+      elf_swap_dyn_in (dynobj, dyncon, & dyn);
+      switch (dyn.d_tag)
+	{
+	case DT_STRSZ:
+	  dyn.d_un.d_val = size;
+	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
+	  break;
+	case DT_NEEDED:
+	case DT_SONAME:
+	case DT_RPATH:
+	case DT_RUNPATH:
+	case DT_FILTER:
+	case DT_AUXILIARY:
+	  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
+	  elf_swap_dyn_out (dynobj, & dyn, dyncon);
+	  break;
+	default:
+	  break;
+	}
+    }
+
+  /* Now update local dynamic symbols.  */
+  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
+    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
+						  entry->isym.st_name);
+
+  /* And the rest of dynamic symbols.  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_adjust_dynstr_offsets, dynstr);
+
+  /* Adjust version definitions.  */
+  if (elf_tdata (output_bfd)->cverdefs)
+    {
+      asection *s;
+      bfd_byte *p;
+      bfd_size_type i;
+      Elf_Internal_Verdef def;
+      Elf_Internal_Verdaux defaux;
+
+      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
+      p = (bfd_byte *) s->contents;
+      do
+	{
+	  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
+				   &def);
+	  p += sizeof (Elf_External_Verdef);
+	  for (i = 0; i < def.vd_cnt; ++i)
+	    {
+	      _bfd_elf_swap_verdaux_in (output_bfd,
+					(Elf_External_Verdaux *) p, &defaux);
+	      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
+							defaux.vda_name);
+	      _bfd_elf_swap_verdaux_out (output_bfd,
+					 &defaux, (Elf_External_Verdaux *) p);
+	      p += sizeof (Elf_External_Verdaux);
+	    }
+	}
+      while (def.vd_next);
+    }
+
+  /* Adjust version references.  */
+  if (elf_tdata (output_bfd)->verref)
+    {
+      asection *s;
+      bfd_byte *p;
+      bfd_size_type i;
+      Elf_Internal_Verneed need;
+      Elf_Internal_Vernaux needaux;
+
+      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
+      p = (bfd_byte *) s->contents;
+      do
+	{
+	  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
+				    &need);
+	  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
+	  _bfd_elf_swap_verneed_out (output_bfd, &need,
+				     (Elf_External_Verneed *) p);
+	  p += sizeof (Elf_External_Verneed);
+	  for (i = 0; i < need.vn_cnt; ++i)
+	    {
+	      _bfd_elf_swap_vernaux_in (output_bfd,
+					(Elf_External_Vernaux *) p, &needaux);
+	      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
+							 needaux.vna_name);
+	      _bfd_elf_swap_vernaux_out (output_bfd,
+					 &needaux,
+					 (Elf_External_Vernaux *) p);
+	      p += sizeof (Elf_External_Vernaux);
+	    }
+	}
+      while (need.vn_next);
+    }
+
+  return true;
+}
+
+/* Fix up the flags for a symbol.  This handles various cases which
+   can only be fixed after all the input files are seen.  This is
+   currently called by both adjust_dynamic_symbol and
+   assign_sym_version, which is unnecessary but perhaps more robust in
+   the face of future changes.  */
+
+static boolean
+elf_fix_symbol_flags (h, eif)
+     struct elf_link_hash_entry *h;
+     struct elf_info_failed *eif;
+{
+  /* If this symbol was mentioned in a non-ELF file, try to set
+     DEF_REGULAR and REF_REGULAR correctly.  This is the only way to
+     permit a non-ELF file to correctly refer to a symbol defined in
+     an ELF dynamic object.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_NON_ELF) != 0)
+    {
+      while (h->root.type == bfd_link_hash_indirect)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      if (h->root.type != bfd_link_hash_defined
+	  && h->root.type != bfd_link_hash_defweak)
+	h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
+				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
+      else
+	{
+	  if (h->root.u.def.section->owner != NULL
+	      && (bfd_get_flavour (h->root.u.def.section->owner)
+		  == bfd_target_elf_flavour))
+	    h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
+				       | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
+	  else
+	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+	}
+
+      if (h->dynindx == -1
+	  && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+	      || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0))
+	{
+	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
+	    {
+	      eif->failed = true;
+	      return false;
+	    }
+	}
+    }
+  else
+    {
+      /* Unfortunately, ELF_LINK_NON_ELF is only correct if the symbol
+	 was first seen in a non-ELF file.  Fortunately, if the symbol
+	 was first seen in an ELF file, we're probably OK unless the
+	 symbol was defined in a non-ELF file.  Catch that case here.
+	 FIXME: We're still in trouble if the symbol was first seen in
+	 a dynamic object, and then later in a non-ELF regular object.  */
+      if ((h->root.type == bfd_link_hash_defined
+	   || h->root.type == bfd_link_hash_defweak)
+	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
+	  && (h->root.u.def.section->owner != NULL
+	      ? (bfd_get_flavour (h->root.u.def.section->owner)
+		 != bfd_target_elf_flavour)
+	      : (bfd_is_abs_section (h->root.u.def.section)
+		 && (h->elf_link_hash_flags
+		     & ELF_LINK_HASH_DEF_DYNAMIC) == 0)))
+	h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+    }
+
+  /* If this is a final link, and the symbol was defined as a common
+     symbol in a regular object file, and there was no definition in
+     any dynamic object, then the linker will have allocated space for
+     the symbol in a common section but the ELF_LINK_HASH_DEF_REGULAR
+     flag will not have been set.  */
+  if (h->root.type == bfd_link_hash_defined
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
+      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
+    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+
+  /* If -Bsymbolic was used (which means to bind references to global
+     symbols to the definition within the shared object), and this
+     symbol was defined in a regular object, then it actually doesn't
+     need a PLT entry, and we can accomplish that by forcing it local.
+     Likewise, if the symbol has hidden or internal visibility.
+     FIXME: It might be that we also do not need a PLT for other
+     non-hidden visibilities, but we would have to tell that to the
+     backend specifically; we can't just clear PLT-related data here.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
+      && eif->info->shared
+      && is_elf_hash_table (eif->info)
+      && (eif->info->symbolic
+	  || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
+	  || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
+    {
+      struct elf_backend_data *bed;
+      boolean force_local;
+
+      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
+
+      force_local = (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
+		     || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN);
+      (*bed->elf_backend_hide_symbol) (eif->info, h, force_local);
+    }
+
+  /* If this is a weak defined symbol in a dynamic object, and we know
+     the real definition in the dynamic object, copy interesting flags
+     over to the real definition.  */
+  if (h->weakdef != NULL)
+    {
+      struct elf_link_hash_entry *weakdef;
+
+      weakdef = h->weakdef;
+      if (h->root.type == bfd_link_hash_indirect)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      BFD_ASSERT (h->root.type == bfd_link_hash_defined
+		  || h->root.type == bfd_link_hash_defweak);
+      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
+		  || weakdef->root.type == bfd_link_hash_defweak);
+      BFD_ASSERT (weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC);
+
+      /* If the real definition is defined by a regular object file,
+	 don't do anything special.  See the longer description in
+	 elf_adjust_dynamic_symbol, below.  */
+      if ((weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
+	h->weakdef = NULL;
+      else
+	{
+	  struct elf_backend_data *bed;
+
+	  bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
+	  (*bed->elf_backend_copy_indirect_symbol) (bed, weakdef, h);
+	}
+    }
+
+  return true;
+}
+
+/* Make the backend pick a good value for a dynamic symbol.  This is
+   called via elf_link_hash_traverse, and also calls itself
+   recursively.  */
+
+static boolean
+elf_adjust_dynamic_symbol (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_info_failed *eif = (struct elf_info_failed *) data;
+  bfd *dynobj;
+  struct elf_backend_data *bed;
+
+  if (h->root.type == bfd_link_hash_warning)
+    {
+      h->plt.offset = (bfd_vma) -1;
+      h->got.offset = (bfd_vma) -1;
+
+      /* When warning symbols are created, they **replace** the "real"
+	 entry in the hash table, thus we never get to see the real
+	 symbol in a hash traversal.  So look at it now.  */
+      h = (struct elf_link_hash_entry *) h->root.u.i.link;
+    }
+
+  /* Ignore indirect symbols.  These are added by the versioning code.  */
+  if (h->root.type == bfd_link_hash_indirect)
+    return true;
+
+  if (! is_elf_hash_table (eif->info))
+    return false;
+
+  /* Fix the symbol flags.  */
+  if (! elf_fix_symbol_flags (h, eif))
+    return false;
+
+  /* If this symbol does not require a PLT entry, and it is not
+     defined by a dynamic object, or is not referenced by a regular
+     object, ignore it.  We do have to handle a weak defined symbol,
+     even if no regular object refers to it, if we decided to add it
+     to the dynamic symbol table.  FIXME: Do we normally need to worry
+     about symbols which are defined by one dynamic object and
+     referenced by another one?  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0
+      && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
+	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
+	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
+	      && (h->weakdef == NULL || h->weakdef->dynindx == -1))))
+    {
+      h->plt.offset = (bfd_vma) -1;
+      return true;
+    }
+
+  /* If we've already adjusted this symbol, don't do it again.  This
+     can happen via a recursive call.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
+    return true;
+
+  /* Don't look at this symbol again.  Note that we must set this
+     after checking the above conditions, because we may look at a
+     symbol once, decide not to do anything, and then get called
+     recursively later after REF_REGULAR is set below.  */
+  h->elf_link_hash_flags |= ELF_LINK_HASH_DYNAMIC_ADJUSTED;
+
+  /* If this is a weak definition, and we know a real definition, and
+     the real symbol is not itself defined by a regular object file,
+     then get a good value for the real definition.  We handle the
+     real symbol first, for the convenience of the backend routine.
+
+     Note that there is a confusing case here.  If the real definition
+     is defined by a regular object file, we don't get the real symbol
+     from the dynamic object, but we do get the weak symbol.  If the
+     processor backend uses a COPY reloc, then if some routine in the
+     dynamic object changes the real symbol, we will not see that
+     change in the corresponding weak symbol.  This is the way other
+     ELF linkers work as well, and seems to be a result of the shared
+     library model.
+
+     I will clarify this issue.  Most SVR4 shared libraries define the
+     variable _timezone and define timezone as a weak synonym.  The
+     tzset call changes _timezone.  If you write
+       extern int timezone;
+       int _timezone = 5;
+       int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }
+     you might expect that, since timezone is a synonym for _timezone,
+     the same number will print both times.  However, if the processor
+     backend uses a COPY reloc, then actually timezone will be copied
+     into your process image, and, since you define _timezone
+     yourself, _timezone will not.  Thus timezone and _timezone will
+     wind up at different memory locations.  The tzset call will set
+     _timezone, leaving timezone unchanged.  */
+
+  if (h->weakdef != NULL)
+    {
+      /* If we get to this point, we know there is an implicit
+	 reference by a regular object file via the weak symbol H.
+	 FIXME: Is this really true?  What if the traversal finds
+	 H->WEAKDEF before it finds H?  */
+      h->weakdef->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
+
+      if (! elf_adjust_dynamic_symbol (h->weakdef, (PTR) eif))
+	return false;
+    }
+
+  /* If a symbol has no type and no size and does not require a PLT
+     entry, then we are probably about to do the wrong thing here: we
+     are probably going to create a COPY reloc for an empty object.
+     This case can arise when a shared object is built with assembly
+     code, and the assembly code fails to set the symbol type.  */
+  if (h->size == 0
+      && h->type == STT_NOTYPE
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
+    (*_bfd_error_handler)
+      (_("warning: type and size of dynamic symbol `%s' are not defined"),
+       h->root.root.string);
+
+  dynobj = elf_hash_table (eif->info)->dynobj;
+  bed = get_elf_backend_data (dynobj);
+  if (! (*bed->elf_backend_adjust_dynamic_symbol) (eif->info, h))
+    {
+      eif->failed = true;
+      return false;
+    }
+
+  return true;
+}
+
+/* This routine is used to export all defined symbols into the dynamic
+   symbol table.  It is called via elf_link_hash_traverse.  */
+
+static boolean
+elf_export_symbol (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_info_failed *eif = (struct elf_info_failed *) data;
+
+  /* Ignore indirect symbols.  These are added by the versioning code.  */
+  if (h->root.type == bfd_link_hash_indirect)
+    return true;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if (h->dynindx == -1
+      && (h->elf_link_hash_flags
+	  & (ELF_LINK_HASH_DEF_REGULAR | ELF_LINK_HASH_REF_REGULAR)) != 0)
+    {
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_expr *d;
+
+      for (t = eif->verdefs; t != NULL; t = t->next)
+	{
+	  if (t->globals != NULL)
+	    {
+	      for (d = t->globals; d != NULL; d = d->next)
+		{
+		  if ((*d->match) (d, h->root.root.string))
+		    goto doit;
+		}
+	    }
+
+	  if (t->locals != NULL)
+	    {
+	      for (d = t->locals ; d != NULL; d = d->next)
+		{
+		  if ((*d->match) (d, h->root.root.string))
+		    return true;
+		}
+	    }
+	}
+
+      if (!eif->verdefs)
+	{
+	doit:
+	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
+	    {
+	      eif->failed = true;
+	      return false;
+	    }
+	}
+    }
+
+  return true;
+}
+
+/* Look through the symbols which are defined in other shared
+   libraries and referenced here.  Update the list of version
+   dependencies.  This will be put into the .gnu.version_r section.
+   This function is called via elf_link_hash_traverse.  */
+
+static boolean
+elf_link_find_version_dependencies (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_find_verdep_info *rinfo = (struct elf_find_verdep_info *) data;
+  Elf_Internal_Verneed *t;
+  Elf_Internal_Vernaux *a;
+  bfd_size_type amt;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* We only care about symbols defined in shared objects with version
+     information.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
+      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
+      || h->dynindx == -1
+      || h->verinfo.verdef == NULL)
+    return true;
+
+  /* See if we already know about this version.  */
+  for (t = elf_tdata (rinfo->output_bfd)->verref; t != NULL; t = t->vn_nextref)
+    {
+      if (t->vn_bfd != h->verinfo.verdef->vd_bfd)
+	continue;
+
+      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
+	  return true;
+
+      break;
+    }
+
+  /* This is a new version.  Add it to tree we are building.  */
+
+  if (t == NULL)
+    {
+      amt = sizeof *t;
+      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->output_bfd, amt);
+      if (t == NULL)
+	{
+	  rinfo->failed = true;
+	  return false;
+	}
+
+      t->vn_bfd = h->verinfo.verdef->vd_bfd;
+      t->vn_nextref = elf_tdata (rinfo->output_bfd)->verref;
+      elf_tdata (rinfo->output_bfd)->verref = t;
+    }
+
+  amt = sizeof *a;
+  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->output_bfd, amt);
+
+  /* Note that we are copying a string pointer here, and testing it
+     above.  If bfd_elf_string_from_elf_section is ever changed to
+     discard the string data when low in memory, this will have to be
+     fixed.  */
+  a->vna_nodename = h->verinfo.verdef->vd_nodename;
+
+  a->vna_flags = h->verinfo.verdef->vd_flags;
+  a->vna_nextptr = t->vn_auxptr;
+
+  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
+  ++rinfo->vers;
+
+  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;
+
+  t->vn_auxptr = a;
+
+  return true;
+}
+
+/* Figure out appropriate versions for all the symbols.  We may not
+   have the version number script until we have read all of the input
+   files, so until that point we don't know which symbols should be
+   local.  This function is called via elf_link_hash_traverse.  */
+
+static boolean
+elf_link_assign_sym_version (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_assign_sym_version_info *sinfo;
+  struct bfd_link_info *info;
+  struct elf_backend_data *bed;
+  struct elf_info_failed eif;
+  char *p;
+  bfd_size_type amt;
+
+  sinfo = (struct elf_assign_sym_version_info *) data;
+  info = sinfo->info;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Fix the symbol flags.  */
+  eif.failed = false;
+  eif.info = info;
+  if (! elf_fix_symbol_flags (h, &eif))
+    {
+      if (eif.failed)
+	sinfo->failed = true;
+      return false;
+    }
+
+  /* We only need version numbers for symbols defined in regular
+     objects.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+    return true;
+
+  bed = get_elf_backend_data (sinfo->output_bfd);
+  p = strchr (h->root.root.string, ELF_VER_CHR);
+  if (p != NULL && h->verinfo.vertree == NULL)
+    {
+      struct bfd_elf_version_tree *t;
+      boolean hidden;
+
+      hidden = true;
+
+      /* There are two consecutive ELF_VER_CHR characters if this is
+	 not a hidden symbol.  */
+      ++p;
+      if (*p == ELF_VER_CHR)
+	{
+	  hidden = false;
+	  ++p;
+	}
+
+      /* If there is no version string, we can just return out.  */
+      if (*p == '\0')
+	{
+	  if (hidden)
+	    h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
+	  return true;
+	}
+
+      /* Look for the version.  If we find it, it is no longer weak.  */
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (strcmp (t->name, p) == 0)
+	    {
+	      size_t len;
+	      char *alc;
+	      struct bfd_elf_version_expr *d;
+
+	      len = p - h->root.root.string;
+	      alc = bfd_malloc ((bfd_size_type) len);
+	      if (alc == NULL)
+		return false;
+	      memcpy (alc, h->root.root.string, len - 1);
+	      alc[len - 1] = '\0';
+	      if (alc[len - 2] == ELF_VER_CHR)
+		alc[len - 2] = '\0';
+
+	      h->verinfo.vertree = t;
+	      t->used = true;
+	      d = NULL;
+
+	      if (t->globals != NULL)
+		{
+		  for (d = t->globals; d != NULL; d = d->next)
+		    if ((*d->match) (d, alc))
+		      break;
+		}
+
+	      /* See if there is anything to force this symbol to
+		 local scope.  */
+	      if (d == NULL && t->locals != NULL)
+		{
+		  for (d = t->locals; d != NULL; d = d->next)
+		    {
+		      if ((*d->match) (d, alc))
+			{
+			  if (h->dynindx != -1
+			      && info->shared
+			      && ! info->export_dynamic)
+			    {
+			      (*bed->elf_backend_hide_symbol) (info, h, true);
+			    }
+
+			  break;
+			}
+		    }
+		}
+
+	      free (alc);
+	      break;
+	    }
+	}
+
+      /* If we are building an application, we need to create a
+	 version node for this version.  */
+      if (t == NULL && ! info->shared)
+	{
+	  struct bfd_elf_version_tree **pp;
+	  int version_index;
+
+	  /* If we aren't going to export this symbol, we don't need
+	     to worry about it.  */
+	  if (h->dynindx == -1)
+	    return true;
+
+	  amt = sizeof *t;
+	  t = ((struct bfd_elf_version_tree *)
+	       bfd_alloc (sinfo->output_bfd, amt));
+	  if (t == NULL)
+	    {
+	      sinfo->failed = true;
+	      return false;
+	    }
+
+	  t->next = NULL;
+	  t->name = p;
+	  t->globals = NULL;
+	  t->locals = NULL;
+	  t->deps = NULL;
+	  t->name_indx = (unsigned int) -1;
+	  t->used = true;
+
+	  version_index = 1;
+	  /* Don't count anonymous version tag.  */
+	  if (sinfo->verdefs != NULL && sinfo->verdefs->vernum == 0)
+	    version_index = 0;
+	  for (pp = &sinfo->verdefs; *pp != NULL; pp = &(*pp)->next)
+	    ++version_index;
+	  t->vernum = version_index;
+
+	  *pp = t;
+
+	  h->verinfo.vertree = t;
+	}
+      else if (t == NULL)
+	{
+	  /* We could not find the version for a symbol when
+	     generating a shared archive.  Return an error.  */
+	  (*_bfd_error_handler)
+	    (_("%s: undefined versioned symbol name %s"),
+	     bfd_get_filename (sinfo->output_bfd), h->root.root.string);
+	  bfd_set_error (bfd_error_bad_value);
+	  sinfo->failed = true;
+	  return false;
+	}
+
+      if (hidden)
+	h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
+    }
+
+  /* If we don't have a version for this symbol, see if we can find
+     something.  */
+  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
+    {
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_tree *local_ver;
+      struct bfd_elf_version_expr *d;
+
+      /* See if can find what version this symbol is in.  If the
+	 symbol is supposed to be local, then don't actually register
+	 it.  */
+      local_ver = NULL;
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (t->globals != NULL)
+	    {
+	      boolean matched;
+
+	      matched = false;
+	      for (d = t->globals; d != NULL; d = d->next)
+		{
+		  if ((*d->match) (d, h->root.root.string))
+		    {
+		      if (d->symver)
+			matched = true;
+		      else
+			{
+			  /* There is a version without definition.  Make
+			     the symbol the default definition for this
+			     version.  */
+			  h->verinfo.vertree = t;
+			  local_ver = NULL;
+			  d->script = 1;
+			  break;
+			}
+		    }
+		}
+
+	      if (d != NULL)
+		break;
+	      else if (matched)
+		/* There is no undefined version for this symbol. Hide the
+		   default one.  */
+		(*bed->elf_backend_hide_symbol) (info, h, true);
+	    }
+
+	  if (t->locals != NULL)
+	    {
+	      for (d = t->locals; d != NULL; d = d->next)
+		{
+		  /* If the match is "*", keep looking for a more
+		     explicit, perhaps even global, match.  */
+		  if (d->pattern[0] == '*' && d->pattern[1] == '\0')
+		    local_ver = t;
+		  else if ((*d->match) (d, h->root.root.string))
+		    {
+		      local_ver = t;
+		      break;
+		    }
+		}
+
+	      if (d != NULL)
+		break;
+	    }
+	}
+
+      if (local_ver != NULL)
+	{
+	  h->verinfo.vertree = local_ver;
+	  if (h->dynindx != -1
+	      && info->shared
+	      && ! info->export_dynamic)
+	    {
+	      (*bed->elf_backend_hide_symbol) (info, h, true);
+	    }
+	}
+    }
+
+  return true;
+}
+
+/* Final phase of ELF linker.  */
+
+/* A structure we use to avoid passing large numbers of arguments.  */
+
+struct elf_final_link_info
+{
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* Symbol string table.  */
+  struct bfd_strtab_hash *symstrtab;
+  /* .dynsym section.  */
+  asection *dynsym_sec;
+  /* .hash section.  */
+  asection *hash_sec;
+  /* symbol version section (.gnu.version).  */
+  asection *symver_sec;
+  /* first SHF_TLS section (if any).  */
+  asection *first_tls_sec;
+  /* Buffer large enough to hold contents of any section.  */
+  bfd_byte *contents;
+  /* Buffer large enough to hold external relocs of any section.  */
+  PTR external_relocs;
+  /* Buffer large enough to hold internal relocs of any section.  */
+  Elf_Internal_Rela *internal_relocs;
+  /* Buffer large enough to hold external local symbols of any input
+     BFD.  */
+  Elf_External_Sym *external_syms;
+  /* And a buffer for symbol section indices.  */
+  Elf_External_Sym_Shndx *locsym_shndx;
+  /* Buffer large enough to hold internal local symbols of any input
+     BFD.  */
+  Elf_Internal_Sym *internal_syms;
+  /* Array large enough to hold a symbol index for each local symbol
+     of any input BFD.  */
+  long *indices;
+  /* Array large enough to hold a section pointer for each local
+     symbol of any input BFD.  */
+  asection **sections;
+  /* Buffer to hold swapped out symbols.  */
+  Elf_External_Sym *symbuf;
+  /* And one for symbol section indices.  */
+  Elf_External_Sym_Shndx *symshndxbuf;
+  /* Number of swapped out symbols in buffer.  */
+  size_t symbuf_count;
+  /* Number of symbols which fit in symbuf.  */
+  size_t symbuf_size;
+};
+
+static boolean elf_link_output_sym
+  PARAMS ((struct elf_final_link_info *, const char *,
+	   Elf_Internal_Sym *, asection *));
+static boolean elf_link_flush_output_syms
+  PARAMS ((struct elf_final_link_info *));
+static boolean elf_link_output_extsym
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static boolean elf_link_sec_merge_syms
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+static boolean elf_link_check_versioned_symbol
+  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
+static boolean elf_link_input_bfd
+  PARAMS ((struct elf_final_link_info *, bfd *));
+static boolean elf_reloc_link_order
+  PARAMS ((bfd *, struct bfd_link_info *, asection *,
+	   struct bfd_link_order *));
+
+/* This struct is used to pass information to elf_link_output_extsym.  */
+
+struct elf_outext_info
+{
+  boolean failed;
+  boolean localsyms;
+  struct elf_final_link_info *finfo;
+};
+
+/* Compute the size of, and allocate space for, REL_HDR which is the
+   section header for a section containing relocations for O.  */
+
+static boolean
+elf_link_size_reloc_section (abfd, rel_hdr, o)
+     bfd *abfd;
+     Elf_Internal_Shdr *rel_hdr;
+     asection *o;
+{
+  bfd_size_type reloc_count;
+  bfd_size_type num_rel_hashes;
+
+  /* Figure out how many relocations there will be.  */
+  if (rel_hdr == &elf_section_data (o)->rel_hdr)
+    reloc_count = elf_section_data (o)->rel_count;
+  else
+    reloc_count = elf_section_data (o)->rel_count2;
+
+  num_rel_hashes = o->reloc_count;
+  if (num_rel_hashes < reloc_count)
+    num_rel_hashes = reloc_count;
+
+  /* That allows us to calculate the size of the section.  */
+  rel_hdr->sh_size = rel_hdr->sh_entsize * reloc_count;
+
+  /* The contents field must last into write_object_contents, so we
+     allocate it with bfd_alloc rather than malloc.  Also since we
+     cannot be sure that the contents will actually be filled in,
+     we zero the allocated space.  */
+  rel_hdr->contents = (PTR) bfd_zalloc (abfd, rel_hdr->sh_size);
+  if (rel_hdr->contents == NULL && rel_hdr->sh_size != 0)
+    return false;
+
+  /* We only allocate one set of hash entries, so we only do it the
+     first time we are called.  */
+  if (elf_section_data (o)->rel_hashes == NULL
+      && num_rel_hashes)
+    {
+      struct elf_link_hash_entry **p;
+
+      p = ((struct elf_link_hash_entry **)
+	   bfd_zmalloc (num_rel_hashes
+			* sizeof (struct elf_link_hash_entry *)));
+      if (p == NULL)
+	return false;
+
+      elf_section_data (o)->rel_hashes = p;
+    }
+
+  return true;
+}
+
+/* When performing a relocateable link, the input relocations are
+   preserved.  But, if they reference global symbols, the indices
+   referenced must be updated.  Update all the relocations in
+   REL_HDR (there are COUNT of them), using the data in REL_HASH.  */
+
+static void
+elf_link_adjust_relocs (abfd, rel_hdr, count, rel_hash)
+     bfd *abfd;
+     Elf_Internal_Shdr *rel_hdr;
+     unsigned int count;
+     struct elf_link_hash_entry **rel_hash;
+{
+  unsigned int i;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  Elf_Internal_Rel *irel;
+  Elf_Internal_Rela *irela;
+  bfd_size_type amt = sizeof (Elf_Internal_Rel) * bed->s->int_rels_per_ext_rel;
+
+  irel = (Elf_Internal_Rel *) bfd_zmalloc (amt);
+  if (irel == NULL)
+    {
+      (*_bfd_error_handler) (_("Error: out of memory"));
+      abort ();
+    }
+
+  amt = sizeof (Elf_Internal_Rela) * bed->s->int_rels_per_ext_rel;
+  irela = (Elf_Internal_Rela *) bfd_zmalloc (amt);
+  if (irela == NULL)
+    {
+      (*_bfd_error_handler) (_("Error: out of memory"));
+      abort ();
+    }
+
+  for (i = 0; i < count; i++, rel_hash++)
+    {
+      if (*rel_hash == NULL)
+	continue;
+
+      BFD_ASSERT ((*rel_hash)->indx >= 0);
+
+      if (rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
+	{
+	  Elf_External_Rel *erel;
+	  unsigned int j;
+
+	  erel = (Elf_External_Rel *) rel_hdr->contents + i;
+	  if (bed->s->swap_reloc_in)
+	    (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel, irel);
+	  else
+	    elf_swap_reloc_in (abfd, erel, irel);
+
+	  for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
+	    irel[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
+					 ELF_R_TYPE (irel[j].r_info));
+
+	  if (bed->s->swap_reloc_out)
+	    (*bed->s->swap_reloc_out) (abfd, irel, (bfd_byte *) erel);
+	  else
+	    elf_swap_reloc_out (abfd, irel, erel);
+	}
+      else
+	{
+	  Elf_External_Rela *erela;
+	  unsigned int j;
+
+	  BFD_ASSERT (rel_hdr->sh_entsize
+		      == sizeof (Elf_External_Rela));
+
+	  erela = (Elf_External_Rela *) rel_hdr->contents + i;
+	  if (bed->s->swap_reloca_in)
+	    (*bed->s->swap_reloca_in) (abfd, (bfd_byte *) erela, irela);
+	  else
+	    elf_swap_reloca_in (abfd, erela, irela);
+
+	  for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
+	    irela[j].r_info = ELF_R_INFO ((*rel_hash)->indx,
+					  ELF_R_TYPE (irela[j].r_info));
+
+	  if (bed->s->swap_reloca_out)
+	    (*bed->s->swap_reloca_out) (abfd, irela, (bfd_byte *) erela);
+	  else
+	    elf_swap_reloca_out (abfd, irela, erela);
+	}
+    }
+
+  free (irel);
+  free (irela);
+}
+
+struct elf_link_sort_rela
+{
+  bfd_vma offset;
+  enum elf_reloc_type_class type;
+  union
+  {
+    Elf_Internal_Rel rel;
+    Elf_Internal_Rela rela;
+  } u;
+};
+
+static int
+elf_link_sort_cmp1 (A, B)
+     const PTR A;
+     const PTR B;
+{
+  struct elf_link_sort_rela *a = (struct elf_link_sort_rela *) A;
+  struct elf_link_sort_rela *b = (struct elf_link_sort_rela *) B;
+  int relativea, relativeb;
+
+  relativea = a->type == reloc_class_relative;
+  relativeb = b->type == reloc_class_relative;
+
+  if (relativea < relativeb)
+    return 1;
+  if (relativea > relativeb)
+    return -1;
+  if (ELF_R_SYM (a->u.rel.r_info) < ELF_R_SYM (b->u.rel.r_info))
+    return -1;
+  if (ELF_R_SYM (a->u.rel.r_info) > ELF_R_SYM (b->u.rel.r_info))
+    return 1;
+  if (a->u.rel.r_offset < b->u.rel.r_offset)
+    return -1;
+  if (a->u.rel.r_offset > b->u.rel.r_offset)
+    return 1;
+  return 0;
+}
+
+static int
+elf_link_sort_cmp2 (A, B)
+     const PTR A;
+     const PTR B;
+{
+  struct elf_link_sort_rela *a = (struct elf_link_sort_rela *) A;
+  struct elf_link_sort_rela *b = (struct elf_link_sort_rela *) B;
+  int copya, copyb;
+
+  if (a->offset < b->offset)
+    return -1;
+  if (a->offset > b->offset)
+    return 1;
+  copya = (a->type == reloc_class_copy) * 2 + (a->type == reloc_class_plt);
+  copyb = (b->type == reloc_class_copy) * 2 + (b->type == reloc_class_plt);
+  if (copya < copyb)
+    return -1;
+  if (copya > copyb)
+    return 1;
+  if (a->u.rel.r_offset < b->u.rel.r_offset)
+    return -1;
+  if (a->u.rel.r_offset > b->u.rel.r_offset)
+    return 1;
+  return 0;
+}
+
+static size_t
+elf_link_sort_relocs (abfd, info, psec)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     asection **psec;
+{
+  bfd *dynobj = elf_hash_table (info)->dynobj;
+  asection *reldyn, *o;
+  boolean rel = false;
+  bfd_size_type count, size;
+  size_t i, j, ret;
+  struct elf_link_sort_rela *rela;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+
+  reldyn = bfd_get_section_by_name (abfd, ".rela.dyn");
+  if (reldyn == NULL || reldyn->_raw_size == 0)
+    {
+      reldyn = bfd_get_section_by_name (abfd, ".rel.dyn");
+      if (reldyn == NULL || reldyn->_raw_size == 0)
+	return 0;
+      rel = true;
+      count = reldyn->_raw_size / sizeof (Elf_External_Rel);
+    }
+  else
+    count = reldyn->_raw_size / sizeof (Elf_External_Rela);
+
+  size = 0;
+  for (o = dynobj->sections; o != NULL; o = o->next)
+    if ((o->flags & (SEC_HAS_CONTENTS|SEC_LINKER_CREATED))
+	== (SEC_HAS_CONTENTS|SEC_LINKER_CREATED)
+	&& o->output_section == reldyn)
+      size += o->_raw_size;
+
+  if (size != reldyn->_raw_size)
+    return 0;
+
+  rela = (struct elf_link_sort_rela *) bfd_zmalloc (sizeof (*rela) * count);
+  if (rela == NULL)
+    {
+      (*info->callbacks->warning)
+	(info, _("Not enough memory to sort relocations"), 0, abfd, 0,
+	 (bfd_vma) 0);
+      return 0;
+    }
+
+  for (o = dynobj->sections; o != NULL; o = o->next)
+    if ((o->flags & (SEC_HAS_CONTENTS|SEC_LINKER_CREATED))
+	== (SEC_HAS_CONTENTS|SEC_LINKER_CREATED)
+	&& o->output_section == reldyn)
+      {
+	if (rel)
+	  {
+	    Elf_External_Rel *erel, *erelend;
+	    struct elf_link_sort_rela *s;
+
+	    erel = (Elf_External_Rel *) o->contents;
+	    erelend = (Elf_External_Rel *) (o->contents + o->_raw_size);
+	    s = rela + o->output_offset / sizeof (Elf_External_Rel);
+	    for (; erel < erelend; erel++, s++)
+	      {
+		if (bed->s->swap_reloc_in)
+		  (*bed->s->swap_reloc_in) (abfd, (bfd_byte *) erel, &s->u.rel);
+		else
+		  elf_swap_reloc_in (abfd, erel, &s->u.rel);
+
+		s->type = (*bed->elf_backend_reloc_type_class) (&s->u.rela);
+	      }
+	  }
+	else
+	  {
+	    Elf_External_Rela *erela, *erelaend;
+	    struct elf_link_sort_rela *s;
+
+	    erela = (Elf_External_Rela *) o->contents;
+	    erelaend = (Elf_External_Rela *) (o->contents + o->_raw_size);
+	    s = rela + o->output_offset / sizeof (Elf_External_Rela);
+	    for (; erela < erelaend; erela++, s++)
+	      {
+		if (bed->s->swap_reloca_in)
+		  (*bed->s->swap_reloca_in) (dynobj, (bfd_byte *) erela,
+					     &s->u.rela);
+		else
+		  elf_swap_reloca_in (dynobj, erela, &s->u.rela);
+
+		s->type = (*bed->elf_backend_reloc_type_class) (&s->u.rela);
+	      }
+	  }
+      }
+
+  qsort (rela, (size_t) count, sizeof (*rela), elf_link_sort_cmp1);
+  for (ret = 0; ret < count && rela[ret].type == reloc_class_relative; ret++)
+    ;
+  for (i = ret, j = ret; i < count; i++)
+    {
+      if (ELF_R_SYM (rela[i].u.rel.r_info) != ELF_R_SYM (rela[j].u.rel.r_info))
+	j = i;
+      rela[i].offset = rela[j].u.rel.r_offset;
+    }
+  qsort (rela + ret, (size_t) count - ret, sizeof (*rela), elf_link_sort_cmp2);
+
+  for (o = dynobj->sections; o != NULL; o = o->next)
+    if ((o->flags & (SEC_HAS_CONTENTS|SEC_LINKER_CREATED))
+	== (SEC_HAS_CONTENTS|SEC_LINKER_CREATED)
+	&& o->output_section == reldyn)
+      {
+	if (rel)
+	  {
+	    Elf_External_Rel *erel, *erelend;
+	    struct elf_link_sort_rela *s;
+
+	    erel = (Elf_External_Rel *) o->contents;
+	    erelend = (Elf_External_Rel *) (o->contents + o->_raw_size);
+	    s = rela + o->output_offset / sizeof (Elf_External_Rel);
+	    for (; erel < erelend; erel++, s++)
+	      {
+		if (bed->s->swap_reloc_out)
+		  (*bed->s->swap_reloc_out) (abfd, &s->u.rel,
+					     (bfd_byte *) erel);
+		else
+		  elf_swap_reloc_out (abfd, &s->u.rel, erel);
+	      }
+	  }
+	else
+	  {
+	    Elf_External_Rela *erela, *erelaend;
+	    struct elf_link_sort_rela *s;
+
+	    erela = (Elf_External_Rela *) o->contents;
+	    erelaend = (Elf_External_Rela *) (o->contents + o->_raw_size);
+	    s = rela + o->output_offset / sizeof (Elf_External_Rela);
+	    for (; erela < erelaend; erela++, s++)
+	      {
+		if (bed->s->swap_reloca_out)
+		  (*bed->s->swap_reloca_out) (dynobj, &s->u.rela,
+					      (bfd_byte *) erela);
+		else
+		  elf_swap_reloca_out (dynobj, &s->u.rela, erela);
+	      }
+	  }
+      }
+
+  free (rela);
+  *psec = reldyn;
+  return ret;
+}
+
+/* Do the final step of an ELF link.  */
+
+boolean
+elf_bfd_final_link (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  boolean dynamic;
+  boolean emit_relocs;
+  bfd *dynobj;
+  struct elf_final_link_info finfo;
+  register asection *o;
+  register struct bfd_link_order *p;
+  register bfd *sub;
+  bfd_size_type max_contents_size;
+  bfd_size_type max_external_reloc_size;
+  bfd_size_type max_internal_reloc_count;
+  bfd_size_type max_sym_count;
+  bfd_size_type max_sym_shndx_count;
+  file_ptr off;
+  Elf_Internal_Sym elfsym;
+  unsigned int i;
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Shdr *symstrtab_hdr;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  struct elf_outext_info eoinfo;
+  boolean merged;
+  size_t relativecount = 0;
+  asection *reldyn = 0;
+  bfd_size_type amt;
+
+  if (! is_elf_hash_table (info))
+    return false;
+
+  if (info->shared)
+    abfd->flags |= DYNAMIC;
+
+  dynamic = elf_hash_table (info)->dynamic_sections_created;
+  dynobj = elf_hash_table (info)->dynobj;
+
+  emit_relocs = (info->relocateable
+		 || info->emitrelocations
+		 || bed->elf_backend_emit_relocs);
+
+  finfo.info = info;
+  finfo.output_bfd = abfd;
+  finfo.symstrtab = elf_stringtab_init ();
+  if (finfo.symstrtab == NULL)
+    return false;
+
+  if (! dynamic)
+    {
+      finfo.dynsym_sec = NULL;
+      finfo.hash_sec = NULL;
+      finfo.symver_sec = NULL;
+    }
+  else
+    {
+      finfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
+      finfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
+      BFD_ASSERT (finfo.dynsym_sec != NULL && finfo.hash_sec != NULL);
+      finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
+      /* Note that it is OK if symver_sec is NULL.  */
+    }
+
+  finfo.contents = NULL;
+  finfo.external_relocs = NULL;
+  finfo.internal_relocs = NULL;
+  finfo.external_syms = NULL;
+  finfo.locsym_shndx = NULL;
+  finfo.internal_syms = NULL;
+  finfo.indices = NULL;
+  finfo.sections = NULL;
+  finfo.symbuf = NULL;
+  finfo.symshndxbuf = NULL;
+  finfo.symbuf_count = 0;
+  finfo.first_tls_sec = NULL;
+  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
+    if ((o->flags & SEC_THREAD_LOCAL) != 0
+	&& (o->flags & SEC_LOAD) != 0)
+      {
+	finfo.first_tls_sec = o;
+	break;
+      }
+
+  /* Count up the number of relocations we will output for each output
+     section, so that we know the sizes of the reloc sections.  We
+     also figure out some maximum sizes.  */
+  max_contents_size = 0;
+  max_external_reloc_size = 0;
+  max_internal_reloc_count = 0;
+  max_sym_count = 0;
+  max_sym_shndx_count = 0;
+  merged = false;
+  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
+    {
+      o->reloc_count = 0;
+
+      for (p = o->link_order_head; p != NULL; p = p->next)
+	{
+	  if (p->type == bfd_section_reloc_link_order
+	      || p->type == bfd_symbol_reloc_link_order)
+	    ++o->reloc_count;
+	  else if (p->type == bfd_indirect_link_order)
+	    {
+	      asection *sec;
+
+	      sec = p->u.indirect.section;
+
+	      /* Mark all sections which are to be included in the
+		 link.  This will normally be every section.  We need
+		 to do this so that we can identify any sections which
+		 the linker has decided to not include.  */
+	      sec->linker_mark = true;
+
+	      if (sec->flags & SEC_MERGE)
+		merged = true;
+
+	      if (info->relocateable || info->emitrelocations)
+		o->reloc_count += sec->reloc_count;
+	      else if (bed->elf_backend_count_relocs)
+		{
+		  Elf_Internal_Rela * relocs;
+
+		  relocs = (NAME(_bfd_elf,link_read_relocs)
+			    (abfd, sec, (PTR) NULL,
+			     (Elf_Internal_Rela *) NULL, info->keep_memory));
+
+		  o->reloc_count
+		    += (*bed->elf_backend_count_relocs) (sec, relocs);
+
+		  if (elf_section_data (o)->relocs != relocs)
+		    free (relocs);
+		}
+
+	      if (sec->_raw_size > max_contents_size)
+		max_contents_size = sec->_raw_size;
+	      if (sec->_cooked_size > max_contents_size)
+		max_contents_size = sec->_cooked_size;
+
+	      /* We are interested in just local symbols, not all
+		 symbols.  */
+	      if (bfd_get_flavour (sec->owner) == bfd_target_elf_flavour
+		  && (sec->owner->flags & DYNAMIC) == 0)
+		{
+		  size_t sym_count;
+
+		  if (elf_bad_symtab (sec->owner))
+		    sym_count = (elf_tdata (sec->owner)->symtab_hdr.sh_size
+				 / sizeof (Elf_External_Sym));
+		  else
+		    sym_count = elf_tdata (sec->owner)->symtab_hdr.sh_info;
+
+		  if (sym_count > max_sym_count)
+		    max_sym_count = sym_count;
+
+		  if (sym_count > max_sym_shndx_count
+		      && elf_symtab_shndx (sec->owner) != 0)
+		    max_sym_shndx_count = sym_count;
+
+		  if ((sec->flags & SEC_RELOC) != 0)
+		    {
+		      size_t ext_size;
+
+		      ext_size = elf_section_data (sec)->rel_hdr.sh_size;
+		      if (ext_size > max_external_reloc_size)
+			max_external_reloc_size = ext_size;
+		      if (sec->reloc_count > max_internal_reloc_count)
+			max_internal_reloc_count = sec->reloc_count;
+		    }
+		}
+	    }
+	}
+
+      if (o->reloc_count > 0)
+	o->flags |= SEC_RELOC;
+      else
+	{
+	  /* Explicitly clear the SEC_RELOC flag.  The linker tends to
+	     set it (this is probably a bug) and if it is set
+	     assign_section_numbers will create a reloc section.  */
+	  o->flags &=~ SEC_RELOC;
+	}
+
+      /* If the SEC_ALLOC flag is not set, force the section VMA to
+	 zero.  This is done in elf_fake_sections as well, but forcing
+	 the VMA to 0 here will ensure that relocs against these
+	 sections are handled correctly.  */
+      if ((o->flags & SEC_ALLOC) == 0
+	  && ! o->user_set_vma)
+	o->vma = 0;
+    }
+
+  if (! info->relocateable && merged)
+    elf_link_hash_traverse (elf_hash_table (info),
+			    elf_link_sec_merge_syms, (PTR) abfd);
+
+  /* Figure out the file positions for everything but the symbol table
+     and the relocs.  We set symcount to force assign_section_numbers
+     to create a symbol table.  */
+  bfd_get_symcount (abfd) = info->strip == strip_all ? 0 : 1;
+  BFD_ASSERT (! abfd->output_has_begun);
+  if (! _bfd_elf_compute_section_file_positions (abfd, info))
+    goto error_return;
+
+  /* Figure out how many relocations we will have in each section.
+     Just using RELOC_COUNT isn't good enough since that doesn't
+     maintain a separate value for REL vs. RELA relocations.  */
+  if (emit_relocs)
+    for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+      for (o = sub->sections; o != NULL; o = o->next)
+	{
+	  asection *output_section;
+
+	  if (! o->linker_mark)
+	    {
+	      /* This section was omitted from the link.  */
+	      continue;
+	    }
+
+	  output_section = o->output_section;
+
+	  if (output_section != NULL
+	      && (o->flags & SEC_RELOC) != 0)
+	    {
+	      struct bfd_elf_section_data *esdi
+		= elf_section_data (o);
+	      struct bfd_elf_section_data *esdo
+		= elf_section_data (output_section);
+	      unsigned int *rel_count;
+	      unsigned int *rel_count2;
+	      bfd_size_type entsize;
+	      bfd_size_type entsize2;
+
+	      /* We must be careful to add the relocations from the
+		 input section to the right output count.  */
+	      entsize = esdi->rel_hdr.sh_entsize;
+	      entsize2 = esdi->rel_hdr2 ? esdi->rel_hdr2->sh_entsize : 0;
+	      BFD_ASSERT ((entsize == sizeof (Elf_External_Rel)
+			   || entsize == sizeof (Elf_External_Rela))
+			  && entsize2 != entsize
+			  && (entsize2 == 0
+			      || entsize2 == sizeof (Elf_External_Rel)
+			      || entsize2 == sizeof (Elf_External_Rela)));
+	      if (entsize == esdo->rel_hdr.sh_entsize)
+		{
+		  rel_count = &esdo->rel_count;
+		  rel_count2 = &esdo->rel_count2;
+		}
+	      else
+		{
+		  rel_count = &esdo->rel_count2;
+		  rel_count2 = &esdo->rel_count;
+		}
+
+	      *rel_count += NUM_SHDR_ENTRIES (& esdi->rel_hdr);
+	      if (esdi->rel_hdr2)
+		*rel_count2 += NUM_SHDR_ENTRIES (esdi->rel_hdr2);
+	      output_section->flags |= SEC_RELOC;
+	    }
+	}
+
+  /* That created the reloc sections.  Set their sizes, and assign
+     them file positions, and allocate some buffers.  */
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if ((o->flags & SEC_RELOC) != 0)
+	{
+	  if (!elf_link_size_reloc_section (abfd,
+					    &elf_section_data (o)->rel_hdr,
+					    o))
+	    goto error_return;
+
+	  if (elf_section_data (o)->rel_hdr2
+	      && !elf_link_size_reloc_section (abfd,
+					       elf_section_data (o)->rel_hdr2,
+					       o))
+	    goto error_return;
+	}
+
+      /* Now, reset REL_COUNT and REL_COUNT2 so that we can use them
+	 to count upwards while actually outputting the relocations.  */
+      elf_section_data (o)->rel_count = 0;
+      elf_section_data (o)->rel_count2 = 0;
+    }
+
+  _bfd_elf_assign_file_positions_for_relocs (abfd);
+
+  /* We have now assigned file positions for all the sections except
+     .symtab and .strtab.  We start the .symtab section at the current
+     file position, and write directly to it.  We build the .strtab
+     section in memory.  */
+  bfd_get_symcount (abfd) = 0;
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  /* sh_name is set in prep_headers.  */
+  symtab_hdr->sh_type = SHT_SYMTAB;
+  symtab_hdr->sh_flags = 0;
+  symtab_hdr->sh_addr = 0;
+  symtab_hdr->sh_size = 0;
+  symtab_hdr->sh_entsize = sizeof (Elf_External_Sym);
+  /* sh_link is set in assign_section_numbers.  */
+  /* sh_info is set below.  */
+  /* sh_offset is set just below.  */
+  symtab_hdr->sh_addralign = bed->s->file_align;
+
+  off = elf_tdata (abfd)->next_file_pos;
+  off = _bfd_elf_assign_file_position_for_section (symtab_hdr, off, true);
+
+  /* Note that at this point elf_tdata (abfd)->next_file_pos is
+     incorrect.  We do not yet know the size of the .symtab section.
+     We correct next_file_pos below, after we do know the size.  */
+
+  /* Allocate a buffer to hold swapped out symbols.  This is to avoid
+     continuously seeking to the right position in the file.  */
+  if (! info->keep_memory || max_sym_count < 20)
+    finfo.symbuf_size = 20;
+  else
+    finfo.symbuf_size = max_sym_count;
+  amt = finfo.symbuf_size;
+  amt *= sizeof (Elf_External_Sym);
+  finfo.symbuf = (Elf_External_Sym *) bfd_malloc (amt);
+  if (finfo.symbuf == NULL)
+    goto error_return;
+  if (elf_numsections (abfd) > SHN_LORESERVE)
+    {
+      amt = finfo.symbuf_size;
+      amt *= sizeof (Elf_External_Sym_Shndx);
+      finfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
+      if (finfo.symshndxbuf == NULL)
+	goto error_return;
+    }
+
+  /* Start writing out the symbol table.  The first symbol is always a
+     dummy symbol.  */
+  if (info->strip != strip_all
+      || emit_relocs)
+    {
+      elfsym.st_value = 0;
+      elfsym.st_size = 0;
+      elfsym.st_info = 0;
+      elfsym.st_other = 0;
+      elfsym.st_shndx = SHN_UNDEF;
+      if (! elf_link_output_sym (&finfo, (const char *) NULL,
+				 &elfsym, bfd_und_section_ptr))
+	goto error_return;
+    }
+
+#if 0
+  /* Some standard ELF linkers do this, but we don't because it causes
+     bootstrap comparison failures.  */
+  /* Output a file symbol for the output file as the second symbol.
+     We output this even if we are discarding local symbols, although
+     I'm not sure if this is correct.  */
+  elfsym.st_value = 0;
+  elfsym.st_size = 0;
+  elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
+  elfsym.st_other = 0;
+  elfsym.st_shndx = SHN_ABS;
+  if (! elf_link_output_sym (&finfo, bfd_get_filename (abfd),
+			     &elfsym, bfd_abs_section_ptr))
+    goto error_return;
+#endif
+
+  /* Output a symbol for each section.  We output these even if we are
+     discarding local symbols, since they are used for relocs.  These
+     symbols have no names.  We store the index of each one in the
+     index field of the section, so that we can find it again when
+     outputting relocs.  */
+  if (info->strip != strip_all
+      || emit_relocs)
+    {
+      elfsym.st_size = 0;
+      elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
+      elfsym.st_other = 0;
+      for (i = 1; i < elf_numsections (abfd); i++)
+	{
+	  o = section_from_elf_index (abfd, i);
+	  if (o != NULL)
+	    o->target_index = bfd_get_symcount (abfd);
+	  elfsym.st_shndx = i;
+	  if (info->relocateable || o == NULL)
+	    elfsym.st_value = 0;
+	  else
+	    elfsym.st_value = o->vma;
+	  if (! elf_link_output_sym (&finfo, (const char *) NULL,
+				     &elfsym, o))
+	    goto error_return;
+	  if (i == SHN_LORESERVE)
+	    i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
+	}
+    }
+
+  /* Allocate some memory to hold information read in from the input
+     files.  */
+  if (max_contents_size != 0)
+    {
+      finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
+      if (finfo.contents == NULL)
+	goto error_return;
+    }
+
+  if (max_external_reloc_size != 0)
+    {
+      finfo.external_relocs = (PTR) bfd_malloc (max_external_reloc_size);
+      if (finfo.external_relocs == NULL)
+	goto error_return;
+    }
+
+  if (max_internal_reloc_count != 0)
+    {
+      amt = max_internal_reloc_count * bed->s->int_rels_per_ext_rel;
+      amt *= sizeof (Elf_Internal_Rela);
+      finfo.internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
+      if (finfo.internal_relocs == NULL)
+	goto error_return;
+    }
+
+  if (max_sym_count != 0)
+    {
+      amt = max_sym_count * sizeof (Elf_External_Sym);
+      finfo.external_syms = (Elf_External_Sym *) bfd_malloc (amt);
+      if (finfo.external_syms == NULL)
+	goto error_return;
+
+      amt = max_sym_count * sizeof (Elf_Internal_Sym);
+      finfo.internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
+      if (finfo.internal_syms == NULL)
+	goto error_return;
+
+      amt = max_sym_count * sizeof (long);
+      finfo.indices = (long *) bfd_malloc (amt);
+      if (finfo.indices == NULL)
+	goto error_return;
+
+      amt = max_sym_count * sizeof (asection *);
+      finfo.sections = (asection **) bfd_malloc (amt);
+      if (finfo.sections == NULL)
+	goto error_return;
+    }
+
+  if (max_sym_shndx_count != 0)
+    {
+      amt = max_sym_shndx_count * sizeof (Elf_External_Sym_Shndx);
+      finfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
+      if (finfo.locsym_shndx == NULL)
+	goto error_return;
+    }
+
+  if (finfo.first_tls_sec)
+    {
+      unsigned int align = 0;
+      bfd_vma base = finfo.first_tls_sec->vma, end = 0;
+      asection *sec;
+
+      for (sec = finfo.first_tls_sec;
+	   sec && (sec->flags & SEC_THREAD_LOCAL);
+	   sec = sec->next)
+	{
+	  bfd_vma size = sec->_raw_size;
+
+	  if (bfd_get_section_alignment (abfd, sec) > align)
+	    align = bfd_get_section_alignment (abfd, sec);
+	  if (sec->_raw_size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
+	    {
+	      struct bfd_link_order *o;
+
+	      size = 0;
+	      for (o = sec->link_order_head; o != NULL; o = o->next)
+		if (size < o->offset + o->size)
+		  size = o->offset + o->size;
+	    }
+	  end = sec->vma + size;
+	}
+      elf_hash_table (info)->tls_segment
+	= bfd_zalloc (abfd, sizeof (struct elf_link_tls_segment));
+      if (elf_hash_table (info)->tls_segment == NULL)
+	goto error_return;
+      elf_hash_table (info)->tls_segment->start = base;
+      elf_hash_table (info)->tls_segment->size = end - base;
+      elf_hash_table (info)->tls_segment->align = align;
+    }
+
+  /* Since ELF permits relocations to be against local symbols, we
+     must have the local symbols available when we do the relocations.
+     Since we would rather only read the local symbols once, and we
+     would rather not keep them in memory, we handle all the
+     relocations for a single input file at the same time.
+
+     Unfortunately, there is no way to know the total number of local
+     symbols until we have seen all of them, and the local symbol
+     indices precede the global symbol indices.  This means that when
+     we are generating relocateable output, and we see a reloc against
+     a global symbol, we can not know the symbol index until we have
+     finished examining all the local symbols to see which ones we are
+     going to output.  To deal with this, we keep the relocations in
+     memory, and don't output them until the end of the link.  This is
+     an unfortunate waste of memory, but I don't see a good way around
+     it.  Fortunately, it only happens when performing a relocateable
+     link, which is not the common case.  FIXME: If keep_memory is set
+     we could write the relocs out and then read them again; I don't
+     know how bad the memory loss will be.  */
+
+  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+    sub->output_has_begun = false;
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      for (p = o->link_order_head; p != NULL; p = p->next)
+	{
+	  if (p->type == bfd_indirect_link_order
+	      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
+		  == bfd_target_elf_flavour)
+	      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)
+	    {
+	      if (! sub->output_has_begun)
+		{
+		  if (! elf_link_input_bfd (&finfo, sub))
+		    goto error_return;
+		  sub->output_has_begun = true;
+		}
+	    }
+	  else if (p->type == bfd_section_reloc_link_order
+		   || p->type == bfd_symbol_reloc_link_order)
+	    {
+	      if (! elf_reloc_link_order (abfd, info, o, p))
+		goto error_return;
+	    }
+	  else
+	    {
+	      if (! _bfd_default_link_order (abfd, info, o, p))
+		goto error_return;
+	    }
+	}
+    }
+
+  /* Output any global symbols that got converted to local in a
+     version script or due to symbol visibility.  We do this in a
+     separate step since ELF requires all local symbols to appear
+     prior to any global symbols.  FIXME: We should only do this if
+     some global symbols were, in fact, converted to become local.
+     FIXME: Will this work correctly with the Irix 5 linker?  */
+  eoinfo.failed = false;
+  eoinfo.finfo = &finfo;
+  eoinfo.localsyms = true;
+  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
+			  (PTR) &eoinfo);
+  if (eoinfo.failed)
+    return false;
+
+  /* That wrote out all the local symbols.  Finish up the symbol table
+     with the global symbols. Even if we want to strip everything we
+     can, we still need to deal with those global symbols that got
+     converted to local in a version script.  */
+
+  /* The sh_info field records the index of the first non local symbol.  */
+  symtab_hdr->sh_info = bfd_get_symcount (abfd);
+
+  if (dynamic
+      && finfo.dynsym_sec->output_section != bfd_abs_section_ptr)
+    {
+      Elf_Internal_Sym sym;
+      Elf_External_Sym *dynsym =
+	(Elf_External_Sym *) finfo.dynsym_sec->contents;
+      long last_local = 0;
+
+      /* Write out the section symbols for the output sections.  */
+      if (info->shared)
+	{
+	  asection *s;
+
+	  sym.st_size = 0;
+	  sym.st_name = 0;
+	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
+	  sym.st_other = 0;
+
+	  for (s = abfd->sections; s != NULL; s = s->next)
+	    {
+	      int indx;
+	      Elf_External_Sym *dest;
+
+	      indx = elf_section_data (s)->this_idx;
+	      BFD_ASSERT (indx > 0);
+	      sym.st_shndx = indx;
+	      sym.st_value = s->vma;
+	      dest = dynsym + elf_section_data (s)->dynindx;
+	      elf_swap_symbol_out (abfd, &sym, (PTR) dest, (PTR) 0);
+	    }
+
+	  last_local = bfd_count_sections (abfd);
+	}
+
+      /* Write out the local dynsyms.  */
+      if (elf_hash_table (info)->dynlocal)
+	{
+	  struct elf_link_local_dynamic_entry *e;
+	  for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
+	    {
+	      asection *s;
+	      Elf_External_Sym *dest;
+
+	      sym.st_size = e->isym.st_size;
+	      sym.st_other = e->isym.st_other;
+
+	      /* Copy the internal symbol as is.
+		 Note that we saved a word of storage and overwrote
+		 the original st_name with the dynstr_index.  */
+	      sym = e->isym;
+
+	      if (e->isym.st_shndx != SHN_UNDEF
+		  && (e->isym.st_shndx < SHN_LORESERVE
+		      || e->isym.st_shndx > SHN_HIRESERVE))
+		{
+		  s = bfd_section_from_elf_index (e->input_bfd,
+						  e->isym.st_shndx);
+
+		  sym.st_shndx =
+		    elf_section_data (s->output_section)->this_idx;
+		  sym.st_value = (s->output_section->vma
+				  + s->output_offset
+				  + e->isym.st_value);
+		}
+
+	      if (last_local < e->dynindx)
+		last_local = e->dynindx;
+
+	      dest = dynsym + e->dynindx;
+	      elf_swap_symbol_out (abfd, &sym, (PTR) dest, (PTR) 0);
+	    }
+	}
+
+      elf_section_data (finfo.dynsym_sec->output_section)->this_hdr.sh_info =
+	last_local + 1;
+    }
+
+  /* We get the global symbols from the hash table.  */
+  eoinfo.failed = false;
+  eoinfo.localsyms = false;
+  eoinfo.finfo = &finfo;
+  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
+			  (PTR) &eoinfo);
+  if (eoinfo.failed)
+    return false;
+
+  /* If backend needs to output some symbols not present in the hash
+     table, do it now.  */
+  if (bed->elf_backend_output_arch_syms)
+    {
+      typedef boolean (*out_sym_func) PARAMS ((PTR, const char *,
+					       Elf_Internal_Sym *,
+					       asection *));
+
+      if (! ((*bed->elf_backend_output_arch_syms)
+	     (abfd, info, (PTR) &finfo, (out_sym_func) elf_link_output_sym)))
+	return false;
+    }
+
+  /* Flush all symbols to the file.  */
+  if (! elf_link_flush_output_syms (&finfo))
+    return false;
+
+  /* Now we know the size of the symtab section.  */
+  off += symtab_hdr->sh_size;
+
+  /* Finish up and write out the symbol string table (.strtab)
+     section.  */
+  symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
+  /* sh_name was set in prep_headers.  */
+  symstrtab_hdr->sh_type = SHT_STRTAB;
+  symstrtab_hdr->sh_flags = 0;
+  symstrtab_hdr->sh_addr = 0;
+  symstrtab_hdr->sh_size = _bfd_stringtab_size (finfo.symstrtab);
+  symstrtab_hdr->sh_entsize = 0;
+  symstrtab_hdr->sh_link = 0;
+  symstrtab_hdr->sh_info = 0;
+  /* sh_offset is set just below.  */
+  symstrtab_hdr->sh_addralign = 1;
+
+  off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr, off, true);
+  elf_tdata (abfd)->next_file_pos = off;
+
+  if (bfd_get_symcount (abfd) > 0)
+    {
+      if (bfd_seek (abfd, symstrtab_hdr->sh_offset, SEEK_SET) != 0
+	  || ! _bfd_stringtab_emit (abfd, finfo.symstrtab))
+	return false;
+    }
+
+  /* Adjust the relocs to have the correct symbol indices.  */
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if ((o->flags & SEC_RELOC) == 0)
+	continue;
+
+      elf_link_adjust_relocs (abfd, &elf_section_data (o)->rel_hdr,
+			      elf_section_data (o)->rel_count,
+			      elf_section_data (o)->rel_hashes);
+      if (elf_section_data (o)->rel_hdr2 != NULL)
+	elf_link_adjust_relocs (abfd, elf_section_data (o)->rel_hdr2,
+				elf_section_data (o)->rel_count2,
+				(elf_section_data (o)->rel_hashes
+				 + elf_section_data (o)->rel_count));
+
+      /* Set the reloc_count field to 0 to prevent write_relocs from
+	 trying to swap the relocs out itself.  */
+      o->reloc_count = 0;
+    }
+
+  if (dynamic && info->combreloc && dynobj != NULL)
+    relativecount = elf_link_sort_relocs (abfd, info, &reldyn);
+
+  /* If we are linking against a dynamic object, or generating a
+     shared library, finish up the dynamic linking information.  */
+  if (dynamic)
+    {
+      Elf_External_Dyn *dyncon, *dynconend;
+
+      /* Fix up .dynamic entries.  */
+      o = bfd_get_section_by_name (dynobj, ".dynamic");
+      BFD_ASSERT (o != NULL);
+
+      dyncon = (Elf_External_Dyn *) o->contents;
+      dynconend = (Elf_External_Dyn *) (o->contents + o->_raw_size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+	  const char *name;
+	  unsigned int type;
+
+	  elf_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      break;
+	    case DT_NULL:
+	      if (relativecount > 0 && dyncon + 1 < dynconend)
+		{
+		  switch (elf_section_data (reldyn)->this_hdr.sh_type)
+		    {
+		    case SHT_REL: dyn.d_tag = DT_RELCOUNT; break;
+		    case SHT_RELA: dyn.d_tag = DT_RELACOUNT; break;
+		    default: break;
+		    }
+		  if (dyn.d_tag != DT_NULL)
+		    {
+		      dyn.d_un.d_val = relativecount;
+		      elf_swap_dyn_out (dynobj, &dyn, dyncon);
+		      relativecount = 0;
+		    }
+		}
+	      break;
+	    case DT_INIT:
+	      name = info->init_function;
+	      goto get_sym;
+	    case DT_FINI:
+	      name = info->fini_function;
+	    get_sym:
+	      {
+		struct elf_link_hash_entry *h;
+
+		h = elf_link_hash_lookup (elf_hash_table (info), name,
+					  false, false, true);
+		if (h != NULL
+		    && (h->root.type == bfd_link_hash_defined
+			|| h->root.type == bfd_link_hash_defweak))
+		  {
+		    dyn.d_un.d_val = h->root.u.def.value;
+		    o = h->root.u.def.section;
+		    if (o->output_section != NULL)
+		      dyn.d_un.d_val += (o->output_section->vma
+					 + o->output_offset);
+		    else
+		      {
+			/* The symbol is imported from another shared
+			   library and does not apply to this one.  */
+			dyn.d_un.d_val = 0;
+		      }
+
+		    elf_swap_dyn_out (dynobj, &dyn, dyncon);
+		  }
+	      }
+	      break;
+
+	    case DT_PREINIT_ARRAYSZ:
+	      name = ".preinit_array";
+	      goto get_size;
+	    case DT_INIT_ARRAYSZ:
+	      name = ".init_array";
+	      goto get_size;
+	    case DT_FINI_ARRAYSZ:
+	      name = ".fini_array";
+	    get_size:
+	      o = bfd_get_section_by_name (abfd, name);
+	      if (o == NULL)
+		{
+		  (*_bfd_error_handler)
+		    (_("%s: could not find output section %s"),
+		     bfd_get_filename (abfd), name);
+		  goto error_return;
+		}
+	      if (o->_raw_size == 0)
+		(*_bfd_error_handler)
+		  (_("warning: %s section has zero size"), name);
+	      dyn.d_un.d_val = o->_raw_size;
+	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_PREINIT_ARRAY:
+	      name = ".preinit_array";
+	      goto get_vma;
+	    case DT_INIT_ARRAY:
+	      name = ".init_array";
+	      goto get_vma;
+	    case DT_FINI_ARRAY:
+	      name = ".fini_array";
+	      goto get_vma;
+
+	    case DT_HASH:
+	      name = ".hash";
+	      goto get_vma;
+	    case DT_STRTAB:
+	      name = ".dynstr";
+	      goto get_vma;
+	    case DT_SYMTAB:
+	      name = ".dynsym";
+	      goto get_vma;
+	    case DT_VERDEF:
+	      name = ".gnu.version_d";
+	      goto get_vma;
+	    case DT_VERNEED:
+	      name = ".gnu.version_r";
+	      goto get_vma;
+	    case DT_VERSYM:
+	      name = ".gnu.version";
+	    get_vma:
+	      o = bfd_get_section_by_name (abfd, name);
+	      if (o == NULL)
+		{
+		  (*_bfd_error_handler)
+		    (_("%s: could not find output section %s"),
+		     bfd_get_filename (abfd), name);
+		  goto error_return;
+		}
+	      dyn.d_un.d_ptr = o->vma;
+	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_REL:
+	    case DT_RELA:
+	    case DT_RELSZ:
+	    case DT_RELASZ:
+	      if (dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)
+		type = SHT_REL;
+	      else
+		type = SHT_RELA;
+	      dyn.d_un.d_val = 0;
+	      for (i = 1; i < elf_numsections (abfd); i++)
+		{
+		  Elf_Internal_Shdr *hdr;
+
+		  hdr = elf_elfsections (abfd)[i];
+		  if (hdr->sh_type == type
+		      && (hdr->sh_flags & SHF_ALLOC) != 0)
+		    {
+		      if (dyn.d_tag == DT_RELSZ || dyn.d_tag == DT_RELASZ)
+			dyn.d_un.d_val += hdr->sh_size;
+		      else
+			{
+			  if (dyn.d_un.d_val == 0
+			      || hdr->sh_addr < dyn.d_un.d_val)
+			    dyn.d_un.d_val = hdr->sh_addr;
+			}
+		    }
+		}
+	      elf_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+	    }
+	}
+    }
+
+  /* If we have created any dynamic sections, then output them.  */
+  if (dynobj != NULL)
+    {
+      if (! (*bed->elf_backend_finish_dynamic_sections) (abfd, info))
+	goto error_return;
+
+      for (o = dynobj->sections; o != NULL; o = o->next)
+	{
+	  if ((o->flags & SEC_HAS_CONTENTS) == 0
+	      || o->_raw_size == 0
+	      || o->output_section == bfd_abs_section_ptr)
+	    continue;
+	  if ((o->flags & SEC_LINKER_CREATED) == 0)
+	    {
+	      /* At this point, we are only interested in sections
+		 created by elf_link_create_dynamic_sections.  */
+	      continue;
+	    }
+	  if ((elf_section_data (o->output_section)->this_hdr.sh_type
+	       != SHT_STRTAB)
+	      || strcmp (bfd_get_section_name (abfd, o), ".dynstr") != 0)
+	    {
+	      if (! bfd_set_section_contents (abfd, o->output_section,
+					      o->contents,
+					      (file_ptr) o->output_offset,
+					      o->_raw_size))
+		goto error_return;
+	    }
+	  else
+	    {
+	      /* The contents of the .dynstr section are actually in a
+		 stringtab.  */
+	      off = elf_section_data (o->output_section)->this_hdr.sh_offset;
+	      if (bfd_seek (abfd, off, SEEK_SET) != 0
+		  || ! _bfd_elf_strtab_emit (abfd,
+					     elf_hash_table (info)->dynstr))
+		goto error_return;
+	    }
+	}
+    }
+
+  if (info->relocateable)
+    {
+      boolean failed = false;
+
+      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
+      if (failed)
+	goto error_return;
+    }
+
+  /* If we have optimized stabs strings, output them.  */
+  if (elf_hash_table (info)->stab_info != NULL)
+    {
+      if (! _bfd_write_stab_strings (abfd, &elf_hash_table (info)->stab_info))
+	goto error_return;
+    }
+
+  if (info->eh_frame_hdr && elf_hash_table (info)->dynobj)
+    {
+      o = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
+				   ".eh_frame_hdr");
+      if (o
+	  && (elf_section_data (o)->sec_info_type
+	      == ELF_INFO_TYPE_EH_FRAME_HDR))
+	{
+	  if (! _bfd_elf_write_section_eh_frame_hdr (abfd, o))
+	    goto error_return;
+	}
+    }
+
+  if (finfo.symstrtab != NULL)
+    _bfd_stringtab_free (finfo.symstrtab);
+  if (finfo.contents != NULL)
+    free (finfo.contents);
+  if (finfo.external_relocs != NULL)
+    free (finfo.external_relocs);
+  if (finfo.internal_relocs != NULL)
+    free (finfo.internal_relocs);
+  if (finfo.external_syms != NULL)
+    free (finfo.external_syms);
+  if (finfo.locsym_shndx != NULL)
+    free (finfo.locsym_shndx);
+  if (finfo.internal_syms != NULL)
+    free (finfo.internal_syms);
+  if (finfo.indices != NULL)
+    free (finfo.indices);
+  if (finfo.sections != NULL)
+    free (finfo.sections);
+  if (finfo.symbuf != NULL)
+    free (finfo.symbuf);
+  if (finfo.symshndxbuf != NULL)
+    free (finfo.symbuf);
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if ((o->flags & SEC_RELOC) != 0
+	  && elf_section_data (o)->rel_hashes != NULL)
+	free (elf_section_data (o)->rel_hashes);
+    }
+
+  elf_tdata (abfd)->linker = true;
+
+  return true;
+
+ error_return:
+  if (finfo.symstrtab != NULL)
+    _bfd_stringtab_free (finfo.symstrtab);
+  if (finfo.contents != NULL)
+    free (finfo.contents);
+  if (finfo.external_relocs != NULL)
+    free (finfo.external_relocs);
+  if (finfo.internal_relocs != NULL)
+    free (finfo.internal_relocs);
+  if (finfo.external_syms != NULL)
+    free (finfo.external_syms);
+  if (finfo.locsym_shndx != NULL)
+    free (finfo.locsym_shndx);
+  if (finfo.internal_syms != NULL)
+    free (finfo.internal_syms);
+  if (finfo.indices != NULL)
+    free (finfo.indices);
+  if (finfo.sections != NULL)
+    free (finfo.sections);
+  if (finfo.symbuf != NULL)
+    free (finfo.symbuf);
+  if (finfo.symshndxbuf != NULL)
+    free (finfo.symbuf);
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if ((o->flags & SEC_RELOC) != 0
+	  && elf_section_data (o)->rel_hashes != NULL)
+	free (elf_section_data (o)->rel_hashes);
+    }
+
+  return false;
+}
+
+/* Add a symbol to the output symbol table.  */
+
+static boolean
+elf_link_output_sym (finfo, name, elfsym, input_sec)
+     struct elf_final_link_info *finfo;
+     const char *name;
+     Elf_Internal_Sym *elfsym;
+     asection *input_sec;
+{
+  Elf_External_Sym *dest;
+  Elf_External_Sym_Shndx *destshndx;
+
+  boolean (*output_symbol_hook) PARAMS ((bfd *,
+					 struct bfd_link_info *info,
+					 const char *,
+					 Elf_Internal_Sym *,
+					 asection *));
+
+  output_symbol_hook = get_elf_backend_data (finfo->output_bfd)->
+    elf_backend_link_output_symbol_hook;
+  if (output_symbol_hook != NULL)
+    {
+      if (! ((*output_symbol_hook)
+	     (finfo->output_bfd, finfo->info, name, elfsym, input_sec)))
+	return false;
+    }
+
+  if (name == (const char *) NULL || *name == '\0')
+    elfsym->st_name = 0;
+  else if (input_sec->flags & SEC_EXCLUDE)
+    elfsym->st_name = 0;
+  else
+    {
+      elfsym->st_name = (unsigned long) _bfd_stringtab_add (finfo->symstrtab,
+							    name, true, false);
+      if (elfsym->st_name == (unsigned long) -1)
+	return false;
+    }
+
+  if (finfo->symbuf_count >= finfo->symbuf_size)
+    {
+      if (! elf_link_flush_output_syms (finfo))
+	return false;
+    }
+
+  dest = finfo->symbuf + finfo->symbuf_count;
+  destshndx = finfo->symshndxbuf;
+  if (destshndx != NULL)
+    destshndx += finfo->symbuf_count;
+  elf_swap_symbol_out (finfo->output_bfd, elfsym, (PTR) dest, (PTR) destshndx);
+  ++finfo->symbuf_count;
+
+  ++ bfd_get_symcount (finfo->output_bfd);
+
+  return true;
+}
+
+/* Flush the output symbols to the file.  */
+
+static boolean
+elf_link_flush_output_syms (finfo)
+     struct elf_final_link_info *finfo;
+{
+  if (finfo->symbuf_count > 0)
+    {
+      Elf_Internal_Shdr *hdr;
+      file_ptr pos;
+      bfd_size_type amt;
+
+      hdr = &elf_tdata (finfo->output_bfd)->symtab_hdr;
+      pos = hdr->sh_offset + hdr->sh_size;
+      amt = finfo->symbuf_count * sizeof (Elf_External_Sym);
+      if (bfd_seek (finfo->output_bfd, pos, SEEK_SET) != 0
+	  || bfd_bwrite ((PTR) finfo->symbuf, amt, finfo->output_bfd) != amt)
+	return false;
+
+      hdr->sh_size += amt;
+
+      if (finfo->symshndxbuf != NULL)
+	{
+	  hdr = &elf_tdata (finfo->output_bfd)->symtab_shndx_hdr;
+	  pos = hdr->sh_offset + hdr->sh_size;
+	  amt = finfo->symbuf_count * sizeof (Elf_External_Sym_Shndx);
+	  if (bfd_seek (finfo->output_bfd, pos, SEEK_SET) != 0
+	      || (bfd_bwrite ((PTR) finfo->symshndxbuf, amt, finfo->output_bfd)
+		  != amt))
+	    return false;
+
+	  hdr->sh_size += amt;
+	}
+
+      finfo->symbuf_count = 0;
+    }
+
+  return true;
+}
+
+/* Adjust all external symbols pointing into SEC_MERGE sections
+   to reflect the object merging within the sections.  */
+
+static boolean
+elf_link_sec_merge_syms (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  asection *sec;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if ((h->root.type == bfd_link_hash_defined
+       || h->root.type == bfd_link_hash_defweak)
+      && ((sec = h->root.u.def.section)->flags & SEC_MERGE)
+      && elf_section_data (sec)->sec_info_type == ELF_INFO_TYPE_MERGE)
+    {
+      bfd *output_bfd = (bfd *) data;
+
+      h->root.u.def.value =
+	_bfd_merged_section_offset (output_bfd,
+				    &h->root.u.def.section,
+				    elf_section_data (sec)->sec_info,
+				    h->root.u.def.value, (bfd_vma) 0);
+    }
+
+  return true;
+}
+
+/* For DSOs loaded in via a DT_NEEDED entry, emulate ld.so in
+   allowing an unsatisfied unversioned symbol in the DSO to match a
+   versioned symbol that would normally require an explicit version.  */
+
+static boolean
+elf_link_check_versioned_symbol (info, h)
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *h;
+{
+  bfd *undef_bfd = h->root.u.undef.abfd;
+  struct elf_link_loaded_list *loaded;
+
+  if ((undef_bfd->flags & DYNAMIC) == 0
+      || info->hash->creator->flavour != bfd_target_elf_flavour
+      || elf_dt_soname (h->root.u.undef.abfd) == NULL)
+    return false;
+
+  for (loaded = elf_hash_table (info)->loaded;
+       loaded != NULL;
+       loaded = loaded->next)
+    {
+      bfd *input;
+      Elf_Internal_Shdr *hdr;
+      bfd_size_type symcount;
+      bfd_size_type extsymcount;
+      bfd_size_type extsymoff;
+      Elf_Internal_Shdr *versymhdr;
+      Elf_Internal_Sym *isym;
+      Elf_Internal_Sym *isymend;
+      Elf_Internal_Sym *isymbuf;
+      Elf_External_Versym *ever;
+      Elf_External_Versym *extversym;
+
+      input = loaded->abfd;
+
+      /* We check each DSO for a possible hidden versioned definition.  */
+      if (input == undef_bfd
+	  || (input->flags & DYNAMIC) == 0
+	  || elf_dynversym (input) == 0)
+	continue;
+
+      hdr = &elf_tdata (input)->dynsymtab_hdr;
+
+      symcount = hdr->sh_size / sizeof (Elf_External_Sym);
+      if (elf_bad_symtab (input))
+	{
+	  extsymcount = symcount;
+	  extsymoff = 0;
+	}
+      else
+	{
+	  extsymcount = symcount - hdr->sh_info;
+	  extsymoff = hdr->sh_info;
+	}
+
+      if (extsymcount == 0)
+	continue;
+
+      isymbuf = bfd_elf_get_elf_syms (input, hdr, extsymcount, extsymoff,
+				      NULL, NULL, NULL);
+      if (isymbuf == NULL)
+	return false;
+
+      /* Read in any version definitions.  */
+      versymhdr = &elf_tdata (input)->dynversym_hdr;
+      extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
+      if (extversym == NULL)
+	goto error_ret;
+
+      if (bfd_seek (input, versymhdr->sh_offset, SEEK_SET) != 0
+	  || (bfd_bread ((PTR) extversym, versymhdr->sh_size, input)
+	      != versymhdr->sh_size))
+	{
+	  free (extversym);
+	error_ret:
+	  free (isymbuf);
+	  return false;
+	}
+
+      ever = extversym + extsymoff;
+      isymend = isymbuf + extsymcount;
+      for (isym = isymbuf; isym < isymend; isym++, ever++)
+	{
+	  const char *name;
+	  Elf_Internal_Versym iver;
+
+	  if (ELF_ST_BIND (isym->st_info) == STB_LOCAL
+	      || isym->st_shndx == SHN_UNDEF)
+	    continue;
+
+	  name = bfd_elf_string_from_elf_section (input,
+						  hdr->sh_link,
+						  isym->st_name);
+	  if (strcmp (name, h->root.root.string) != 0)
+	    continue;
+
+	  _bfd_elf_swap_versym_in (input, ever, &iver);
+
+	  if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
+	    {
+	      /* If we have a non-hidden versioned sym, then it should
+		 have provided a definition for the undefined sym.  */
+	      abort ();
+	    }
+
+	  if ((iver.vs_vers & VERSYM_VERSION) == 2)
+	    {
+	      /* This is the oldest (default) sym.  We can use it.  */
+	      free (extversym);
+	      free (isymbuf);
+	      return true;
+	    }
+	}
+
+      free (extversym);
+      free (isymbuf);
+    }
+
+  return false;
+}
+
+/* Add an external symbol to the symbol table.  This is called from
+   the hash table traversal routine.  When generating a shared object,
+   we go through the symbol table twice.  The first time we output
+   anything that might have been forced to local scope in a version
+   script.  The second time we output the symbols that are still
+   global symbols.  */
+
+static boolean
+elf_link_output_extsym (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  struct elf_outext_info *eoinfo = (struct elf_outext_info *) data;
+  struct elf_final_link_info *finfo = eoinfo->finfo;
+  boolean strip;
+  Elf_Internal_Sym sym;
+  asection *input_sec;
+
+  if (h->root.type == bfd_link_hash_warning)
+    {
+      h = (struct elf_link_hash_entry *) h->root.u.i.link;
+      if (h->root.type == bfd_link_hash_new)
+	return true;
+    }
+
+  /* Decide whether to output this symbol in this pass.  */
+  if (eoinfo->localsyms)
+    {
+      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
+	return true;
+    }
+  else
+    {
+      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
+	return true;
+    }
+
+  /* If we are not creating a shared library, and this symbol is
+     referenced by a shared library but is not defined anywhere, then
+     warn that it is undefined.  If we do not do this, the runtime
+     linker will complain that the symbol is undefined when the
+     program is run.  We don't have to worry about symbols that are
+     referenced by regular files, because we will already have issued
+     warnings for them.  */
+  if (! finfo->info->relocateable
+      && ! finfo->info->allow_shlib_undefined
+      && ! finfo->info->shared
+      && h->root.type == bfd_link_hash_undefined
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
+      && ! elf_link_check_versioned_symbol (finfo->info, h))
+    {
+      if (! ((*finfo->info->callbacks->undefined_symbol)
+	     (finfo->info, h->root.root.string, h->root.u.undef.abfd,
+	      (asection *) NULL, (bfd_vma) 0, true)))
+	{
+	  eoinfo->failed = true;
+	  return false;
+	}
+    }
+
+  /* We don't want to output symbols that have never been mentioned by
+     a regular file, or that we have been told to strip.  However, if
+     h->indx is set to -2, the symbol is used by a reloc and we must
+     output it.  */
+  if (h->indx == -2)
+    strip = false;
+  else if (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+	    || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
+	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
+	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
+    strip = true;
+  else if (finfo->info->strip == strip_all
+	   || (finfo->info->strip == strip_some
+	       && bfd_hash_lookup (finfo->info->keep_hash,
+				   h->root.root.string,
+				   false, false) == NULL))
+    strip = true;
+  else
+    strip = false;
+
+  /* If we're stripping it, and it's not a dynamic symbol, there's
+     nothing else to do unless it is a forced local symbol.  */
+  if (strip
+      && h->dynindx == -1
+      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
+    return true;
+
+  sym.st_value = 0;
+  sym.st_size = h->size;
+  sym.st_other = h->other;
+  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
+    sym.st_info = ELF_ST_INFO (STB_LOCAL, h->type);
+  else if (h->root.type == bfd_link_hash_undefweak
+	   || h->root.type == bfd_link_hash_defweak)
+    sym.st_info = ELF_ST_INFO (STB_WEAK, h->type);
+  else
+    sym.st_info = ELF_ST_INFO (STB_GLOBAL, h->type);
+
+  switch (h->root.type)
+    {
+    default:
+    case bfd_link_hash_new:
+    case bfd_link_hash_warning:
+      abort ();
+      return false;
+
+    case bfd_link_hash_undefined:
+    case bfd_link_hash_undefweak:
+      input_sec = bfd_und_section_ptr;
+      sym.st_shndx = SHN_UNDEF;
+      break;
+
+    case bfd_link_hash_defined:
+    case bfd_link_hash_defweak:
+      {
+	input_sec = h->root.u.def.section;
+	if (input_sec->output_section != NULL)
+	  {
+	    sym.st_shndx =
+	      _bfd_elf_section_from_bfd_section (finfo->output_bfd,
+						 input_sec->output_section);
+	    if (sym.st_shndx == SHN_BAD)
+	      {
+		(*_bfd_error_handler)
+		  (_("%s: could not find output section %s for input section %s"),
+		   bfd_get_filename (finfo->output_bfd),
+		   input_sec->output_section->name,
+		   input_sec->name);
+		eoinfo->failed = true;
+		return false;
+	      }
+
+	    /* ELF symbols in relocateable files are section relative,
+	       but in nonrelocateable files they are virtual
+	       addresses.  */
+	    sym.st_value = h->root.u.def.value + input_sec->output_offset;
+	    if (! finfo->info->relocateable)
+	      {
+		sym.st_value += input_sec->output_section->vma;
+		if (h->type == STT_TLS)
+		  {
+		    /* STT_TLS symbols are relative to PT_TLS segment
+		       base.  */
+		    BFD_ASSERT (finfo->first_tls_sec != NULL);
+		    sym.st_value -= finfo->first_tls_sec->vma;
+		  }
+	      }
+	  }
+	else
+	  {
+	    BFD_ASSERT (input_sec->owner == NULL
+			|| (input_sec->owner->flags & DYNAMIC) != 0);
+	    sym.st_shndx = SHN_UNDEF;
+	    input_sec = bfd_und_section_ptr;
+	  }
+      }
+      break;
+
+    case bfd_link_hash_common:
+      input_sec = h->root.u.c.p->section;
+      sym.st_shndx = SHN_COMMON;
+      sym.st_value = 1 << h->root.u.c.p->alignment_power;
+      break;
+
+    case bfd_link_hash_indirect:
+      /* These symbols are created by symbol versioning.  They point
+	 to the decorated version of the name.  For example, if the
+	 symbol foo@@GNU_1.2 is the default, which should be used when
+	 foo is used with no version, then we add an indirect symbol
+	 foo which points to foo@@GNU_1.2.  We ignore these symbols,
+	 since the indirected symbol is already in the hash table.  */
+      return true;
+    }
+
+  /* Give the processor backend a chance to tweak the symbol value,
+     and also to finish up anything that needs to be done for this
+     symbol.  FIXME: Not calling elf_backend_finish_dynamic_symbol for
+     forced local syms when non-shared is due to a historical quirk.  */
+  if ((h->dynindx != -1
+       || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
+      && (finfo->info->shared
+	  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
+      && elf_hash_table (finfo->info)->dynamic_sections_created)
+    {
+      struct elf_backend_data *bed;
+
+      bed = get_elf_backend_data (finfo->output_bfd);
+      if (! ((*bed->elf_backend_finish_dynamic_symbol)
+	     (finfo->output_bfd, finfo->info, h, &sym)))
+	{
+	  eoinfo->failed = true;
+	  return false;
+	}
+    }
+
+  /* If we are marking the symbol as undefined, and there are no
+     non-weak references to this symbol from a regular object, then
+     mark the symbol as weak undefined; if there are non-weak
+     references, mark the symbol as strong.  We can't do this earlier,
+     because it might not be marked as undefined until the
+     finish_dynamic_symbol routine gets through with it.  */
+  if (sym.st_shndx == SHN_UNDEF
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
+      && (ELF_ST_BIND (sym.st_info) == STB_GLOBAL
+	  || ELF_ST_BIND (sym.st_info) == STB_WEAK))
+    {
+      int bindtype;
+
+      if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) != 0)
+	bindtype = STB_GLOBAL;
+      else
+	bindtype = STB_WEAK;
+      sym.st_info = ELF_ST_INFO (bindtype, ELF_ST_TYPE (sym.st_info));
+    }
+
+  /* If a symbol is not defined locally, we clear the visibility field.  */
+  if (! finfo->info->relocateable
+      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+    sym.st_other &= ~ ELF_ST_VISIBILITY (-1);
+
+  /* If this symbol should be put in the .dynsym section, then put it
+     there now.  We already know the symbol index.  We also fill in
+     the entry in the .hash section.  */
+  if (h->dynindx != -1
+      && elf_hash_table (finfo->info)->dynamic_sections_created)
+    {
+      size_t bucketcount;
+      size_t bucket;
+      size_t hash_entry_size;
+      bfd_byte *bucketpos;
+      bfd_vma chain;
+      Elf_External_Sym *esym;
+
+      sym.st_name = h->dynstr_index;
+      esym = (Elf_External_Sym *) finfo->dynsym_sec->contents + h->dynindx;
+      elf_swap_symbol_out (finfo->output_bfd, &sym, (PTR) esym, (PTR) 0);
+
+      bucketcount = elf_hash_table (finfo->info)->bucketcount;
+      bucket = h->elf_hash_value % bucketcount;
+      hash_entry_size
+	= elf_section_data (finfo->hash_sec)->this_hdr.sh_entsize;
+      bucketpos = ((bfd_byte *) finfo->hash_sec->contents
+		   + (bucket + 2) * hash_entry_size);
+      chain = bfd_get (8 * hash_entry_size, finfo->output_bfd, bucketpos);
+      bfd_put (8 * hash_entry_size, finfo->output_bfd, (bfd_vma) h->dynindx,
+	       bucketpos);
+      bfd_put (8 * hash_entry_size, finfo->output_bfd, chain,
+	       ((bfd_byte *) finfo->hash_sec->contents
+		+ (bucketcount + 2 + h->dynindx) * hash_entry_size));
+
+      if (finfo->symver_sec != NULL && finfo->symver_sec->contents != NULL)
+	{
+	  Elf_Internal_Versym iversym;
+	  Elf_External_Versym *eversym;
+
+	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+	    {
+	      if (h->verinfo.verdef == NULL)
+		iversym.vs_vers = 0;
+	      else
+		iversym.vs_vers = h->verinfo.verdef->vd_exp_refno + 1;
+	    }
+	  else
+	    {
+	      if (h->verinfo.vertree == NULL)
+		iversym.vs_vers = 1;
+	      else
+		iversym.vs_vers = h->verinfo.vertree->vernum + 1;
+	    }
+
+	  if ((h->elf_link_hash_flags & ELF_LINK_HIDDEN) != 0)
+	    iversym.vs_vers |= VERSYM_HIDDEN;
+
+	  eversym = (Elf_External_Versym *) finfo->symver_sec->contents;
+	  eversym += h->dynindx;
+	  _bfd_elf_swap_versym_out (finfo->output_bfd, &iversym, eversym);
+	}
+    }
+
+  /* If we're stripping it, then it was just a dynamic symbol, and
+     there's nothing else to do.  */
+  if (strip || (input_sec->flags & SEC_EXCLUDE) != 0)
+    return true;
+
+  h->indx = bfd_get_symcount (finfo->output_bfd);
+
+  if (! elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec))
+    {
+      eoinfo->failed = true;
+      return false;
+    }
+
+  return true;
+}
+
+/* Copy the relocations indicated by the INTERNAL_RELOCS (which
+   originated from the section given by INPUT_REL_HDR) to the
+   OUTPUT_BFD.  */
+
+static boolean
+elf_link_output_relocs (output_bfd, input_section, input_rel_hdr,
+			internal_relocs)
+     bfd *output_bfd;
+     asection *input_section;
+     Elf_Internal_Shdr *input_rel_hdr;
+     Elf_Internal_Rela *internal_relocs;
+{
+  Elf_Internal_Rela *irela;
+  Elf_Internal_Rela *irelaend;
+  Elf_Internal_Shdr *output_rel_hdr;
+  asection *output_section;
+  unsigned int *rel_countp = NULL;
+  struct elf_backend_data *bed;
+  bfd_size_type amt;
+
+  output_section = input_section->output_section;
+  output_rel_hdr = NULL;
+
+  if (elf_section_data (output_section)->rel_hdr.sh_entsize
+      == input_rel_hdr->sh_entsize)
+    {
+      output_rel_hdr = &elf_section_data (output_section)->rel_hdr;
+      rel_countp = &elf_section_data (output_section)->rel_count;
+    }
+  else if (elf_section_data (output_section)->rel_hdr2
+	   && (elf_section_data (output_section)->rel_hdr2->sh_entsize
+	       == input_rel_hdr->sh_entsize))
+    {
+      output_rel_hdr = elf_section_data (output_section)->rel_hdr2;
+      rel_countp = &elf_section_data (output_section)->rel_count2;
+    }
+  else
+    {
+      (*_bfd_error_handler)
+	(_("%s: relocation size mismatch in %s section %s"),
+	 bfd_get_filename (output_bfd),
+	 bfd_archive_filename (input_section->owner),
+	 input_section->name);
+      bfd_set_error (bfd_error_wrong_object_format);
+      return false;
+    }
+
+  bed = get_elf_backend_data (output_bfd);
+  irela = internal_relocs;
+  irelaend = irela + (NUM_SHDR_ENTRIES (input_rel_hdr)
+		      * bed->s->int_rels_per_ext_rel);
+
+  if (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rel))
+    {
+      Elf_External_Rel *erel;
+      Elf_Internal_Rel *irel;
+
+      amt = bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rel);
+      irel = (Elf_Internal_Rel *) bfd_zmalloc (amt);
+      if (irel == NULL)
+	{
+	  (*_bfd_error_handler) (_("Error: out of memory"));
+	  abort ();
+	}
+
+      erel = ((Elf_External_Rel *) output_rel_hdr->contents + *rel_countp);
+      for (; irela < irelaend; irela += bed->s->int_rels_per_ext_rel, erel++)
+	{
+	  unsigned int i;
+
+	  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
+	    {
+	      irel[i].r_offset = irela[i].r_offset;
+	      irel[i].r_info = irela[i].r_info;
+	      BFD_ASSERT (irela[i].r_addend == 0);
+	    }
+
+	  if (bed->s->swap_reloc_out)
+	    (*bed->s->swap_reloc_out) (output_bfd, irel, (PTR) erel);
+	  else
+	    elf_swap_reloc_out (output_bfd, irel, erel);
+	}
+
+      free (irel);
+    }
+  else
+    {
+      Elf_External_Rela *erela;
+
+      BFD_ASSERT (input_rel_hdr->sh_entsize == sizeof (Elf_External_Rela));
+
+      erela = ((Elf_External_Rela *) output_rel_hdr->contents + *rel_countp);
+      for (; irela < irelaend; irela += bed->s->int_rels_per_ext_rel, erela++)
+	if (bed->s->swap_reloca_out)
+	  (*bed->s->swap_reloca_out) (output_bfd, irela, (PTR) erela);
+	else
+	  elf_swap_reloca_out (output_bfd, irela, erela);
+    }
+
+  /* Bump the counter, so that we know where to add the next set of
+     relocations.  */
+  *rel_countp += NUM_SHDR_ENTRIES (input_rel_hdr);
+
+  return true;
+}
+
+/* Link an input file into the linker output file.  This function
+   handles all the sections and relocations of the input file at once.
+   This is so that we only have to read the local symbols once, and
+   don't have to keep them in memory.  */
+
+static boolean
+elf_link_input_bfd (finfo, input_bfd)
+     struct elf_final_link_info *finfo;
+     bfd *input_bfd;
+{
+  boolean (*relocate_section) PARAMS ((bfd *, struct bfd_link_info *,
+				       bfd *, asection *, bfd_byte *,
+				       Elf_Internal_Rela *,
+				       Elf_Internal_Sym *, asection **));
+  bfd *output_bfd;
+  Elf_Internal_Shdr *symtab_hdr;
+  size_t locsymcount;
+  size_t extsymoff;
+  Elf_Internal_Sym *isymbuf;
+  Elf_Internal_Sym *isym;
+  Elf_Internal_Sym *isymend;
+  long *pindex;
+  asection **ppsection;
+  asection *o;
+  struct elf_backend_data *bed;
+  boolean emit_relocs;
+  struct elf_link_hash_entry **sym_hashes;
+
+  output_bfd = finfo->output_bfd;
+  bed = get_elf_backend_data (output_bfd);
+  relocate_section = bed->elf_backend_relocate_section;
+
+  /* If this is a dynamic object, we don't want to do anything here:
+     we don't want the local symbols, and we don't want the section
+     contents.  */
+  if ((input_bfd->flags & DYNAMIC) != 0)
+    return true;
+
+  emit_relocs = (finfo->info->relocateable
+		 || finfo->info->emitrelocations
+		 || bed->elf_backend_emit_relocs);
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  if (elf_bad_symtab (input_bfd))
+    {
+      locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
+      extsymoff = 0;
+    }
+  else
+    {
+      locsymcount = symtab_hdr->sh_info;
+      extsymoff = symtab_hdr->sh_info;
+    }
+
+  /* Read the local symbols.  */
+  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+  if (isymbuf == NULL && locsymcount != 0)
+    {
+      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
+				      finfo->internal_syms,
+				      finfo->external_syms,
+				      finfo->locsym_shndx);
+      if (isymbuf == NULL)
+	return false;
+    }
+
+  /* Find local symbol sections and adjust values of symbols in
+     SEC_MERGE sections.  Write out those local symbols we know are
+     going into the output file.  */
+  isymend = isymbuf + locsymcount;
+  for (isym = isymbuf, pindex = finfo->indices, ppsection = finfo->sections;
+       isym < isymend;
+       isym++, pindex++, ppsection++)
+    {
+      asection *isec;
+      const char *name;
+      Elf_Internal_Sym osym;
+
+      *pindex = -1;
+
+      if (elf_bad_symtab (input_bfd))
+	{
+	  if (ELF_ST_BIND (isym->st_info) != STB_LOCAL)
+	    {
+	      *ppsection = NULL;
+	      continue;
+	    }
+	}
+
+      if (isym->st_shndx == SHN_UNDEF)
+	isec = bfd_und_section_ptr;
+      else if (isym->st_shndx < SHN_LORESERVE
+	       || isym->st_shndx > SHN_HIRESERVE)
+	{
+	  isec = section_from_elf_index (input_bfd, isym->st_shndx);
+	  if (isec
+	      && elf_section_data (isec)->sec_info_type == ELF_INFO_TYPE_MERGE
+	      && ELF_ST_TYPE (isym->st_info) != STT_SECTION)
+	    isym->st_value =
+	      _bfd_merged_section_offset (output_bfd, &isec,
+					  elf_section_data (isec)->sec_info,
+					  isym->st_value, (bfd_vma) 0);
+	}
+      else if (isym->st_shndx == SHN_ABS)
+	isec = bfd_abs_section_ptr;
+      else if (isym->st_shndx == SHN_COMMON)
+	isec = bfd_com_section_ptr;
+      else
+	{
+	  /* Who knows?  */
+	  isec = NULL;
+	}
+
+      *ppsection = isec;
+
+      /* Don't output the first, undefined, symbol.  */
+      if (ppsection == finfo->sections)
+	continue;
+
+      if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
+	{
+	  /* We never output section symbols.  Instead, we use the
+	     section symbol of the corresponding section in the output
+	     file.  */
+	  continue;
+	}
+
+      /* If we are stripping all symbols, we don't want to output this
+	 one.  */
+      if (finfo->info->strip == strip_all)
+	continue;
+
+      /* If we are discarding all local symbols, we don't want to
+	 output this one.  If we are generating a relocateable output
+	 file, then some of the local symbols may be required by
+	 relocs; we output them below as we discover that they are
+	 needed.  */
+      if (finfo->info->discard == discard_all)
+	continue;
+
+      /* If this symbol is defined in a section which we are
+	 discarding, we don't need to keep it, but note that
+	 linker_mark is only reliable for sections that have contents.
+	 For the benefit of the MIPS ELF linker, we check SEC_EXCLUDE
+	 as well as linker_mark.  */
+      if ((isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
+	  && isec != NULL
+	  && ((! isec->linker_mark && (isec->flags & SEC_HAS_CONTENTS) != 0)
+	      || (! finfo->info->relocateable
+		  && (isec->flags & SEC_EXCLUDE) != 0)))
+	continue;
+
+      /* Get the name of the symbol.  */
+      name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link,
+					      isym->st_name);
+      if (name == NULL)
+	return false;
+
+      /* See if we are discarding symbols with this name.  */
+      if ((finfo->info->strip == strip_some
+	   && (bfd_hash_lookup (finfo->info->keep_hash, name, false, false)
+	       == NULL))
+	  || (((finfo->info->discard == discard_sec_merge
+		&& (isec->flags & SEC_MERGE) && ! finfo->info->relocateable)
+	       || finfo->info->discard == discard_l)
+	      && bfd_is_local_label_name (input_bfd, name)))
+	continue;
+
+      /* If we get here, we are going to output this symbol.  */
+
+      osym = *isym;
+
+      /* Adjust the section index for the output file.  */
+      osym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
+							 isec->output_section);
+      if (osym.st_shndx == SHN_BAD)
+	return false;
+
+      *pindex = bfd_get_symcount (output_bfd);
+
+      /* ELF symbols in relocateable files are section relative, but
+	 in executable files they are virtual addresses.  Note that
+	 this code assumes that all ELF sections have an associated
+	 BFD section with a reasonable value for output_offset; below
+	 we assume that they also have a reasonable value for
+	 output_section.  Any special sections must be set up to meet
+	 these requirements.  */
+      osym.st_value += isec->output_offset;
+      if (! finfo->info->relocateable)
+	{
+	  osym.st_value += isec->output_section->vma;
+	  if (ELF_ST_TYPE (osym.st_info) == STT_TLS)
+	    {
+	      /* STT_TLS symbols are relative to PT_TLS segment base.  */
+	      BFD_ASSERT (finfo->first_tls_sec != NULL);
+	      osym.st_value -= finfo->first_tls_sec->vma;
+	    }
+	}
+
+      if (! elf_link_output_sym (finfo, name, &osym, isec))
+	return false;
+    }
+
+  /* Relocate the contents of each section.  */
+  sym_hashes = elf_sym_hashes (input_bfd);
+  for (o = input_bfd->sections; o != NULL; o = o->next)
+    {
+      bfd_byte *contents;
+
+      if (! o->linker_mark)
+	{
+	  /* This section was omitted from the link.  */
+	  continue;
+	}
+
+      if ((o->flags & SEC_HAS_CONTENTS) == 0
+	  || (o->_raw_size == 0 && (o->flags & SEC_RELOC) == 0))
+	continue;
+
+      if ((o->flags & SEC_LINKER_CREATED) != 0)
+	{
+	  /* Section was created by elf_link_create_dynamic_sections
+	     or somesuch.  */
+	  continue;
+	}
+
+      /* Get the contents of the section.  They have been cached by a
+	 relaxation routine.  Note that o is a section in an input
+	 file, so the contents field will not have been set by any of
+	 the routines which work on output files.  */
+      if (elf_section_data (o)->this_hdr.contents != NULL)
+	contents = elf_section_data (o)->this_hdr.contents;
+      else
+	{
+	  contents = finfo->contents;
+	  if (! bfd_get_section_contents (input_bfd, o, contents,
+					  (file_ptr) 0, o->_raw_size))
+	    return false;
+	}
+
+      if ((o->flags & SEC_RELOC) != 0)
+	{
+	  Elf_Internal_Rela *internal_relocs;
+
+	  /* Get the swapped relocs.  */
+	  internal_relocs = (NAME(_bfd_elf,link_read_relocs)
+			     (input_bfd, o, finfo->external_relocs,
+			      finfo->internal_relocs, false));
+	  if (internal_relocs == NULL
+	      && o->reloc_count > 0)
+	    return false;
+
+	  /* Run through the relocs looking for any against symbols
+	     from discarded sections and section symbols from
+	     removed link-once sections.  Complain about relocs
+	     against discarded sections.  Zero relocs against removed
+	     link-once sections.  We should really complain if
+	     anything in the final link tries to use it, but
+	     DWARF-based exception handling might have an entry in
+	     .eh_frame to describe a routine in the linkonce section,
+	     and it turns out to be hard to remove the .eh_frame
+	     entry too.  FIXME.  */
+	  if (!finfo->info->relocateable
+	      && !elf_section_ignore_discarded_relocs (o))
+	    {
+	      Elf_Internal_Rela *rel, *relend;
+
+	      rel = internal_relocs;
+	      relend = rel + o->reloc_count * bed->s->int_rels_per_ext_rel;
+	      for ( ; rel < relend; rel++)
+		{
+		  unsigned long r_symndx = ELF_R_SYM (rel->r_info);
+
+		  if (r_symndx >= locsymcount
+		      || (elf_bad_symtab (input_bfd)
+			  && finfo->sections[r_symndx] == NULL))
+		    {
+		      struct elf_link_hash_entry *h;
+
+		      h = sym_hashes[r_symndx - extsymoff];
+		      while (h->root.type == bfd_link_hash_indirect
+			     || h->root.type == bfd_link_hash_warning)
+			h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+		      /* Complain if the definition comes from a
+			 discarded section.  */
+		      if ((h->root.type == bfd_link_hash_defined
+			   || h->root.type == bfd_link_hash_defweak)
+			  && elf_discarded_section (h->root.u.def.section))
+			{
+			  if ((o->flags & SEC_DEBUGGING) != 0)
+			    {
+			      BFD_ASSERT (r_symndx != 0);
+			      memset (rel, 0, sizeof (*rel));
+			    }
+			  else
+			    {
+			      if (! ((*finfo->info->callbacks->undefined_symbol)
+				     (finfo->info, h->root.root.string,
+				      input_bfd, o, rel->r_offset,
+				      true)))
+				return false;
+			    }
+			}
+		    }
+		  else
+		    {
+		      asection *sec = finfo->sections[r_symndx];
+
+		      if (sec != NULL && elf_discarded_section (sec))
+			{
+			  if ((o->flags & SEC_DEBUGGING) != 0
+			      || (sec->flags & SEC_LINK_ONCE) != 0)
+			    {
+			      BFD_ASSERT (r_symndx != 0);
+			      rel->r_info
+				= ELF_R_INFO (0, ELF_R_TYPE (rel->r_info));
+			      rel->r_addend = 0;
+			    }
+			  else
+			    {
+			      boolean ok;
+			      const char *msg
+				= _("local symbols in discarded section %s");
+			      bfd_size_type amt
+				= strlen (sec->name) + strlen (msg) - 1;
+			      char *buf = (char *) bfd_malloc (amt);
+
+			      if (buf != NULL)
+				sprintf (buf, msg, sec->name);
+			      else
+				buf = (char *) sec->name;
+			      ok = (*finfo->info->callbacks
+				    ->undefined_symbol) (finfo->info, buf,
+							 input_bfd, o,
+							 rel->r_offset,
+							 true);
+			      if (buf != sec->name)
+				free (buf);
+			      if (!ok)
+				return false;
+			    }
+			}
+		    }
+		}
+	    }
+
+	  /* Relocate the section by invoking a back end routine.
+
+	     The back end routine is responsible for adjusting the
+	     section contents as necessary, and (if using Rela relocs
+	     and generating a relocateable output file) adjusting the
+	     reloc addend as necessary.
+
+	     The back end routine does not have to worry about setting
+	     the reloc address or the reloc symbol index.
+
+	     The back end routine is given a pointer to the swapped in
+	     internal symbols, and can access the hash table entries
+	     for the external symbols via elf_sym_hashes (input_bfd).
+
+	     When generating relocateable output, the back end routine
+	     must handle STB_LOCAL/STT_SECTION symbols specially.  The
+	     output symbol is going to be a section symbol
+	     corresponding to the output section, which will require
+	     the addend to be adjusted.  */
+
+	  if (! (*relocate_section) (output_bfd, finfo->info,
+				     input_bfd, o, contents,
+				     internal_relocs,
+				     isymbuf,
+				     finfo->sections))
+	    return false;
+
+	  if (emit_relocs)
+	    {
+	      Elf_Internal_Rela *irela;
+	      Elf_Internal_Rela *irelaend;
+	      struct elf_link_hash_entry **rel_hash;
+	      Elf_Internal_Shdr *input_rel_hdr, *input_rel_hdr2;
+	      unsigned int next_erel;
+	      boolean (*reloc_emitter) PARAMS ((bfd *, asection *,
+						Elf_Internal_Shdr *,
+						Elf_Internal_Rela *));
+	      boolean rela_normal;
+
+	      input_rel_hdr = &elf_section_data (o)->rel_hdr;
+	      rela_normal = (bed->rela_normal
+			     && (input_rel_hdr->sh_entsize
+				 == sizeof (Elf_External_Rela)));
+
+	      /* Adjust the reloc addresses and symbol indices.  */
+
+	      irela = internal_relocs;
+	      irelaend = irela + o->reloc_count * bed->s->int_rels_per_ext_rel;
+	      rel_hash = (elf_section_data (o->output_section)->rel_hashes
+			  + elf_section_data (o->output_section)->rel_count
+			  + elf_section_data (o->output_section)->rel_count2);
+	      for (next_erel = 0; irela < irelaend; irela++, next_erel++)
+		{
+		  unsigned long r_symndx;
+		  asection *sec;
+		  Elf_Internal_Sym sym;
+
+		  if (next_erel == bed->s->int_rels_per_ext_rel)
+		    {
+		      rel_hash++;
+		      next_erel = 0;
+		    }
+
+		  irela->r_offset += o->output_offset;
+
+		  /* Relocs in an executable have to be virtual addresses.  */
+		  if (!finfo->info->relocateable)
+		    irela->r_offset += o->output_section->vma;
+
+		  r_symndx = ELF_R_SYM (irela->r_info);
+
+		  if (r_symndx == 0)
+		    continue;
+
+		  if (r_symndx >= locsymcount
+		      || (elf_bad_symtab (input_bfd)
+			  && finfo->sections[r_symndx] == NULL))
+		    {
+		      struct elf_link_hash_entry *rh;
+		      unsigned long indx;
+
+		      /* This is a reloc against a global symbol.  We
+			 have not yet output all the local symbols, so
+			 we do not know the symbol index of any global
+			 symbol.  We set the rel_hash entry for this
+			 reloc to point to the global hash table entry
+			 for this symbol.  The symbol index is then
+			 set at the end of elf_bfd_final_link.  */
+		      indx = r_symndx - extsymoff;
+		      rh = elf_sym_hashes (input_bfd)[indx];
+		      while (rh->root.type == bfd_link_hash_indirect
+			     || rh->root.type == bfd_link_hash_warning)
+			rh = (struct elf_link_hash_entry *) rh->root.u.i.link;
+
+		      /* Setting the index to -2 tells
+			 elf_link_output_extsym that this symbol is
+			 used by a reloc.  */
+		      BFD_ASSERT (rh->indx < 0);
+		      rh->indx = -2;
+
+		      *rel_hash = rh;
+
+		      continue;
+		    }
+
+		  /* This is a reloc against a local symbol.  */
+
+		  *rel_hash = NULL;
+		  sym = isymbuf[r_symndx];
+		  sec = finfo->sections[r_symndx];
+		  if (ELF_ST_TYPE (sym.st_info) == STT_SECTION)
+		    {
+		      /* I suppose the backend ought to fill in the
+			 section of any STT_SECTION symbol against a
+			 processor specific section.  If we have
+			 discarded a section, the output_section will
+			 be the absolute section.  */
+		      if (bfd_is_abs_section (sec)
+			  || (sec != NULL
+			      && bfd_is_abs_section (sec->output_section)))
+			r_symndx = 0;
+		      else if (sec == NULL || sec->owner == NULL)
+			{
+			  bfd_set_error (bfd_error_bad_value);
+			  return false;
+			}
+		      else
+			{
+			  r_symndx = sec->output_section->target_index;
+			  BFD_ASSERT (r_symndx != 0);
+			}
+
+		      /* Adjust the addend according to where the
+			 section winds up in the output section.  */
+		      if (rela_normal)
+			irela->r_addend += sec->output_offset;
+		    }
+		  else
+		    {
+		      if (finfo->indices[r_symndx] == -1)
+			{
+			  unsigned long shlink;
+			  const char *name;
+			  asection *osec;
+
+			  if (finfo->info->strip == strip_all)
+			    {
+			      /* You can't do ld -r -s.  */
+			      bfd_set_error (bfd_error_invalid_operation);
+			      return false;
+			    }
+
+			  /* This symbol was skipped earlier, but
+			     since it is needed by a reloc, we
+			     must output it now.  */
+			  shlink = symtab_hdr->sh_link;
+			  name = (bfd_elf_string_from_elf_section
+				  (input_bfd, shlink, sym.st_name));
+			  if (name == NULL)
+			    return false;
+
+			  osec = sec->output_section;
+			  sym.st_shndx =
+			    _bfd_elf_section_from_bfd_section (output_bfd,
+							       osec);
+			  if (sym.st_shndx == SHN_BAD)
+			    return false;
+
+			  sym.st_value += sec->output_offset;
+			  if (! finfo->info->relocateable)
+			    {
+			      sym.st_value += osec->vma;
+			      if (ELF_ST_TYPE (sym.st_info) == STT_TLS)
+				{
+				  /* STT_TLS symbols are relative to PT_TLS
+				     segment base.  */
+				  BFD_ASSERT (finfo->first_tls_sec != NULL);
+				  sym.st_value -= finfo->first_tls_sec->vma;
+				}
+			    }
+
+			  finfo->indices[r_symndx]
+			    = bfd_get_symcount (output_bfd);
+
+			  if (! elf_link_output_sym (finfo, name, &sym, sec))
+			    return false;
+			}
+
+		      r_symndx = finfo->indices[r_symndx];
+		    }
+
+		  irela->r_info = ELF_R_INFO (r_symndx,
+					      ELF_R_TYPE (irela->r_info));
+		}
+
+	      /* Swap out the relocs.  */
+	      if (bed->elf_backend_emit_relocs
+		  && !(finfo->info->relocateable
+		       || finfo->info->emitrelocations))
+		reloc_emitter = bed->elf_backend_emit_relocs;
+	      else
+		reloc_emitter = elf_link_output_relocs;
+
+	      if (input_rel_hdr->sh_size != 0
+		  && ! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
+					 internal_relocs))
+		return false;
+
+	      input_rel_hdr2 = elf_section_data (o)->rel_hdr2;
+	      if (input_rel_hdr2 && input_rel_hdr2->sh_size != 0)
+		{
+		  internal_relocs += (NUM_SHDR_ENTRIES (input_rel_hdr)
+				      * bed->s->int_rels_per_ext_rel);
+		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr2,
+					  internal_relocs))
+		    return false;
+		}
+	    }
+	}
+
+      /* Write out the modified section contents.  */
+      if (bed->elf_backend_write_section
+	  && (*bed->elf_backend_write_section) (output_bfd, o, contents))
+	{
+	  /* Section written out.  */
+	}
+      else switch (elf_section_data (o)->sec_info_type)
+	{
+	case ELF_INFO_TYPE_STABS:
+	  if (! (_bfd_write_section_stabs
+		 (output_bfd,
+		  &elf_hash_table (finfo->info)->stab_info,
+		  o, &elf_section_data (o)->sec_info, contents)))
+	    return false;
+	  break;
+	case ELF_INFO_TYPE_MERGE:
+	  if (! (_bfd_write_merged_section
+		 (output_bfd, o, elf_section_data (o)->sec_info)))
+	    return false;
+	  break;
+	case ELF_INFO_TYPE_EH_FRAME:
+	  {
+	    asection *ehdrsec;
+
+	    ehdrsec
+	      = bfd_get_section_by_name (elf_hash_table (finfo->info)->dynobj,
+					 ".eh_frame_hdr");
+	    if (! (_bfd_elf_write_section_eh_frame (output_bfd, o, ehdrsec,
+						    contents)))
+	      return false;
+	  }
+	  break;
+	default:
+	  {
+	    bfd_size_type sec_size;
+
+	    sec_size = (o->_cooked_size != 0 ? o->_cooked_size : o->_raw_size);
+	    if (! (o->flags & SEC_EXCLUDE)
+		&& ! bfd_set_section_contents (output_bfd, o->output_section,
+					       contents,
+					       (file_ptr) o->output_offset,
+					       sec_size))
+	      return false;
+	  }
+	  break;
+	}
+    }
+
+  return true;
+}
+
+/* Generate a reloc when linking an ELF file.  This is a reloc
+   requested by the linker, and does come from any input file.  This
+   is used to build constructor and destructor tables when linking
+   with -Ur.  */
+
+static boolean
+elf_reloc_link_order (output_bfd, info, output_section, link_order)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+     asection *output_section;
+     struct bfd_link_order *link_order;
+{
+  reloc_howto_type *howto;
+  long indx;
+  bfd_vma offset;
+  bfd_vma addend;
+  struct elf_link_hash_entry **rel_hash_ptr;
+  Elf_Internal_Shdr *rel_hdr;
+  struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+
+  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
+  if (howto == NULL)
+    {
+      bfd_set_error (bfd_error_bad_value);
+      return false;
+    }
+
+  addend = link_order->u.reloc.p->addend;
+
+  /* Figure out the symbol index.  */
+  rel_hash_ptr = (elf_section_data (output_section)->rel_hashes
+		  + elf_section_data (output_section)->rel_count
+		  + elf_section_data (output_section)->rel_count2);
+  if (link_order->type == bfd_section_reloc_link_order)
+    {
+      indx = link_order->u.reloc.p->u.section->target_index;
+      BFD_ASSERT (indx != 0);
+      *rel_hash_ptr = NULL;
+    }
+  else
+    {
+      struct elf_link_hash_entry *h;
+
+      /* Treat a reloc against a defined symbol as though it were
+	 actually against the section.  */
+      h = ((struct elf_link_hash_entry *)
+	   bfd_wrapped_link_hash_lookup (output_bfd, info,
+					 link_order->u.reloc.p->u.name,
+					 false, false, true));
+      if (h != NULL
+	  && (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak))
+	{
+	  asection *section;
+
+	  section = h->root.u.def.section;
+	  indx = section->output_section->target_index;
+	  *rel_hash_ptr = NULL;
+	  /* It seems that we ought to add the symbol value to the
+	     addend here, but in practice it has already been added
+	     because it was passed to constructor_callback.  */
+	  addend += section->output_section->vma + section->output_offset;
+	}
+      else if (h != NULL)
+	{
+	  /* Setting the index to -2 tells elf_link_output_extsym that
+	     this symbol is used by a reloc.  */
+	  h->indx = -2;
+	  *rel_hash_ptr = h;
+	  indx = 0;
+	}
+      else
+	{
+	  if (! ((*info->callbacks->unattached_reloc)
+		 (info, link_order->u.reloc.p->u.name, (bfd *) NULL,
+		  (asection *) NULL, (bfd_vma) 0)))
+	    return false;
+	  indx = 0;
+	}
+    }
+
+  /* If this is an inplace reloc, we must write the addend into the
+     object file.  */
+  if (howto->partial_inplace && addend != 0)
+    {
+      bfd_size_type size;
+      bfd_reloc_status_type rstat;
+      bfd_byte *buf;
+      boolean ok;
+      const char *sym_name;
+
+      size = bfd_get_reloc_size (howto);
+      buf = (bfd_byte *) bfd_zmalloc (size);
+      if (buf == (bfd_byte *) NULL)
+	return false;
+      rstat = _bfd_relocate_contents (howto, output_bfd, (bfd_vma) addend, buf);
+      switch (rstat)
+	{
+	case bfd_reloc_ok:
+	  break;
+
+	default:
+	case bfd_reloc_outofrange:
+	  abort ();
+
+	case bfd_reloc_overflow:
+	  if (link_order->type == bfd_section_reloc_link_order)
+	    sym_name = bfd_section_name (output_bfd,
+					 link_order->u.reloc.p->u.section);
+	  else
+	    sym_name = link_order->u.reloc.p->u.name;
+	  if (! ((*info->callbacks->reloc_overflow)
+		 (info, sym_name, howto->name, addend,
+		  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0)))
+	    {
+	      free (buf);
+	      return false;
+	    }
+	  break;
+	}
+      ok = bfd_set_section_contents (output_bfd, output_section, (PTR) buf,
+				     (file_ptr) link_order->offset, size);
+      free (buf);
+      if (! ok)
+	return false;
+    }
+
+  /* The address of a reloc is relative to the section in a
+     relocateable file, and is a virtual address in an executable
+     file.  */
+  offset = link_order->offset;
+  if (! info->relocateable)
+    offset += output_section->vma;
+
+  rel_hdr = &elf_section_data (output_section)->rel_hdr;
+
+  if (rel_hdr->sh_type == SHT_REL)
+    {
+      bfd_size_type size;
+      Elf_Internal_Rel *irel;
+      Elf_External_Rel *erel;
+      unsigned int i;
+
+      size = bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rel);
+      irel = (Elf_Internal_Rel *) bfd_zmalloc (size);
+      if (irel == NULL)
+	return false;
+
+      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
+	irel[i].r_offset = offset;
+      irel[0].r_info = ELF_R_INFO (indx, howto->type);
+
+      erel = ((Elf_External_Rel *) rel_hdr->contents
+	      + elf_section_data (output_section)->rel_count);
+
+      if (bed->s->swap_reloc_out)
+	(*bed->s->swap_reloc_out) (output_bfd, irel, (bfd_byte *) erel);
+      else
+	elf_swap_reloc_out (output_bfd, irel, erel);
+
+      free (irel);
+    }
+  else
+    {
+      bfd_size_type size;
+      Elf_Internal_Rela *irela;
+      Elf_External_Rela *erela;
+      unsigned int i;
+
+      size = bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rela);
+      irela = (Elf_Internal_Rela *) bfd_zmalloc (size);
+      if (irela == NULL)
+	return false;
+
+      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
+	irela[i].r_offset = offset;
+      irela[0].r_info = ELF_R_INFO (indx, howto->type);
+      irela[0].r_addend = addend;
+
+      erela = ((Elf_External_Rela *) rel_hdr->contents
+	       + elf_section_data (output_section)->rel_count);
+
+      if (bed->s->swap_reloca_out)
+	(*bed->s->swap_reloca_out) (output_bfd, irela, (bfd_byte *) erela);
+      else
+	elf_swap_reloca_out (output_bfd, irela, erela);
+    }
+
+  ++elf_section_data (output_section)->rel_count;
+
+  return true;
+}
+
+/* Allocate a pointer to live in a linker created section.  */
+
+boolean
+elf_create_pointer_linker_section (abfd, info, lsect, h, rel)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     elf_linker_section_t *lsect;
+     struct elf_link_hash_entry *h;
+     const Elf_Internal_Rela *rel;
+{
+  elf_linker_section_pointers_t **ptr_linker_section_ptr = NULL;
+  elf_linker_section_pointers_t *linker_section_ptr;
+  unsigned long r_symndx = ELF_R_SYM (rel->r_info);
+  bfd_size_type amt;
+
+  BFD_ASSERT (lsect != NULL);
+
+  /* Is this a global symbol?  */
+  if (h != NULL)
+    {
+      /* Has this symbol already been allocated?  If so, our work is done.  */
+      if (_bfd_elf_find_pointer_linker_section (h->linker_section_pointer,
+						rel->r_addend,
+						lsect->which))
+	return true;
+
+      ptr_linker_section_ptr = &h->linker_section_pointer;
+      /* Make sure this symbol is output as a dynamic symbol.  */
+      if (h->dynindx == -1)
+	{
+	  if (! elf_link_record_dynamic_symbol (info, h))
+	    return false;
+	}
+
+      if (lsect->rel_section)
+	lsect->rel_section->_raw_size += sizeof (Elf_External_Rela);
+    }
+  else
+    {
+      /* Allocation of a pointer to a local symbol.  */
+      elf_linker_section_pointers_t **ptr = elf_local_ptr_offsets (abfd);
+
+      /* Allocate a table to hold the local symbols if first time.  */
+      if (!ptr)
+	{
+	  unsigned int num_symbols = elf_tdata (abfd)->symtab_hdr.sh_info;
+	  register unsigned int i;
+
+	  amt = num_symbols;
+	  amt *= sizeof (elf_linker_section_pointers_t *);
+	  ptr = (elf_linker_section_pointers_t **) bfd_alloc (abfd, amt);
+
+	  if (!ptr)
+	    return false;
+
+	  elf_local_ptr_offsets (abfd) = ptr;
+	  for (i = 0; i < num_symbols; i++)
+	    ptr[i] = (elf_linker_section_pointers_t *) 0;
+	}
+
+      /* Has this symbol already been allocated?  If so, our work is done.  */
+      if (_bfd_elf_find_pointer_linker_section (ptr[r_symndx],
+						rel->r_addend,
+						lsect->which))
+	return true;
+
+      ptr_linker_section_ptr = &ptr[r_symndx];
+
+      if (info->shared)
+	{
+	  /* If we are generating a shared object, we need to
+	     output a R_<xxx>_RELATIVE reloc so that the
+	     dynamic linker can adjust this GOT entry.  */
+	  BFD_ASSERT (lsect->rel_section != NULL);
+	  lsect->rel_section->_raw_size += sizeof (Elf_External_Rela);
+	}
+    }
+
+  /* Allocate space for a pointer in the linker section, and allocate
+     a new pointer record from internal memory.  */
+  BFD_ASSERT (ptr_linker_section_ptr != NULL);
+  amt = sizeof (elf_linker_section_pointers_t);
+  linker_section_ptr = (elf_linker_section_pointers_t *) bfd_alloc (abfd, amt);
+
+  if (!linker_section_ptr)
+    return false;
+
+  linker_section_ptr->next = *ptr_linker_section_ptr;
+  linker_section_ptr->addend = rel->r_addend;
+  linker_section_ptr->which = lsect->which;
+  linker_section_ptr->written_address_p = false;
+  *ptr_linker_section_ptr = linker_section_ptr;
+
+#if 0
+  if (lsect->hole_size && lsect->hole_offset < lsect->max_hole_offset)
+    {
+      linker_section_ptr->offset = (lsect->section->_raw_size
+				    - lsect->hole_size + (ARCH_SIZE / 8));
+      lsect->hole_offset += ARCH_SIZE / 8;
+      lsect->sym_offset  += ARCH_SIZE / 8;
+      if (lsect->sym_hash)
+	{
+	  /* Bump up symbol value if needed.  */
+	  lsect->sym_hash->root.u.def.value += ARCH_SIZE / 8;
+#ifdef DEBUG
+	  fprintf (stderr, "Bump up %s by %ld, current value = %ld\n",
+		   lsect->sym_hash->root.root.string,
+		   (long) ARCH_SIZE / 8,
+		   (long) lsect->sym_hash->root.u.def.value);
+#endif
+	}
+    }
+  else
+#endif
+    linker_section_ptr->offset = lsect->section->_raw_size;
+
+  lsect->section->_raw_size += ARCH_SIZE / 8;
+
+#ifdef DEBUG
+  fprintf (stderr,
+	   "Create pointer in linker section %s, offset = %ld, section size = %ld\n",
+	   lsect->name, (long) linker_section_ptr->offset,
+	   (long) lsect->section->_raw_size);
+#endif
+
+  return true;
+}
+
+#if ARCH_SIZE==64
+#define bfd_put_ptr(BFD,VAL,ADDR) bfd_put_64 (BFD, VAL, ADDR)
+#endif
+#if ARCH_SIZE==32
+#define bfd_put_ptr(BFD,VAL,ADDR) bfd_put_32 (BFD, VAL, ADDR)
+#endif
+
+/* Fill in the address for a pointer generated in a linker section.  */
+
+bfd_vma
+elf_finish_pointer_linker_section (output_bfd, input_bfd, info, lsect, h,
+				   relocation, rel, relative_reloc)
+     bfd *output_bfd;
+     bfd *input_bfd;
+     struct bfd_link_info *info;
+     elf_linker_section_t *lsect;
+     struct elf_link_hash_entry *h;
+     bfd_vma relocation;
+     const Elf_Internal_Rela *rel;
+     int relative_reloc;
+{
+  elf_linker_section_pointers_t *linker_section_ptr;
+
+  BFD_ASSERT (lsect != NULL);
+
+  if (h != NULL)
+    {
+      /* Handle global symbol.  */
+      linker_section_ptr = (_bfd_elf_find_pointer_linker_section
+			    (h->linker_section_pointer,
+			     rel->r_addend,
+			     lsect->which));
+
+      BFD_ASSERT (linker_section_ptr != NULL);
+
+      if (! elf_hash_table (info)->dynamic_sections_created
+	  || (info->shared
+	      && info->symbolic
+	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
+	{
+	  /* This is actually a static link, or it is a
+	     -Bsymbolic link and the symbol is defined
+	     locally.  We must initialize this entry in the
+	     global section.
+
+	     When doing a dynamic link, we create a .rela.<xxx>
+	     relocation entry to initialize the value.  This
+	     is done in the finish_dynamic_symbol routine.  */
+	  if (!linker_section_ptr->written_address_p)
+	    {
+	      linker_section_ptr->written_address_p = true;
+	      bfd_put_ptr (output_bfd,
+			   relocation + linker_section_ptr->addend,
+			   (lsect->section->contents
+			    + linker_section_ptr->offset));
+	    }
+	}
+    }
+  else
+    {
+      /* Handle local symbol.  */
+      unsigned long r_symndx = ELF_R_SYM (rel->r_info);
+      BFD_ASSERT (elf_local_ptr_offsets (input_bfd) != NULL);
+      BFD_ASSERT (elf_local_ptr_offsets (input_bfd)[r_symndx] != NULL);
+      linker_section_ptr = (_bfd_elf_find_pointer_linker_section
+			    (elf_local_ptr_offsets (input_bfd)[r_symndx],
+			     rel->r_addend,
+			     lsect->which));
+
+      BFD_ASSERT (linker_section_ptr != NULL);
+
+      /* Write out pointer if it hasn't been rewritten out before.  */
+      if (!linker_section_ptr->written_address_p)
+	{
+	  linker_section_ptr->written_address_p = true;
+	  bfd_put_ptr (output_bfd, relocation + linker_section_ptr->addend,
+		       lsect->section->contents + linker_section_ptr->offset);
+
+	  if (info->shared)
+	    {
+	      asection *srel = lsect->rel_section;
+	      Elf_Internal_Rela *outrel;
+	      Elf_External_Rela *erel;
+	      struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+	      unsigned int i;
+	      bfd_size_type amt;
+
+	      amt = sizeof (Elf_Internal_Rela) * bed->s->int_rels_per_ext_rel;
+	      outrel = (Elf_Internal_Rela *) bfd_zmalloc (amt);
+	      if (outrel == NULL)
+		{
+		  (*_bfd_error_handler) (_("Error: out of memory"));
+		  return 0;
+		}
+
+	      /* We need to generate a relative reloc for the dynamic
+		 linker.  */
+	      if (!srel)
+		{
+		  srel = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
+						  lsect->rel_name);
+		  lsect->rel_section = srel;
+		}
+
+	      BFD_ASSERT (srel != NULL);
+
+	      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
+		outrel[i].r_offset = (lsect->section->output_section->vma
+				      + lsect->section->output_offset
+				      + linker_section_ptr->offset);
+	      outrel[0].r_info = ELF_R_INFO (0, relative_reloc);
+	      outrel[0].r_addend = 0;
+	      erel = (Elf_External_Rela *) lsect->section->contents;
+	      erel += elf_section_data (lsect->section)->rel_count;
+	      elf_swap_reloca_out (output_bfd, outrel, erel);
+	      ++elf_section_data (lsect->section)->rel_count;
+
+	      free (outrel);
+	    }
+	}
+    }
+
+  relocation = (lsect->section->output_offset
+		+ linker_section_ptr->offset
+		- lsect->hole_offset
+		- lsect->sym_offset);
+
+#ifdef DEBUG
+  fprintf (stderr,
+	   "Finish pointer in linker section %s, offset = %ld (0x%lx)\n",
+	   lsect->name, (long) relocation, (long) relocation);
+#endif
+
+  /* Subtract out the addend, because it will get added back in by the normal
+     processing.  */
+  return relocation - linker_section_ptr->addend;
+}
+
+/* Garbage collect unused sections.  */
+
+static boolean elf_gc_mark
+  PARAMS ((struct bfd_link_info *, asection *,
+	   asection * (*) (asection *, struct bfd_link_info *,
+			   Elf_Internal_Rela *, struct elf_link_hash_entry *,
+			   Elf_Internal_Sym *)));
+
+static boolean elf_gc_sweep
+  PARAMS ((struct bfd_link_info *,
+	   boolean (*) (bfd *, struct bfd_link_info *, asection *,
+			const Elf_Internal_Rela *)));
+
+static boolean elf_gc_sweep_symbol
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+
+static boolean elf_gc_allocate_got_offsets
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+
+static boolean elf_gc_propagate_vtable_entries_used
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+
+static boolean elf_gc_smash_unused_vtentry_relocs
+  PARAMS ((struct elf_link_hash_entry *, PTR));
+
+/* The mark phase of garbage collection.  For a given section, mark
+   it and any sections in this section's group, and all the sections
+   which define symbols to which it refers.  */
+
+static boolean
+elf_gc_mark (info, sec, gc_mark_hook)
+     struct bfd_link_info *info;
+     asection *sec;
+     asection * (*gc_mark_hook) PARAMS ((asection *, struct bfd_link_info *,
+					 Elf_Internal_Rela *,
+					 struct elf_link_hash_entry *,
+					 Elf_Internal_Sym *));
+{
+  boolean ret;
+  asection *group_sec;
+
+  sec->gc_mark = 1;
+
+  /* Mark all the sections in the group.  */
+  group_sec = elf_section_data (sec)->next_in_group;
+  if (group_sec && !group_sec->gc_mark)
+    if (!elf_gc_mark (info, group_sec, gc_mark_hook))
+      return false;
+
+  /* Look through the section relocs.  */
+  ret = true;
+  if ((sec->flags & SEC_RELOC) != 0 && sec->reloc_count > 0)
+    {
+      Elf_Internal_Rela *relstart, *rel, *relend;
+      Elf_Internal_Shdr *symtab_hdr;
+      struct elf_link_hash_entry **sym_hashes;
+      size_t nlocsyms;
+      size_t extsymoff;
+      bfd *input_bfd = sec->owner;
+      struct elf_backend_data *bed = get_elf_backend_data (input_bfd);
+      Elf_Internal_Sym *isym = NULL;
+
+      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+      sym_hashes = elf_sym_hashes (input_bfd);
+
+      /* Read the local symbols.  */
+      if (elf_bad_symtab (input_bfd))
+	{
+	  nlocsyms = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
+	  extsymoff = 0;
+	}
+      else
+	extsymoff = nlocsyms = symtab_hdr->sh_info;
+
+      isym = (Elf_Internal_Sym *) symtab_hdr->contents;
+      if (isym == NULL && nlocsyms != 0)
+	{
+	  isym = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, nlocsyms, 0,
+				       NULL, NULL, NULL);
+	  if (isym == NULL)
+	    return false;
+	}
+
+      /* Read the relocations.  */
+      relstart = (NAME(_bfd_elf,link_read_relocs)
+		  (input_bfd, sec, NULL, (Elf_Internal_Rela *) NULL,
+		   info->keep_memory));
+      if (relstart == NULL)
+	{
+	  ret = false;
+	  goto out1;
+	}
+      relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;
+
+      for (rel = relstart; rel < relend; rel++)
+	{
+	  unsigned long r_symndx;
+	  asection *rsec;
+	  struct elf_link_hash_entry *h;
+
+	  r_symndx = ELF_R_SYM (rel->r_info);
+	  if (r_symndx == 0)
+	    continue;
+
+	  if (r_symndx >= nlocsyms
+	      || ELF_ST_BIND (isym[r_symndx].st_info) != STB_LOCAL)
+	    {
+	      h = sym_hashes[r_symndx - extsymoff];
+	      rsec = (*gc_mark_hook) (sec, info, rel, h, NULL);
+	    }
+	  else
+	    {
+	      rsec = (*gc_mark_hook) (sec, info, rel, NULL, &isym[r_symndx]);
+	    }
+
+	  if (rsec && !rsec->gc_mark)
+	    {
+	      if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour)
+		rsec->gc_mark = 1;
+	      else if (!elf_gc_mark (info, rsec, gc_mark_hook))
+		{
+		  ret = false;
+		  goto out2;
+		}
+	    }
+	}
+
+    out2:
+      if (elf_section_data (sec)->relocs != relstart)
+	free (relstart);
+    out1:
+      if (isym != NULL && symtab_hdr->contents != (unsigned char *) isym)
+	{
+	  if (! info->keep_memory)
+	    free (isym);
+	  else
+	    symtab_hdr->contents = (unsigned char *) isym;
+	}
+    }
+
+  return ret;
+}
+
+/* The sweep phase of garbage collection.  Remove all garbage sections.  */
+
+static boolean
+elf_gc_sweep (info, gc_sweep_hook)
+     struct bfd_link_info *info;
+     boolean (*gc_sweep_hook) PARAMS ((bfd *, struct bfd_link_info *,
+				       asection *, const Elf_Internal_Rela *));
+{
+  bfd *sub;
+
+  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+    {
+      asection *o;
+
+      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
+	continue;
+
+      for (o = sub->sections; o != NULL; o = o->next)
+	{
+	  /* Keep special sections.  Keep .debug sections.  */
+	  if ((o->flags & SEC_LINKER_CREATED)
+	      || (o->flags & SEC_DEBUGGING))
+	    o->gc_mark = 1;
+
+	  if (o->gc_mark)
+	    continue;
+
+	  /* Skip sweeping sections already excluded.  */
+	  if (o->flags & SEC_EXCLUDE)
+	    continue;
+
+	  /* Since this is early in the link process, it is simple
+	     to remove a section from the output.  */
+	  o->flags |= SEC_EXCLUDE;
+
+	  /* But we also have to update some of the relocation
+	     info we collected before.  */
+	  if (gc_sweep_hook
+	      && (o->flags & SEC_RELOC) && o->reloc_count > 0)
+	    {
+	      Elf_Internal_Rela *internal_relocs;
+	      boolean r;
+
+	      internal_relocs = (NAME(_bfd_elf,link_read_relocs)
+				 (o->owner, o, NULL, NULL, info->keep_memory));
+	      if (internal_relocs == NULL)
+		return false;
+
+	      r = (*gc_sweep_hook) (o->owner, info, o, internal_relocs);
+
+	      if (elf_section_data (o)->relocs != internal_relocs)
+		free (internal_relocs);
+
+	      if (!r)
+		return false;
+	    }
+	}
+    }
+
+  /* Remove the symbols that were in the swept sections from the dynamic
+     symbol table.  GCFIXME: Anyone know how to get them out of the
+     static symbol table as well?  */
+  {
+    int i = 0;
+
+    elf_link_hash_traverse (elf_hash_table (info),
+			    elf_gc_sweep_symbol,
+			    (PTR) &i);
+
+    elf_hash_table (info)->dynsymcount = i;
+  }
+
+  return true;
+}
+
+/* Sweep symbols in swept sections.  Called via elf_link_hash_traverse.  */
+
+static boolean
+elf_gc_sweep_symbol (h, idxptr)
+     struct elf_link_hash_entry *h;
+     PTR idxptr;
+{
+  int *idx = (int *) idxptr;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if (h->dynindx != -1
+      && ((h->root.type != bfd_link_hash_defined
+	   && h->root.type != bfd_link_hash_defweak)
+	  || h->root.u.def.section->gc_mark))
+    h->dynindx = (*idx)++;
+
+  return true;
+}
+
+/* Propogate collected vtable information.  This is called through
+   elf_link_hash_traverse.  */
+
+static boolean
+elf_gc_propagate_vtable_entries_used (h, okp)
+     struct elf_link_hash_entry *h;
+     PTR okp;
+{
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Those that are not vtables.  */
+  if (h->vtable_parent == NULL)
+    return true;
+
+  /* Those vtables that do not have parents, we cannot merge.  */
+  if (h->vtable_parent == (struct elf_link_hash_entry *) -1)
+    return true;
+
+  /* If we've already been done, exit.  */
+  if (h->vtable_entries_used && h->vtable_entries_used[-1])
+    return true;
+
+  /* Make sure the parent's table is up to date.  */
+  elf_gc_propagate_vtable_entries_used (h->vtable_parent, okp);
+
+  if (h->vtable_entries_used == NULL)
+    {
+      /* None of this table's entries were referenced.  Re-use the
+	 parent's table.  */
+      h->vtable_entries_used = h->vtable_parent->vtable_entries_used;
+      h->vtable_entries_size = h->vtable_parent->vtable_entries_size;
+    }
+  else
+    {
+      size_t n;
+      boolean *cu, *pu;
+
+      /* Or the parent's entries into ours.  */
+      cu = h->vtable_entries_used;
+      cu[-1] = true;
+      pu = h->vtable_parent->vtable_entries_used;
+      if (pu != NULL)
+	{
+	  asection *sec = h->root.u.def.section;
+	  struct elf_backend_data *bed = get_elf_backend_data (sec->owner);
+	  int file_align = bed->s->file_align;
+
+	  n = h->vtable_parent->vtable_entries_size / file_align;
+	  while (n--)
+	    {
+	      if (*pu)
+		*cu = true;
+	      pu++;
+	      cu++;
+	    }
+	}
+    }
+
+  return true;
+}
+
+static boolean
+elf_gc_smash_unused_vtentry_relocs (h, okp)
+     struct elf_link_hash_entry *h;
+     PTR okp;
+{
+  asection *sec;
+  bfd_vma hstart, hend;
+  Elf_Internal_Rela *relstart, *relend, *rel;
+  struct elf_backend_data *bed;
+  int file_align;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Take care of both those symbols that do not describe vtables as
+     well as those that are not loaded.  */
+  if (h->vtable_parent == NULL)
+    return true;
+
+  BFD_ASSERT (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak);
+
+  sec = h->root.u.def.section;
+  hstart = h->root.u.def.value;
+  hend = hstart + h->size;
+
+  relstart = (NAME(_bfd_elf,link_read_relocs)
+	      (sec->owner, sec, NULL, (Elf_Internal_Rela *) NULL, true));
+  if (!relstart)
+    return *(boolean *) okp = false;
+  bed = get_elf_backend_data (sec->owner);
+  file_align = bed->s->file_align;
+
+  relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;
+
+  for (rel = relstart; rel < relend; ++rel)
+    if (rel->r_offset >= hstart && rel->r_offset < hend)
+      {
+	/* If the entry is in use, do nothing.  */
+	if (h->vtable_entries_used
+	    && (rel->r_offset - hstart) < h->vtable_entries_size)
+	  {
+	    bfd_vma entry = (rel->r_offset - hstart) / file_align;
+	    if (h->vtable_entries_used[entry])
+	      continue;
+	  }
+	/* Otherwise, kill it.  */
+	rel->r_offset = rel->r_info = rel->r_addend = 0;
+      }
+
+  return true;
+}
+
+/* Do mark and sweep of unused sections.  */
+
+boolean
+elf_gc_sections (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  boolean ok = true;
+  bfd *sub;
+  asection * (*gc_mark_hook)
+    PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
+	     struct elf_link_hash_entry *h, Elf_Internal_Sym *));
+
+  if (!get_elf_backend_data (abfd)->can_gc_sections
+      || info->relocateable || info->emitrelocations
+      || elf_hash_table (info)->dynamic_sections_created)
+    return true;
+
+  /* Apply transitive closure to the vtable entry usage info.  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_gc_propagate_vtable_entries_used,
+			  (PTR) &ok);
+  if (!ok)
+    return false;
+
+  /* Kill the vtable relocations that were not used.  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_gc_smash_unused_vtentry_relocs,
+			  (PTR) &ok);
+  if (!ok)
+    return false;
+
+  /* Grovel through relocs to find out who stays ...  */
+
+  gc_mark_hook = get_elf_backend_data (abfd)->gc_mark_hook;
+  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+    {
+      asection *o;
+
+      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
+	continue;
+
+      for (o = sub->sections; o != NULL; o = o->next)
+	{
+	  if (o->flags & SEC_KEEP)
+	    if (!elf_gc_mark (info, o, gc_mark_hook))
+	      return false;
+	}
+    }
+
+  /* ... and mark SEC_EXCLUDE for those that go.  */
+  if (!elf_gc_sweep (info, get_elf_backend_data (abfd)->gc_sweep_hook))
+    return false;
+
+  return true;
+}
+
+/* Called from check_relocs to record the existance of a VTINHERIT reloc.  */
+
+boolean
+elf_gc_record_vtinherit (abfd, sec, h, offset)
+     bfd *abfd;
+     asection *sec;
+     struct elf_link_hash_entry *h;
+     bfd_vma offset;
+{
+  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
+  struct elf_link_hash_entry **search, *child;
+  bfd_size_type extsymcount;
+
+  /* The sh_info field of the symtab header tells us where the
+     external symbols start.  We don't care about the local symbols at
+     this point.  */
+  extsymcount = elf_tdata (abfd)->symtab_hdr.sh_size/sizeof (Elf_External_Sym);
+  if (!elf_bad_symtab (abfd))
+    extsymcount -= elf_tdata (abfd)->symtab_hdr.sh_info;
+
+  sym_hashes = elf_sym_hashes (abfd);
+  sym_hashes_end = sym_hashes + extsymcount;
+
+  /* Hunt down the child symbol, which is in this section at the same
+     offset as the relocation.  */
+  for (search = sym_hashes; search != sym_hashes_end; ++search)
+    {
+      if ((child = *search) != NULL
+	  && (child->root.type == bfd_link_hash_defined
+	      || child->root.type == bfd_link_hash_defweak)
+	  && child->root.u.def.section == sec
+	  && child->root.u.def.value == offset)
+	goto win;
+    }
+
+  (*_bfd_error_handler) ("%s: %s+%lu: No symbol found for INHERIT",
+			 bfd_archive_filename (abfd), sec->name,
+			 (unsigned long) offset);
+  bfd_set_error (bfd_error_invalid_operation);
+  return false;
+
+ win:
+  if (!h)
+    {
+      /* This *should* only be the absolute section.  It could potentially
+	 be that someone has defined a non-global vtable though, which
+	 would be bad.  It isn't worth paging in the local symbols to be
+	 sure though; that case should simply be handled by the assembler.  */
+
+      child->vtable_parent = (struct elf_link_hash_entry *) -1;
+    }
+  else
+    child->vtable_parent = h;
+
+  return true;
+}
+
+/* Called from check_relocs to record the existance of a VTENTRY reloc.  */
+
+boolean
+elf_gc_record_vtentry (abfd, sec, h, addend)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     asection *sec ATTRIBUTE_UNUSED;
+     struct elf_link_hash_entry *h;
+     bfd_vma addend;
+{
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  int file_align = bed->s->file_align;
+
+  if (addend >= h->vtable_entries_size)
+    {
+      size_t size, bytes;
+      boolean *ptr = h->vtable_entries_used;
+
+      /* While the symbol is undefined, we have to be prepared to handle
+	 a zero size.  */
+      if (h->root.type == bfd_link_hash_undefined)
+	size = addend;
+      else
+	{
+	  size = h->size;
+	  if (size < addend)
+	    {
+	      /* Oops!  We've got a reference past the defined end of
+		 the table.  This is probably a bug -- shall we warn?  */
+	      size = addend;
+	    }
+	}
+
+      /* Allocate one extra entry for use as a "done" flag for the
+	 consolidation pass.  */
+      bytes = (size / file_align + 1) * sizeof (boolean);
+
+      if (ptr)
+	{
+	  ptr = bfd_realloc (ptr - 1, (bfd_size_type) bytes);
+
+	  if (ptr != NULL)
+	    {
+	      size_t oldbytes;
+
+	      oldbytes = ((h->vtable_entries_size / file_align + 1)
+			  * sizeof (boolean));
+	      memset (((char *) ptr) + oldbytes, 0, bytes - oldbytes);
+	    }
+	}
+      else
+	ptr = bfd_zmalloc ((bfd_size_type) bytes);
+
+      if (ptr == NULL)
+	return false;
+
+      /* And arrange for that done flag to be at index -1.  */
+      h->vtable_entries_used = ptr + 1;
+      h->vtable_entries_size = size;
+    }
+
+  h->vtable_entries_used[addend / file_align] = true;
+
+  return true;
+}
+
+/* And an accompanying bit to work out final got entry offsets once
+   we're done.  Should be called from final_link.  */
+
+boolean
+elf_gc_common_finalize_got_offsets (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  bfd *i;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  bfd_vma gotoff;
+
+  /* The GOT offset is relative to the .got section, but the GOT header is
+     put into the .got.plt section, if the backend uses it.  */
+  if (bed->want_got_plt)
+    gotoff = 0;
+  else
+    gotoff = bed->got_header_size;
+
+  /* Do the local .got entries first.  */
+  for (i = info->input_bfds; i; i = i->link_next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_size_type j, locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+
+      if (bfd_get_flavour (i) != bfd_target_elf_flavour)
+	continue;
+
+      local_got = elf_local_got_refcounts (i);
+      if (!local_got)
+	continue;
+
+      symtab_hdr = &elf_tdata (i)->symtab_hdr;
+      if (elf_bad_symtab (i))
+	locsymcount = symtab_hdr->sh_size / sizeof (Elf_External_Sym);
+      else
+	locsymcount = symtab_hdr->sh_info;
+
+      for (j = 0; j < locsymcount; ++j)
+	{
+	  if (local_got[j] > 0)
+	    {
+	      local_got[j] = gotoff;
+	      gotoff += ARCH_SIZE / 8;
+	    }
+	  else
+	    local_got[j] = (bfd_vma) -1;
+	}
+    }
+
+  /* Then the global .got entries.  .plt refcounts are handled by
+     adjust_dynamic_symbol  */
+  elf_link_hash_traverse (elf_hash_table (info),
+			  elf_gc_allocate_got_offsets,
+			  (PTR) &gotoff);
+  return true;
+}
+
+/* We need a special top-level link routine to convert got reference counts
+   to real got offsets.  */
+
+static boolean
+elf_gc_allocate_got_offsets (h, offarg)
+     struct elf_link_hash_entry *h;
+     PTR offarg;
+{
+  bfd_vma *off = (bfd_vma *) offarg;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if (h->got.refcount > 0)
+    {
+      h->got.offset = off[0];
+      off[0] += ARCH_SIZE / 8;
+    }
+  else
+    h->got.offset = (bfd_vma) -1;
+
+  return true;
+}
+
+/* Many folk need no more in the way of final link than this, once
+   got entry reference counting is enabled.  */
+
+boolean
+elf_gc_common_final_link (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  if (!elf_gc_common_finalize_got_offsets (abfd, info))
+    return false;
+
+  /* Invoke the regular ELF backend linker to do all the work.  */
+  return elf_bfd_final_link (abfd, info);
+}
+
+/* This function will be called though elf_link_hash_traverse to store
+   all hash value of the exported symbols in an array.  */
+
+static boolean
+elf_collect_hash_codes (h, data)
+     struct elf_link_hash_entry *h;
+     PTR data;
+{
+  unsigned long **valuep = (unsigned long **) data;
+  const char *name;
+  char *p;
+  unsigned long ha;
+  char *alc = NULL;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Ignore indirect symbols.  These are added by the versioning code.  */
+  if (h->dynindx == -1)
+    return true;
+
+  name = h->root.root.string;
+  p = strchr (name, ELF_VER_CHR);
+  if (p != NULL)
+    {
+      alc = bfd_malloc ((bfd_size_type) (p - name + 1));
+      memcpy (alc, name, (size_t) (p - name));
+      alc[p - name] = '\0';
+      name = alc;
+    }
+
+  /* Compute the hash value.  */
+  ha = bfd_elf_hash (name);
+
+  /* Store the found hash value in the array given as the argument.  */
+  *(*valuep)++ = ha;
+
+  /* And store it in the struct so that we can put it in the hash table
+     later.  */
+  h->elf_hash_value = ha;
+
+  if (alc != NULL)
+    free (alc);
+
+  return true;
+}
+
+boolean
+elf_reloc_symbol_deleted_p (offset, cookie)
+     bfd_vma offset;
+     PTR cookie;
+{
+  struct elf_reloc_cookie *rcookie = (struct elf_reloc_cookie *) cookie;
+
+  if (rcookie->bad_symtab)
+    rcookie->rel = rcookie->rels;
+
+  for (; rcookie->rel < rcookie->relend; rcookie->rel++)
+    {
+      unsigned long r_symndx = ELF_R_SYM (rcookie->rel->r_info);
+
+      if (! rcookie->bad_symtab)
+	if (rcookie->rel->r_offset > offset)
+	  return false;
+      if (rcookie->rel->r_offset != offset)
+	continue;
+
+      if (r_symndx >= rcookie->locsymcount
+	  || ELF_ST_BIND (rcookie->locsyms[r_symndx].st_info) != STB_LOCAL)
+	{
+	  struct elf_link_hash_entry *h;
+
+	  h = rcookie->sym_hashes[r_symndx - rcookie->extsymoff];
+
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+	  if ((h->root.type == bfd_link_hash_defined
+	       || h->root.type == bfd_link_hash_defweak)
+	      && elf_discarded_section (h->root.u.def.section))
+	    return true;
+	  else
+	    return false;
+	}
+      else
+	{
+	  /* It's not a relocation against a global symbol,
+	     but it could be a relocation against a local
+	     symbol for a discarded section.  */
+	  asection *isec;
+	  Elf_Internal_Sym *isym;
+
+	  /* Need to: get the symbol; get the section.  */
+	  isym = &rcookie->locsyms[r_symndx];
+	  if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
+	    {
+	      isec = section_from_elf_index (rcookie->abfd, isym->st_shndx);
+	      if (isec != NULL && elf_discarded_section (isec))
+		return true;
+	    }
+	}
+      return false;
+    }
+  return false;
+}
+
+/* Discard unneeded references to discarded sections.
+   Returns true if any section's size was changed.  */
+/* This function assumes that the relocations are in sorted order,
+   which is true for all known assemblers.  */
+
+boolean
+elf_bfd_discard_info (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  struct elf_reloc_cookie cookie;
+  asection *stab, *eh, *ehdr;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_backend_data *bed;
+  bfd *abfd;
+  boolean ret = false;
+  boolean strip = info->strip == strip_all || info->strip == strip_debugger;
+
+  if (info->relocateable
+      || info->traditional_format
+      || info->hash->creator->flavour != bfd_target_elf_flavour
+      || ! is_elf_hash_table (info))
+    return false;
+
+  ehdr = NULL;
+  if (elf_hash_table (info)->dynobj != NULL)
+    ehdr = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
+				    ".eh_frame_hdr");
+
+  for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
+    {
+      if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
+	continue;
+
+      bed = get_elf_backend_data (abfd);
+
+      if ((abfd->flags & DYNAMIC) != 0)
+	continue;
+
+      eh = NULL;
+      if (ehdr)
+	{
+	  eh = bfd_get_section_by_name (abfd, ".eh_frame");
+	  if (eh && (eh->_raw_size == 0
+		     || bfd_is_abs_section (eh->output_section)))
+	    eh = NULL;
+	}
+
+      stab = NULL;
+      if (!strip)
+	{
+	  stab = bfd_get_section_by_name (abfd, ".stab");
+	  if (stab && (stab->_raw_size == 0
+		       || bfd_is_abs_section (stab->output_section)))
+	    stab = NULL;
+	}
+      if ((! stab
+	   || elf_section_data(stab)->sec_info_type != ELF_INFO_TYPE_STABS)
+	  && ! eh
+	  && (strip || ! bed->elf_backend_discard_info))
+	continue;
+
+      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+      cookie.abfd = abfd;
+      cookie.sym_hashes = elf_sym_hashes (abfd);
+      cookie.bad_symtab = elf_bad_symtab (abfd);
+      if (cookie.bad_symtab)
+	{
+	  cookie.locsymcount =
+	    symtab_hdr->sh_size / sizeof (Elf_External_Sym);
+	  cookie.extsymoff = 0;
+	}
+      else
+	{
+	  cookie.locsymcount = symtab_hdr->sh_info;
+	  cookie.extsymoff = symtab_hdr->sh_info;
+	}
+
+      cookie.locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
+      if (cookie.locsyms == NULL && cookie.locsymcount != 0)
+	{
+	  cookie.locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
+						 cookie.locsymcount, 0,
+						 NULL, NULL, NULL);
+	  if (cookie.locsyms == NULL)
+	    return false;
+	}
+
+      if (stab)
+	{
+	  cookie.rels = (NAME(_bfd_elf,link_read_relocs)
+			 (abfd, stab, (PTR) NULL, (Elf_Internal_Rela *) NULL,
+			  info->keep_memory));
+	  if (cookie.rels)
+	    {
+	      cookie.rel = cookie.rels;
+	      cookie.relend =
+		cookie.rels + stab->reloc_count * bed->s->int_rels_per_ext_rel;
+	      if (_bfd_discard_section_stabs (abfd, stab,
+					      elf_section_data (stab)->sec_info,
+					      elf_reloc_symbol_deleted_p,
+					      &cookie))
+		ret = true;
+	      if (elf_section_data (stab)->relocs != cookie.rels)
+		free (cookie.rels);
+	    }
+	}
+
+      if (eh)
+	{
+	  cookie.rels = NULL;
+	  cookie.rel = NULL;
+	  cookie.relend = NULL;
+	  if (eh->reloc_count)
+	    cookie.rels = (NAME(_bfd_elf,link_read_relocs)
+			   (abfd, eh, (PTR) NULL, (Elf_Internal_Rela *) NULL,
+			    info->keep_memory));
+	  if (cookie.rels)
+	    {
+	      cookie.rel = cookie.rels;
+	      cookie.relend =
+		cookie.rels + eh->reloc_count * bed->s->int_rels_per_ext_rel;
+	    }
+	  if (_bfd_elf_discard_section_eh_frame (abfd, info, eh, ehdr,
+						 elf_reloc_symbol_deleted_p,
+						 &cookie))
+	    {
+	      /* Relocs have been edited.  Ensure edited version is
+		 used later in relocate_section.  */
+	      elf_section_data (eh)->relocs = cookie.rels;
+	      ret = true;
+	    }
+	  if (cookie.rels && elf_section_data (eh)->relocs != cookie.rels)
+	    free (cookie.rels);
+	}
+
+      if (bed->elf_backend_discard_info)
+	{
+	  if (bed->elf_backend_discard_info (abfd, &cookie, info))
+	    ret = true;
+	}
+
+      if (cookie.locsyms != NULL
+	  && symtab_hdr->contents != (unsigned char *) cookie.locsyms)
+	{
+	  if (! info->keep_memory)
+	    free (cookie.locsyms);
+	  else
+	    symtab_hdr->contents = (unsigned char *) cookie.locsyms;
+	}
+    }
+
+  if (ehdr && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info, ehdr))
+    ret = true;
+  return ret;
+}
+
+static boolean
+elf_section_ignore_discarded_relocs (sec)
+     asection *sec;
+{
+  struct elf_backend_data *bed;
+
+  switch (elf_section_data (sec)->sec_info_type)
+    {
+    case ELF_INFO_TYPE_STABS:
+    case ELF_INFO_TYPE_EH_FRAME:
+      return true;
+    default:
+      break;
+    }
+
+  bed = get_elf_backend_data (sec->owner);
+  if (bed->elf_backend_ignore_discarded_relocs != NULL
+      && (*bed->elf_backend_ignore_discarded_relocs) (sec))
+    return true;
+
+  return false;
+}
diff -urp --unidirectional-new-file binutils-2.15/bfd/freebsd.h binutils-freebsd/bfd/freebsd.h
--- binutils-2.15/bfd/freebsd.h	2002-11-30 03:39:39.000000000 -0500
+++ binutils-freebsd/bfd/freebsd.h	2004-06-16 02:13:06.000000000 -0400
@@ -19,26 +19,35 @@ along with this program; if not, write t
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */
 
-/* FreeBSD ZMAGIC files never have the header in the text. */
-#define	N_HEADER_IN_TEXT(x)	0
+/* $FreeBSD: src/contrib/binutils/bfd/freebsd.h,v 1.5 2004/06/16 06:13:06 obrien Exp $ */
 
-/* ZMAGIC files start at offset 0.  Does not apply to QMAGIC files. */
-#define TEXT_START_ADDR		0
-
-#define N_GETMAGIC_NET(exec) \
-	((exec).a_info & 0xffff)
-#define N_GETMID_NET(exec) \
-	(((exec).a_info >> 16) & 0x3ff)
-#define N_GETFLAG_NET(ex) \
-	(((exec).a_info >> 26) & 0x3f)
+/* FreeBSD QMAGIC files have the header in the text. */
+#define	N_HEADER_IN_TEXT(x)	1
+#define MY_text_includes_header 1
+
+#define TEXT_START_ADDR		(TARGET_PAGE_SIZE + 0x20)
+
+/*
+ * FreeBSD uses a weird mix of byte orderings for its a_info field.
+ * Its assembler emits NetBSD style object files, with a big-endian
+ * a_info.  Its linker seems to accept either byte ordering, but
+ * emits a little-endian a_info.
+ *
+ * Here, we accept either byte ordering, but always produce
+ * little-endian.
+ *
+ * FIXME - Probably we should always produce the _native_ byte
+ * ordering.  I.e., it should be in the architecture-specific
+ * file, not here.  But in reality, there is no chance
+ * that FreeBSD will ever use a.out in a new port.
+ */
 
 #define N_MACHTYPE(exec) \
 	((enum machine_type) \
-	 ((N_GETMAGIC_NET (exec) == ZMAGIC) ? N_GETMID_NET (exec) : \
-	  ((exec).a_info >> 16) & 0x3ff))
+	 ((freebsd_swap_magic(&(exec).a_info) >> 16) & 0x3ff))
 #define N_FLAGS(exec) \
-	((N_GETMAGIC_NET (exec) == ZMAGIC) ? N_GETFLAG_NET (exec) : \
-	 ((exec).a_info >> 26) & 0x3f)
+	((enum machine_type) \
+	 ((freebsd_swap_magic(&(exec).a_info) >> 26) & 0x3f))
 
 #define N_SET_INFO(exec, magic, type, flags) \
 	((exec).a_info = ((magic) & 0xffff) \
@@ -56,15 +65,44 @@ Foundation, Inc., 59 Temple Place - Suit
 #include "libbfd.h"
 #include "libaout.h"
 
-/* On FreeBSD, the magic number is always in i386 (little-endian)
-   format.  I think.  */
-#define SWAP_MAGIC(ext) bfd_getl32 (ext)
+#define SWAP_MAGIC(ext)			(freebsd_swap_magic(ext))
 
+#define MY_bfd_final_link MY(bfd_final_link)
 #define MY_write_object_contents MY(write_object_contents)
+
+static bfd_boolean MY(bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
 static bfd_boolean MY(write_object_contents) PARAMS ((bfd *abfd));
+static long freebsd_swap_magic PARAMS ((void *ext));
 
 #include "aout-target.h"
 
+static bfd_boolean
+MY(bfd_final_link) (abfd, info)
+  bfd *abfd;
+  struct bfd_link_info *info;
+{
+  obj_aout_subformat (abfd) = q_magic_format;
+  return NAME(aout,final_link) (abfd, info, MY_final_link_callback);
+}
+
+/* Swap a magic number.  We accept either endian, whichever looks valid. */
+
+static long
+freebsd_swap_magic (ext)
+  void *ext;
+{
+  long linfo = bfd_getl32(ext);
+  long binfo = bfd_getb32(ext);
+  int lmagic = linfo & 0xffff;
+  int bmagic = binfo & 0xffff;
+  int lmagic_ok = lmagic == OMAGIC || lmagic == NMAGIC ||
+    lmagic == ZMAGIC || lmagic == QMAGIC;
+  int bmagic_ok = bmagic == OMAGIC || bmagic == NMAGIC ||
+    bmagic == ZMAGIC || bmagic == QMAGIC;
+
+  return bmagic_ok && !lmagic_ok ? binfo : linfo;
+}
+
 /* Write an object file.
    Section contents have already been written.  We write the
    file header, symbols, and relocation.  */
diff -urp --unidirectional-new-file binutils-2.15/bfd/po/POTFILES.in binutils-freebsd/bfd/po/POTFILES.in
--- binutils-2.15/bfd/po/POTFILES.in	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/bfd/po/POTFILES.in	2001-05-28 01:20:39.000000000 -0400
@@ -0,0 +1,255 @@
+aix386-core.c
+aout0.c
+aout32.c
+aout64.c
+aout-adobe.c
+aout-arm.c
+aout-cris.c
+aoutf1.h
+aout-ns32k.c
+aout-sparcle.c
+aout-target.h
+aout-tic30.c
+aoutx.h
+archive.c
+archures.c
+armnetbsd.c
+bfd.c
+binary.c
+bout.c
+cache.c
+cf-i386lynx.c
+cf-m68klynx.c
+cf-sparclynx.c
+cisco-core.c
+coff64-rs6000.c
+coff-a29k.c
+coff-alpha.c
+coff-apollo.c
+coff-arm.c
+coff-aux.c
+coffcode.h
+coffgen.c
+coff-go32.c
+coff-h8300.c
+coff-h8500.c
+coff-i386.c
+coff-i860.c
+coff-i960.c
+cofflink.c
+coff-m68k.c
+coff-m88k.c
+coff-mips.c
+coff-pmac.c
+coff-rs6000.c
+coff-sh.c
+coff-sparc.c
+coff-stgo32.c
+coff-svm68k.c
+coffswap.h
+coff-tic30.c
+coff-tic54x.c
+coff-tic80.c
+coff-u68k.c
+coff-w65.c
+coff-we32k.c
+coff-z8k.c
+corefile.c
+cpu-a29k.c
+cpu-alpha.c
+cpu-arc.c
+cpu-arm.c
+cpu-avr.c
+cpu-cris.c
+cpu-d10v.c
+cpu-d30v.c
+cpu-fr30.c
+cpu-h8300.c
+cpu-h8500.c
+cpu-hppa.c
+cpu-i370.c
+cpu-i386.c
+cpu-i860.c
+cpu-i960.c
+cpu-ia64.c
+cpu-m10200.c
+cpu-m10300.c
+cpu-m32r.c
+cpu-m68hc11.c
+cpu-m68hc12.c
+cpu-m68k.c
+cpu-m88k.c
+cpu-mcore.c
+cpu-mips.c
+cpu-ns32k.c
+cpu-pj.c
+cpu-powerpc.c
+cpu-rs6000.c
+cpu-sh.c
+cpu-sparc.c
+cpu-tic30.c
+cpu-tic54x.c
+cpu-tic80.c
+cpu-v850.c
+cpu-vax.c
+cpu-w65.c
+cpu-we32k.c
+cpu-z8k.c
+demo64.c
+dwarf1.c
+dwarf2.c
+ecoff.c
+ecofflink.c
+ecoffswap.h
+efi-app-ia32.c
+efi-app-ia64.c
+elf32-arc.c
+elf32-arm.h
+elf32-avr.c
+elf32.c
+elf32-cris.c
+elf32-d10v.c
+elf32-d30v.c
+elf32-fr30.c
+elf32-gen.c
+elf32-hppa.c
+elf32-hppa.h
+elf32-i370.c
+elf32-i386.c
+elf32-i860.c
+elf32-i960.c
+elf32-m32r.c
+elf32-m68hc11.c
+elf32-m68hc12.c
+elf32-m68k.c
+elf32-m88k.c
+elf32-mcore.c
+elf32-mips.c
+elf32-pj.c
+elf32-ppc.c
+elf32-sh.c
+elf32-sh-lin.c
+elf32-sparc.c
+elf32-v850.c
+elf64-alpha.c
+elf64.c
+elf64-gen.c
+elf64-hppa.c
+elf64-hppa.h
+elf64-mips.c
+elf64-sparc.c
+elf64-x86-64.c
+elfarm-nabi.c
+elfarm-oabi.c
+elf-bfd.h
+elf.c
+elfcode.h
+elfcore.h
+elf-hppa.h
+elflink.c
+elflink.h
+elf-m10200.c
+elf-m10300.c
+epoc-pe-arm.c
+epoc-pei-arm.c
+format.c
+freebsd.h
+genlink.h
+go32stub.h
+hash.c
+hp300bsd.c
+hp300hpux.c
+hpux-core.c
+i386aout.c
+i386bsd.c
+i386dynix.c
+i386freebsd.c
+i386linux.c
+i386lynx.c
+i386mach3.c
+i386msdos.c
+i386netbsd.c
+i386os9k.c
+ieee.c
+ihex.c
+init.c
+irix-core.c
+libaout.h
+libbfd.c
+libbfd.h
+libcoff.h
+libecoff.h
+libhppa.h
+libieee.h
+libnlm.h
+liboasys.h
+libpei.h
+linker.c
+lynx-core.c
+m68k4knetbsd.c
+m68klinux.c
+m68klynx.c
+m68knetbsd.c
+m88kmach3.c
+mipsbsd.c
+netbsd.h
+newsos3.c
+nlm32-alpha.c
+nlm32.c
+nlm32-i386.c
+nlm32-ppc.c
+nlm32-sparc.c
+nlm64.c
+nlm.c
+nlmcode.h
+nlmswap.h
+nlm-target.h
+ns32k.h
+ns32knetbsd.c
+oasys.c
+opncls.c
+osf-core.c
+pc532-mach.c
+pe-arm.c
+pe-i386.c
+pei-arm.c
+peicode.h
+peigen.c
+pei-i386.c
+pei-mcore.c
+pei-mips.c
+pei-ppc.c
+pei-sh.c
+pe-mcore.c
+pe-mips.c
+pe-ppc.c
+pe-sh.c
+ppcboot.c
+reloc16.c
+reloc.c
+riscix.c
+sco5-core.c
+section.c
+som.c
+som.h
+sparclinux.c
+sparclynx.c
+sparcnetbsd.c
+srec.c
+stabs.c
+stab-syms.c
+sunos.c
+syms.c
+targets.c
+tekhex.c
+trad-core.c
+vaxnetbsd.c
+versados.c
+vms.c
+vms-gsd.c
+vms.h
+vms-hdr.c
+vms-misc.c
+vms-tir.c
+xcofflink.c
+xcoff-target.h
diff -urp --unidirectional-new-file binutils-2.15/bfd/version.h binutils-freebsd/bfd/version.h
--- binutils-2.15/bfd/version.h	2004-05-17 15:36:04.000000000 -0400
+++ binutils-freebsd/bfd/version.h	2004-06-16 01:44:23.000000000 -0400
@@ -1,3 +1,3 @@
-#define BFD_VERSION_DATE 20040517
+#define BFD_VERSION_DATE 20040523
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING @bfd_version_string@
diff -urp --unidirectional-new-file binutils-2.15/binutils/defparse.c binutils-freebsd/binutils/defparse.c
--- binutils-2.15/binutils/defparse.c	2004-05-17 15:40:46.000000000 -0400
+++ binutils-freebsd/binutils/defparse.c	2002-10-11 01:59:35.000000000 -0400
@@ -22,43 +22,41 @@
 # define	SHARED	273
 # define	NONSHARED	274
 # define	NONAME	275
-# define	PRIVATE	276
-# define	SINGLE	277
-# define	MULTIPLE	278
-# define	INITINSTANCE	279
-# define	INITGLOBAL	280
-# define	TERMINSTANCE	281
-# define	TERMGLOBAL	282
-# define	ID	283
-# define	NUMBER	284
+# define	SINGLE	276
+# define	MULTIPLE	277
+# define	INITINSTANCE	278
+# define	INITGLOBAL	279
+# define	TERMINSTANCE	280
+# define	TERMGLOBAL	281
+# define	ID	282
+# define	NUMBER	283
 
 #line 1 "defparse.y"
  /* defparse.y - parser for .def files */
 
-/*  Copyright 1995, 1997, 1998, 1999, 2004
-    Free Software Foundation, Inc.
+/*   Copyright 1995, 1997, 1998, 1999 Free Software Foundation, Inc.
 
-    This file is part of GNU Binutils.
+This file is part of GNU Binutils.
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 
 #include "bfd.h"
 #include "bucomm.h"
 #include "dlltool.h"
 
-#line 27 "defparse.y"
+#line 26 "defparse.y"
 #ifndef YYSTYPE
 typedef union {
   char *id;
@@ -73,12 +71,12 @@ typedef union {
 
 
 
-#define	YYFINAL		98
+#define	YYFINAL		96
 #define	YYFLAG		-32768
-#define	YYNTBASE	35
+#define	YYNTBASE	34
 
 /* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
-#define YYTRANSLATE(x) ((unsigned)(x) <= 284 ? yytranslate[x] : 57)
+#define YYTRANSLATE(x) ((unsigned)(x) <= 283 ? yytranslate[x] : 55)
 
 /* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
 static const char yytranslate[] =
@@ -87,9 +85,9 @@ static const char yytranslate[] =
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    33,     2,    31,     2,     2,     2,
+       2,     2,     2,     2,    32,     2,    30,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,    32,     2,     2,    34,     2,     2,     2,     2,     2,
+       2,    31,     2,     2,    33,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -111,42 +109,42 @@ static const char yytranslate[] =
        2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
        6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
       16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30
+      26,    27,    28,    29
 };
 
 #if YYDEBUG
 static const short yyprhs[] =
 {
        0,     0,     3,     5,     9,    14,    17,    20,    24,    28,
-      31,    34,    37,    40,    43,    48,    49,    52,    60,    63,
-      65,    73,    81,    87,    93,    99,   105,   109,   113,   116,
-     118,   121,   125,   127,   129,   130,   133,   134,   136,   138,
-     140,   142,   144,   146,   148,   150,   151,   153,   154,   156,
-     157,   159,   160,   162,   166,   167,   170,   171,   174,   179,
-     180,   184,   185,   186,   190,   192,   194,   196
+      31,    34,    37,    40,    43,    48,    49,    52,    59,    62,
+      64,    72,    80,    86,    92,    98,   104,   108,   112,   115,
+     117,   120,   124,   126,   128,   129,   132,   133,   135,   137,
+     139,   141,   143,   145,   147,   149,   150,   152,   153,   155,
+     156,   158,   162,   163,   166,   167,   170,   175,   176,   180,
+     181,   182,   186,   188,   190,   192
 };
 static const short yyrhs[] =
 {
-      35,    36,     0,    36,     0,     3,    51,    54,     0,     4,
-      51,    54,    55,     0,    11,    37,     0,     5,    29,     0,
-       6,    30,    45,     0,     7,    30,    45,     0,     8,    43,
-       0,     9,    43,     0,    10,    41,     0,    12,    39,     0,
-      13,    30,     0,    13,    30,    31,    30,     0,     0,    37,
-      38,     0,    29,    53,    52,    48,    47,    49,    50,     0,
-      39,    40,     0,    40,     0,    29,    32,    29,    31,    29,
-      31,    29,     0,    29,    32,    29,    31,    29,    31,    30,
-       0,    29,    32,    29,    31,    29,     0,    29,    32,    29,
-      31,    30,     0,    29,    31,    29,    31,    29,     0,    29,
-      31,    29,    31,    30,     0,    29,    31,    29,     0,    29,
-      31,    30,     0,    41,    42,     0,    42,     0,    29,    43,
-       0,    43,    44,    46,     0,    46,     0,    33,     0,     0,
-      33,    30,     0,     0,    16,     0,    17,     0,    18,     0,
-      19,     0,    20,     0,    23,     0,    24,     0,    15,     0,
-       0,    21,     0,     0,     9,     0,     0,    22,     0,     0,
-      29,     0,    29,    31,    29,     0,     0,    34,    30,     0,
-       0,    32,    29,     0,    32,    29,    31,    29,     0,     0,
-      14,    32,    30,     0,     0,     0,    55,    44,    56,     0,
-      25,     0,    26,     0,    27,     0,    28,     0
+      34,    35,     0,    35,     0,     3,    49,    52,     0,     4,
+      49,    52,    53,     0,    11,    36,     0,     5,    28,     0,
+       6,    29,    44,     0,     7,    29,    44,     0,     8,    42,
+       0,     9,    42,     0,    10,    40,     0,    12,    38,     0,
+      13,    29,     0,    13,    29,    30,    29,     0,     0,    36,
+      37,     0,    28,    51,    50,    47,    46,    48,     0,    38,
+      39,     0,    39,     0,    28,    31,    28,    30,    28,    30,
+      28,     0,    28,    31,    28,    30,    28,    30,    29,     0,
+      28,    31,    28,    30,    28,     0,    28,    31,    28,    30,
+      29,     0,    28,    30,    28,    30,    28,     0,    28,    30,
+      28,    30,    29,     0,    28,    30,    28,     0,    28,    30,
+      29,     0,    40,    41,     0,    41,     0,    28,    42,     0,
+      42,    43,    45,     0,    45,     0,    32,     0,     0,    32,
+      29,     0,     0,    16,     0,    17,     0,    18,     0,    19,
+       0,    20,     0,    22,     0,    23,     0,    15,     0,     0,
+      21,     0,     0,     9,     0,     0,    28,     0,    28,    30,
+      28,     0,     0,    33,    29,     0,     0,    31,    28,     0,
+      31,    28,    30,    28,     0,     0,    14,    31,    29,     0,
+       0,     0,    53,    43,    54,     0,    24,     0,    25,     0,
+      26,     0,    27,     0
 };
 
 #endif
@@ -155,13 +153,13 @@ static const short yyrhs[] =
 /* YYRLINE[YYN] -- source line where rule number YYN was defined. */
 static const short yyrline[] =
 {
-       0,    44,    45,    48,    50,    51,    52,    53,    54,    55,
-      56,    57,    58,    59,    60,    64,    66,    69,    73,    75,
-      78,    80,    81,    82,    83,    84,    85,    86,    89,    91,
-      94,    98,   100,   103,   105,   107,   108,   111,   113,   114,
-     115,   116,   117,   118,   121,   123,   126,   128,   131,   133,
-     136,   138,   141,   142,   148,   151,   153,   156,   158,   164,
-     167,   168,   171,   173,   176,   178,   179,   180
+       0,    43,    44,    47,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,    58,    59,    63,    65,    68,    72,    74,
+      77,    79,    80,    81,    82,    83,    84,    85,    88,    90,
+      93,    97,    99,   102,   104,   106,   107,   110,   112,   113,
+     114,   115,   116,   117,   120,   122,   125,   127,   130,   132,
+     135,   136,   142,   145,   147,   150,   152,   158,   161,   162,
+     165,   167,   170,   172,   173,   174
 };
 #endif
 
@@ -174,38 +172,38 @@ static const char *const yytname[] =
   "$", "error", "$undefined.", "NAME", "LIBRARY", "DESCRIPTION", 
   "STACKSIZE", "HEAPSIZE", "CODE", "DATA", "SECTIONS", "EXPORTS", 
   "IMPORTS", "VERSIONK", "BASE", "CONSTANT", "READ", "WRITE", "EXECUTE", 
-  "SHARED", "NONSHARED", "NONAME", "PRIVATE", "SINGLE", "MULTIPLE", 
-  "INITINSTANCE", "INITGLOBAL", "TERMINSTANCE", "TERMGLOBAL", "ID", 
-  "NUMBER", "'.'", "'='", "','", "'@'", "start", "command", "explist", 
-  "expline", "implist", "impline", "seclist", "secline", "attr_list", 
-  "opt_comma", "opt_number", "attr", "opt_CONSTANT", "opt_NONAME", 
-  "opt_DATA", "opt_PRIVATE", "opt_name", "opt_ordinal", "opt_equal_name", 
-  "opt_base", "option_list", "option", 0
+  "SHARED", "NONSHARED", "NONAME", "SINGLE", "MULTIPLE", "INITINSTANCE", 
+  "INITGLOBAL", "TERMINSTANCE", "TERMGLOBAL", "ID", "NUMBER", "'.'", 
+  "'='", "','", "'@'", "start", "command", "explist", "expline", 
+  "implist", "impline", "seclist", "secline", "attr_list", "opt_comma", 
+  "opt_number", "attr", "opt_CONSTANT", "opt_NONAME", "opt_DATA", 
+  "opt_name", "opt_ordinal", "opt_equal_name", "opt_base", "option_list", 
+  "option", 0
 };
 #endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
 static const short yyr1[] =
 {
-       0,    35,    35,    36,    36,    36,    36,    36,    36,    36,
-      36,    36,    36,    36,    36,    37,    37,    38,    39,    39,
-      40,    40,    40,    40,    40,    40,    40,    40,    41,    41,
-      42,    43,    43,    44,    44,    45,    45,    46,    46,    46,
-      46,    46,    46,    46,    47,    47,    48,    48,    49,    49,
-      50,    50,    51,    51,    51,    52,    52,    53,    53,    53,
-      54,    54,    55,    55,    56,    56,    56,    56
+       0,    34,    34,    35,    35,    35,    35,    35,    35,    35,
+      35,    35,    35,    35,    35,    36,    36,    37,    38,    38,
+      39,    39,    39,    39,    39,    39,    39,    39,    40,    40,
+      41,    42,    42,    43,    43,    44,    44,    45,    45,    45,
+      45,    45,    45,    45,    46,    46,    47,    47,    48,    48,
+      49,    49,    49,    50,    50,    51,    51,    51,    52,    52,
+      53,    53,    54,    54,    54,    54
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
 static const short yyr2[] =
 {
        0,     2,     1,     3,     4,     2,     2,     3,     3,     2,
-       2,     2,     2,     2,     4,     0,     2,     7,     2,     1,
+       2,     2,     2,     2,     4,     0,     2,     6,     2,     1,
        7,     7,     5,     5,     5,     5,     3,     3,     2,     1,
        2,     3,     1,     1,     0,     2,     0,     1,     1,     1,
        1,     1,     1,     1,     1,     0,     1,     0,     1,     0,
-       1,     0,     1,     3,     0,     2,     0,     2,     4,     0,
-       3,     0,     0,     3,     1,     1,     1,     1
+       1,     3,     0,     2,     0,     2,     4,     0,     3,     0,
+       0,     3,     1,     1,     1,     1
 };
 
 /* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
@@ -213,83 +211,81 @@ static const short yyr2[] =
    error. */
 static const short yydefact[] =
 {
-       0,    54,    54,     0,     0,     0,     0,     0,     0,    15,
-       0,     0,     0,     2,    52,    61,    61,     6,    36,    36,
+       0,    52,    52,     0,     0,     0,     0,     0,     0,    15,
+       0,     0,     0,     2,    50,    59,    59,     6,    36,    36,
       37,    38,    39,    40,    41,    42,    43,     9,    32,    10,
        0,    11,    29,     5,     0,    12,    19,    13,     1,     0,
-       0,     3,    62,     0,     7,     8,    33,     0,    30,    28,
-      59,    16,     0,     0,    18,     0,    53,     0,     4,    35,
-      31,     0,    56,    26,    27,     0,    14,    60,     0,    57,
-       0,    47,     0,     0,    64,    65,    66,    67,    63,     0,
-      55,    46,    45,    24,    25,    22,    23,    58,    44,    49,
-       0,    48,    51,    20,    21,    50,    17,     0,     0
+       0,     3,    60,     0,     7,     8,    33,     0,    30,    28,
+      57,    16,     0,     0,    18,     0,    51,     0,     4,    35,
+      31,     0,    54,    26,    27,     0,    14,    58,     0,    55,
+       0,    47,     0,     0,    62,    63,    64,    65,    61,     0,
+      53,    46,    45,    24,    25,    22,    23,    56,    44,    49,
+       0,    48,    17,    20,    21,     0,     0
 };
 
 static const short yydefgoto[] =
 {
       12,    13,    33,    51,    35,    36,    31,    32,    27,    47,
-      44,    28,    89,    82,    92,    96,    15,    71,    62,    41,
-      58,    78
+      44,    28,    89,    82,    92,    15,    71,    62,    41,    58,
+      78
 };
 
 static const short yypact[] =
 {
-      32,   -12,   -12,    17,    -8,    33,    -4,    -4,    35,-32768,
-      36,    37,    21,-32768,    38,    48,    48,-32768,    39,    39,
+      32,   -22,   -22,   -19,   -13,    22,    30,    30,    -6,-32768,
+      26,    38,    21,-32768,    29,    46,    46,-32768,    36,    36,
   -32768,-32768,-32768,-32768,-32768,-32768,-32768,   -15,-32768,   -15,
-      -4,    35,-32768,    41,   -25,    36,-32768,    40,-32768,    44,
-      34,-32768,-32768,    45,-32768,-32768,-32768,    -4,   -15,-32768,
-      42,-32768,   -19,    47,-32768,    49,-32768,    50,    22,-32768,
-  -32768,    52,    43,    51,-32768,    53,-32768,-32768,    26,    54,
-      56,    57,    27,    29,-32768,-32768,-32768,-32768,-32768,    58,
-  -32768,-32768,    68,-32768,-32768,    59,-32768,-32768,-32768,    79,
-      31,-32768,    46,-32768,-32768,-32768,-32768,    89,-32768
+      30,    -6,-32768,    41,   -16,    26,-32768,    40,-32768,    43,
+      42,-32768,-32768,    45,-32768,-32768,-32768,    30,   -15,-32768,
+      44,-32768,    -9,    48,-32768,    49,-32768,    50,   -14,-32768,
+  -32768,    52,    39,    47,-32768,    51,-32768,-32768,    31,    53,
+      55,    61,    33,    35,-32768,-32768,-32768,-32768,-32768,    57,
+  -32768,-32768,    71,-32768,-32768,    58,-32768,-32768,-32768,    78,
+      37,-32768,-32768,-32768,-32768,    89,-32768
 };
 
 static const short yypgoto[] =
 {
-  -32768,    80,-32768,-32768,-32768,    60,-32768,    62,    -7,    55,
-      72,    61,-32768,-32768,-32768,-32768,    92,-32768,-32768,    81,
-  -32768,-32768
+  -32768,    79,-32768,-32768,-32768,    59,-32768,    62,    -7,    34,
+      76,    54,-32768,-32768,-32768,    88,-32768,-32768,    80,-32768,
+  -32768
 };
 
 
-#define	YYLAST		113
+#define	YYLAST		101
 
 
 static const short yytable[] =
 {
-      29,   -34,   -34,   -34,   -34,   -34,    52,    53,   -34,   -34,
-      63,    64,    20,    21,    22,    23,    24,    14,    46,    25,
-      26,    97,    18,    48,     1,     2,     3,     4,     5,     6,
+      29,   -34,   -34,   -34,   -34,   -34,    14,   -34,   -34,    17,
+     -34,   -34,   -34,   -34,    52,    53,    18,    46,    46,    63,
+      64,    95,    30,    48,     1,     2,     3,     4,     5,     6,
        7,     8,     9,    10,    11,     1,     2,     3,     4,     5,
-       6,     7,     8,     9,    10,    11,    17,   -34,   -34,   -34,
-     -34,    74,    75,    76,    77,    46,    83,    84,    85,    86,
-      93,    94,    40,    19,    30,    34,    57,    37,    95,    39,
-      50,    55,    43,    56,    61,    59,    65,    70,    81,    66,
-      67,    69,    72,    88,    73,    79,    80,    87,    91,    98,
-      90,    45,    38,    49,    16,    54,     0,    42,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,    60,     0,
-       0,     0,     0,    68
+       6,     7,     8,     9,    10,    11,    20,    21,    22,    23,
+      24,    19,    25,    26,    34,    74,    75,    76,    77,    39,
+      40,    83,    84,    85,    86,    93,    94,    37,    43,    50,
+      55,    56,    70,    57,    59,    61,    65,    72,    66,    67,
+      69,    73,    81,    79,    80,    87,    88,    91,    90,    96,
+      16,    38,    68,    49,    54,    45,    42,     0,     0,     0,
+       0,    60
 };
 
 static const short yycheck[] =
 {
-       7,    16,    17,    18,    19,    20,    31,    32,    23,    24,
-      29,    30,    16,    17,    18,    19,    20,    29,    33,    23,
-      24,     0,    30,    30,     3,     4,     5,     6,     7,     8,
+       7,    16,    17,    18,    19,    20,    28,    22,    23,    28,
+      24,    25,    26,    27,    30,    31,    29,    32,    32,    28,
+      29,     0,    28,    30,     3,     4,     5,     6,     7,     8,
        9,    10,    11,    12,    13,     3,     4,     5,     6,     7,
-       8,     9,    10,    11,    12,    13,    29,    25,    26,    27,
-      28,    25,    26,    27,    28,    33,    29,    30,    29,    30,
-      29,    30,    14,    30,    29,    29,    32,    30,    22,    31,
-      29,    31,    33,    29,    32,    30,    29,    34,    21,    30,
-      30,    29,    31,    15,    31,    31,    30,    29,     9,     0,
-      31,    19,    12,    31,     2,    35,    -1,    16,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,
-      -1,    -1,    -1,    58
+       8,     9,    10,    11,    12,    13,    16,    17,    18,    19,
+      20,    29,    22,    23,    28,    24,    25,    26,    27,    30,
+      14,    28,    29,    28,    29,    28,    29,    29,    32,    28,
+      30,    28,    33,    31,    29,    31,    28,    30,    29,    29,
+      28,    30,    21,    30,    29,    28,    15,     9,    30,     0,
+       2,    12,    58,    31,    35,    19,    16,    -1,    -1,    -1,
+      -1,    47
 };
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/share/bison-1.35/bison.simple"
+#line 3 "/usr/share/bison/bison.simple"
 
 /* Skeleton output parser for bison,
 
@@ -602,7 +598,7 @@ yystpcpy (yydest, yysrc)
 # endif
 #endif
 
-#line 315 "/usr/share/bison-1.35/bison.simple"
+#line 315 "/usr/share/bison/bison.simple"
 
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
@@ -996,200 +992,192 @@ yyreduce:
   switch (yyn) {
 
 case 3:
-#line 49 "defparse.y"
+#line 48 "defparse.y"
 { def_name (yyvsp[-1].id, yyvsp[0].number); }
     break;
 case 4:
-#line 50 "defparse.y"
+#line 49 "defparse.y"
 { def_library (yyvsp[-2].id, yyvsp[-1].number); }
     break;
 case 6:
-#line 52 "defparse.y"
+#line 51 "defparse.y"
 { def_description (yyvsp[0].id);}
     break;
 case 7:
-#line 53 "defparse.y"
+#line 52 "defparse.y"
 { def_stacksize (yyvsp[-1].number, yyvsp[0].number);}
     break;
 case 8:
-#line 54 "defparse.y"
+#line 53 "defparse.y"
 { def_heapsize (yyvsp[-1].number, yyvsp[0].number);}
     break;
 case 9:
-#line 55 "defparse.y"
+#line 54 "defparse.y"
 { def_code (yyvsp[0].number);}
     break;
 case 10:
-#line 56 "defparse.y"
+#line 55 "defparse.y"
 { def_data (yyvsp[0].number);}
     break;
 case 13:
-#line 59 "defparse.y"
+#line 58 "defparse.y"
 { def_version (yyvsp[0].number,0);}
     break;
 case 14:
-#line 60 "defparse.y"
+#line 59 "defparse.y"
 { def_version (yyvsp[-2].number,yyvsp[0].number);}
     break;
 case 17:
-#line 71 "defparse.y"
-{ def_exports (yyvsp[-6].id, yyvsp[-5].id, yyvsp[-4].number, yyvsp[-3].number, yyvsp[-2].number, yyvsp[-1].number, yyvsp[0].number);}
+#line 70 "defparse.y"
+{ def_exports (yyvsp[-5].id, yyvsp[-4].id, yyvsp[-3].number, yyvsp[-2].number, yyvsp[-1].number, yyvsp[0].number);}
     break;
 case 20:
-#line 79 "defparse.y"
+#line 78 "defparse.y"
 { def_import (yyvsp[-6].id,yyvsp[-4].id,yyvsp[-2].id,yyvsp[0].id, 0); }
     break;
 case 21:
-#line 80 "defparse.y"
+#line 79 "defparse.y"
 { def_import (yyvsp[-6].id,yyvsp[-4].id,yyvsp[-2].id, 0,yyvsp[0].number); }
     break;
 case 22:
-#line 81 "defparse.y"
+#line 80 "defparse.y"
 { def_import (yyvsp[-4].id,yyvsp[-2].id, 0,yyvsp[0].id, 0); }
     break;
 case 23:
-#line 82 "defparse.y"
+#line 81 "defparse.y"
 { def_import (yyvsp[-4].id,yyvsp[-2].id, 0, 0,yyvsp[0].number); }
     break;
 case 24:
-#line 83 "defparse.y"
+#line 82 "defparse.y"
 { def_import ( 0,yyvsp[-4].id,yyvsp[-2].id,yyvsp[0].id, 0); }
     break;
 case 25:
-#line 84 "defparse.y"
+#line 83 "defparse.y"
 { def_import ( 0,yyvsp[-4].id,yyvsp[-2].id, 0,yyvsp[0].number); }
     break;
 case 26:
-#line 85 "defparse.y"
+#line 84 "defparse.y"
 { def_import ( 0,yyvsp[-2].id, 0,yyvsp[0].id, 0); }
     break;
 case 27:
-#line 86 "defparse.y"
+#line 85 "defparse.y"
 { def_import ( 0,yyvsp[-2].id, 0, 0,yyvsp[0].number); }
     break;
 case 30:
-#line 95 "defparse.y"
+#line 94 "defparse.y"
 { def_section (yyvsp[-1].id,yyvsp[0].number);}
     break;
 case 35:
-#line 107 "defparse.y"
+#line 106 "defparse.y"
 { yyval.number=yyvsp[0].number;}
     break;
 case 36:
-#line 108 "defparse.y"
+#line 107 "defparse.y"
 { yyval.number=-1;}
     break;
 case 37:
-#line 112 "defparse.y"
+#line 111 "defparse.y"
 { yyval.number = 1; }
     break;
 case 38:
-#line 113 "defparse.y"
+#line 112 "defparse.y"
 { yyval.number = 2; }
     break;
 case 39:
-#line 114 "defparse.y"
+#line 113 "defparse.y"
 { yyval.number = 4; }
     break;
 case 40:
-#line 115 "defparse.y"
+#line 114 "defparse.y"
 { yyval.number = 8; }
     break;
 case 41:
-#line 116 "defparse.y"
+#line 115 "defparse.y"
 { yyval.number = 0; }
     break;
 case 42:
-#line 117 "defparse.y"
+#line 116 "defparse.y"
 { yyval.number = 0; }
     break;
 case 43:
-#line 118 "defparse.y"
+#line 117 "defparse.y"
 { yyval.number = 0; }
     break;
 case 44:
-#line 122 "defparse.y"
+#line 121 "defparse.y"
 {yyval.number=1;}
     break;
 case 45:
-#line 123 "defparse.y"
+#line 122 "defparse.y"
 {yyval.number=0;}
     break;
 case 46:
-#line 127 "defparse.y"
+#line 126 "defparse.y"
 {yyval.number=1;}
     break;
 case 47:
-#line 128 "defparse.y"
+#line 127 "defparse.y"
 {yyval.number=0;}
     break;
 case 48:
-#line 132 "defparse.y"
+#line 131 "defparse.y"
 { yyval.number = 1; }
     break;
 case 49:
-#line 133 "defparse.y"
+#line 132 "defparse.y"
 { yyval.number = 0; }
     break;
 case 50:
-#line 137 "defparse.y"
-{ yyval.number = 1; }
-    break;
-case 51:
-#line 138 "defparse.y"
-{ yyval.number = 0; }
-    break;
-case 52:
-#line 141 "defparse.y"
+#line 135 "defparse.y"
 { yyval.id =yyvsp[0].id; }
     break;
-case 53:
-#line 143 "defparse.y"
+case 51:
+#line 137 "defparse.y"
 { 
 	    char *name = xmalloc (strlen (yyvsp[-2].id) + 1 + strlen (yyvsp[0].id) + 1);
 	    sprintf (name, "%s.%s", yyvsp[-2].id, yyvsp[0].id);
 	    yyval.id = name;
 	  }
     break;
-case 54:
-#line 148 "defparse.y"
+case 52:
+#line 142 "defparse.y"
 { yyval.id=""; }
     break;
-case 55:
-#line 152 "defparse.y"
+case 53:
+#line 146 "defparse.y"
 { yyval.number=yyvsp[0].number;}
     break;
-case 56:
-#line 153 "defparse.y"
+case 54:
+#line 147 "defparse.y"
 { yyval.number=-1;}
     break;
-case 57:
-#line 157 "defparse.y"
+case 55:
+#line 151 "defparse.y"
 { yyval.id = yyvsp[0].id; }
     break;
-case 58:
-#line 159 "defparse.y"
+case 56:
+#line 153 "defparse.y"
 { 
 	    char *name = xmalloc (strlen (yyvsp[-2].id) + 1 + strlen (yyvsp[0].id) + 1);
 	    sprintf (name, "%s.%s", yyvsp[-2].id, yyvsp[0].id);
 	    yyval.id = name;
 	  }
     break;
-case 59:
-#line 164 "defparse.y"
+case 57:
+#line 158 "defparse.y"
 { yyval.id =  0; }
     break;
-case 60:
-#line 167 "defparse.y"
+case 58:
+#line 161 "defparse.y"
 { yyval.number= yyvsp[0].number;}
     break;
-case 61:
-#line 168 "defparse.y"
+case 59:
+#line 162 "defparse.y"
 { yyval.number=-1;}
     break;
 }
 
-#line 705 "/usr/share/bison-1.35/bison.simple"
+#line 705 "/usr/share/bison/bison.simple"
 
 
   yyvsp -= yylen;
@@ -1420,4 +1408,4 @@ yyreturn:
 #endif
   return yyresult;
 }
-#line 182 "defparse.y"
+#line 176 "defparse.y"
diff -urp --unidirectional-new-file binutils-2.15/binutils/defparse.h binutils-freebsd/binutils/defparse.h
--- binutils-2.15/binutils/defparse.h	2004-05-17 15:40:46.000000000 -0400
+++ binutils-freebsd/binutils/defparse.h	2002-10-11 01:59:35.000000000 -0400
@@ -28,15 +28,14 @@ typedef union {
 # define	SHARED	273
 # define	NONSHARED	274
 # define	NONAME	275
-# define	PRIVATE	276
-# define	SINGLE	277
-# define	MULTIPLE	278
-# define	INITINSTANCE	279
-# define	INITGLOBAL	280
-# define	TERMINSTANCE	281
-# define	TERMGLOBAL	282
-# define	ID	283
-# define	NUMBER	284
+# define	SINGLE	276
+# define	MULTIPLE	277
+# define	INITINSTANCE	278
+# define	INITGLOBAL	279
+# define	TERMINSTANCE	280
+# define	TERMGLOBAL	281
+# define	ID	282
+# define	NUMBER	283
 
 
 extern YYSTYPE yylval;
diff -urp --unidirectional-new-file binutils-2.15/binutils/defparse.y binutils-freebsd/binutils/defparse.y
--- binutils-2.15/binutils/defparse.y	2004-05-17 15:35:51.000000000 -0400
+++ binutils-freebsd/binutils/defparse.y	2002-01-27 06:58:26.000000000 -0500
@@ -1,23 +1,22 @@
 %{ /* defparse.y - parser for .def files */
 
-/*  Copyright 1995, 1997, 1998, 1999, 2004
-    Free Software Foundation, Inc.
+/*   Copyright 1995, 1997, 1998, 1999 Free Software Foundation, Inc.
 
-    This file is part of GNU Binutils.
+This file is part of GNU Binutils.
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 
 #include "bfd.h"
 #include "bucomm.h"
@@ -31,11 +30,11 @@
 
 %token NAME, LIBRARY, DESCRIPTION, STACKSIZE, HEAPSIZE, CODE, DATA
 %token SECTIONS, EXPORTS, IMPORTS, VERSIONK, BASE, CONSTANT
-%token READ WRITE EXECUTE SHARED NONSHARED NONAME PRIVATE
+%token READ WRITE EXECUTE SHARED NONSHARED NONAME
 %token SINGLE MULTIPLE INITINSTANCE INITGLOBAL TERMINSTANCE TERMGLOBAL
 %token <id> ID
 %token <number> NUMBER
-%type  <number> opt_base opt_ordinal opt_NONAME opt_CONSTANT opt_DATA opt_PRIVATE
+%type  <number> opt_base opt_ordinal opt_NONAME opt_CONSTANT opt_DATA
 %type  <number> attr attr_list opt_number
 %type  <id> opt_name opt_equal_name 
 
@@ -67,8 +66,8 @@ explist:
 	;
 
 expline:
-		ID opt_equal_name opt_ordinal opt_NONAME opt_CONSTANT opt_DATA opt_PRIVATE
-			{ def_exports ($1, $2, $3, $4, $5, $6, $7);}
+		ID opt_equal_name opt_ordinal opt_NONAME opt_CONSTANT opt_DATA
+			{ def_exports ($1, $2, $3, $4, $5, $6);}
 	;
 implist:	
 		implist impline
@@ -133,11 +132,6 @@ opt_DATA:
 	|	     { $$ = 0; }
 	;
 
-opt_PRIVATE:
-		PRIVATE { $$ = 1; }
-	|		{ $$ = 0; }
-	;
-
 opt_name: ID		{ $$ =$1; }
 	| ID '.' ID	
 	  { 
diff -urp --unidirectional-new-file binutils-2.15/binutils/rcparse.y binutils-freebsd/binutils/rcparse.y
--- binutils-2.15/binutils/rcparse.y	2003-09-14 08:20:16.000000000 -0400
+++ binutils-freebsd/binutils/rcparse.y	2002-10-11 01:59:40.000000000 -0400
@@ -1,5 +1,5 @@
 %{ /* rcparse.y -- parser for Windows rc files
-   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support.
 
    This file is part of GNU Binutils.
@@ -52,11 +52,6 @@ static unsigned long style;
 static unsigned long base_style;
 static unsigned long default_style;
 static unsigned long class;
-static struct res_id res_text_field;
-
-/* This is used for COMBOBOX, LISTBOX and EDITTEXT which
-   do not allow resource 'text' field in control definition. */
-static const struct res_id res_null_text = { 1, {{0, L""}}};
 
 %}
 
@@ -140,11 +135,11 @@ static const struct res_id res_null_text
 %type <vervar> vertrans
 %type <res_info> suboptions memflags_move_discard memflags_move
 %type <memflags> memflag
-%type <id> id optresidc resref
+%type <id> id resref
 %type <il> exstyle parennumber
 %type <il> numexpr posnumexpr cnumexpr optcnumexpr cposnumexpr
 %type <is> acc_options acc_option menuitem_flags menuitem_flag
-%type <s> file_name resname
+%type <s> optstringc file_name resname
 %type <i> sizednumexpr sizedposnumexpr
 
 %left '|'
@@ -538,78 +533,70 @@ controls:
 	;
 
 control:
-	  AUTO3STATE optresidc
+	  AUTO3STATE
 	    {
 	      default_style = BS_AUTO3STATE | WS_TABSTOP;
 	      base_style = BS_AUTO3STATE;
 	      class = CTL_BUTTON;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| AUTOCHECKBOX optresidc
+	| AUTOCHECKBOX
 	    {
 	      default_style = BS_AUTOCHECKBOX | WS_TABSTOP;
 	      base_style = BS_AUTOCHECKBOX;
 	      class = CTL_BUTTON;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| AUTORADIOBUTTON optresidc
+	| AUTORADIOBUTTON
 	    {
 	      default_style = BS_AUTORADIOBUTTON | WS_TABSTOP;
 	      base_style = BS_AUTORADIOBUTTON;
 	      class = CTL_BUTTON;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| BEDIT optresidc
+	| BEDIT
 	    {
 	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
 	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
 	      class = CTL_EDIT;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	    if (dialog.ex == NULL)
 	      rcparse_warning (_("BEDIT requires DIALOGEX"));
 	    res_string_to_id (&$$->class, "BEDIT");
 	  }
-	| CHECKBOX optresidc
+	| CHECKBOX
 	    {
 	      default_style = BS_CHECKBOX | WS_TABSTOP;
 	      base_style = BS_CHECKBOX | WS_TABSTOP;
 	      class = CTL_BUTTON;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
 	| COMBOBOX
 	    {
-	      /* This is as per MSDN documentation.  With some (???)
-		 versions of MS rc.exe their is no default style.  */
 	      default_style = CBS_SIMPLE | WS_TABSTOP;
 	      base_style = 0;
 	      class = CTL_COMBOBOX;
-	      res_text_field = res_null_text;	
 	    }
 	    control_params
 	  {
 	    $$ = $3;
 	  }
-	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
+	| CONTROL optstringc numexpr cnumexpr control_styleexpr cnumexpr
 	    cnumexpr cnumexpr cnumexpr optcnumexpr opt_control_data
 	  {
 	    $$ = define_control ($2, $3, $6, $7, $8, $9, $4, style, $10);
@@ -620,7 +607,7 @@ control:
 		$$->data = $11;
 	      }
 	  }
-	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
+	| CONTROL optstringc numexpr cnumexpr control_styleexpr cnumexpr
 	    cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr opt_control_data
 	  {
 	    $$ = define_control ($2, $3, $6, $7, $8, $9, $4, style, $10);
@@ -629,7 +616,7 @@ control:
 	    $$->help = $11;
 	    $$->data = $12;
 	  }
-	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
+	| CONTROL optstringc numexpr ',' QUOTEDSTRING control_styleexpr
 	    cnumexpr cnumexpr cnumexpr cnumexpr optcnumexpr opt_control_data
 	  {
 	    $$ = define_control ($2, $3, $7, $8, $9, $10, 0, style, $11);
@@ -642,7 +629,7 @@ control:
 	    $$->class.named = 1;
   	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
 	  }
-	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
+	| CONTROL optstringc numexpr ',' QUOTEDSTRING control_styleexpr
 	    cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr opt_control_data
 	  {
 	    $$ = define_control ($2, $3, $7, $8, $9, $10, 0, style, $11);
@@ -653,60 +640,55 @@ control:
 	    $$->class.named = 1;
   	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
 	  }
-	| CTEXT optresidc
+	| CTEXT
 	    {
 	      default_style = SS_CENTER | WS_GROUP;
 	      base_style = SS_CENTER;
 	      class = CTL_STATIC;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| DEFPUSHBUTTON optresidc
+	| DEFPUSHBUTTON
 	    {
 	      default_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
 	      base_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
 	      class = CTL_BUTTON;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
 	| EDITTEXT
 	    {
 	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
 	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
 	      class = CTL_EDIT;
-	      res_text_field = res_null_text;	
 	    }
 	    control_params
 	  {
 	    $$ = $3;
 	  }
-	| GROUPBOX optresidc
+	| GROUPBOX
 	    {
 	      default_style = BS_GROUPBOX;
 	      base_style = BS_GROUPBOX;
 	      class = CTL_BUTTON;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| HEDIT optresidc
+	| HEDIT
 	    {
 	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
 	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
 	      class = CTL_EDIT;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	    if (dialog.ex == NULL)
 	      rcparse_warning (_("IEDIT requires DIALOGEX"));
 	    res_string_to_id (&$$->class, "HEDIT");
@@ -734,16 +716,15 @@ control:
 	    $$ = define_icon_control ($2, $3, $4, $5, style, $9, $10, $11,
 				      dialog.ex);
           }
-	| IEDIT optresidc
+	| IEDIT
 	    {
 	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
 	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
 	      class = CTL_EDIT;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	    if (dialog.ex == NULL)
 	      rcparse_warning (_("IEDIT requires DIALOGEX"));
 	    res_string_to_id (&$$->class, "IEDIT");
@@ -753,24 +734,22 @@ control:
 	      default_style = LBS_NOTIFY | WS_BORDER;
 	      base_style = LBS_NOTIFY | WS_BORDER;
 	      class = CTL_LISTBOX;
-	      res_text_field = res_null_text;	
 	    }
 	    control_params
 	  {
 	    $$ = $3;
 	  }
-	| LTEXT optresidc
+	| LTEXT
 	    {
 	      default_style = SS_LEFT | WS_GROUP;
 	      base_style = SS_LEFT;
 	      class = CTL_STATIC;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| PUSHBOX optresidc
+	| PUSHBOX
 	    {
 	      default_style = BS_PUSHBOX | WS_TABSTOP;
 	      base_style = BS_PUSHBOX;
@@ -778,70 +757,65 @@ control:
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| PUSHBUTTON optresidc
+	| PUSHBUTTON
 	    {
 	      default_style = BS_PUSHBUTTON | WS_TABSTOP;
 	      base_style = BS_PUSHBUTTON | WS_TABSTOP;
 	      class = CTL_BUTTON;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| RADIOBUTTON optresidc
+	| RADIOBUTTON
 	    {
 	      default_style = BS_RADIOBUTTON | WS_TABSTOP;
 	      base_style = BS_RADIOBUTTON;
 	      class = CTL_BUTTON;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| RTEXT optresidc
+	| RTEXT
 	    {
 	      default_style = SS_RIGHT | WS_GROUP;
 	      base_style = SS_RIGHT;
 	      class = CTL_STATIC;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
 	| SCROLLBAR
 	    {
 	      default_style = SBS_HORZ;
 	      base_style = 0;
 	      class = CTL_SCROLLBAR;
-	      res_text_field = res_null_text;	
 	    }
 	    control_params
 	  {
 	    $$ = $3;
 	  }
-	| STATE3 optresidc
+	| STATE3
 	    {
 	      default_style = BS_3STATE | WS_TABSTOP;
 	      base_style = BS_3STATE;
 	      class = CTL_BUTTON;
-	      res_text_field = $2;	
 	    }
 	    control_params
 	  {
-	    $$ = $4;
+	    $$ = $3;
 	  }
-	| USERBUTTON resref numexpr ',' numexpr ',' numexpr ','
+	| USERBUTTON QUOTEDSTRING ',' numexpr ',' numexpr ',' numexpr ','
 	    numexpr ',' numexpr ',' 
 	    { style = WS_CHILD | WS_VISIBLE; }
 	    styleexpr optcnumexpr
 	  {
-	    $$ = define_control ($2, $3, $5, $7, $9, $11, CTL_BUTTON,
-				 style, $15);
+	    $$ = define_control ($2, $4, $6, $8, $10, $12, CTL_BUTTON,
+				 style, $16);
 	  }
 	;
 
@@ -853,56 +827,52 @@ control:
    style.  CLASS is the class of the control.  */
 
 control_params:
-	  numexpr cnumexpr cnumexpr cnumexpr cnumexpr opt_control_data
+	  optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
+	    opt_control_data
 	  {
-	    $$ = define_control (res_text_field, $1, $2, $3, $4, $5, class,
+	    $$ = define_control ($1, $2, $3, $4, $5, $6, class,
 				 default_style | WS_CHILD | WS_VISIBLE, 0);
-	    if ($6 != NULL)
+	    if ($7 != NULL)
 	      {
 		if (dialog.ex == NULL)
 		  rcparse_warning (_("control data requires DIALOGEX"));
-		$$->data = $6;
+		$$->data = $7;
 	      }
 	  }
-	| numexpr cnumexpr cnumexpr cnumexpr cnumexpr
+	| optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
 	    control_params_styleexpr optcnumexpr opt_control_data
 	  {
-	    $$ = define_control (res_text_field, $1, $2, $3, $4, $5, class, style, $7);
-	    if ($8 != NULL)
+	    $$ = define_control ($1, $2, $3, $4, $5, $6, class, style, $8);
+	    if ($9 != NULL)
 	      {
 		if (dialog.ex == NULL)
 		  rcparse_warning (_("control data requires DIALOGEX"));
-		$$->data = $8;
+		$$->data = $9;
 	      }
 	  }
-	| numexpr cnumexpr cnumexpr cnumexpr cnumexpr
+	| optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
 	    control_params_styleexpr cnumexpr cnumexpr opt_control_data
 	  {
-	    $$ = define_control (res_text_field, $1, $2, $3, $4, $5, class, style, $7);
+	    $$ = define_control ($1, $2, $3, $4, $5, $6, class, style, $8);
 	    if (dialog.ex == NULL)
 	      rcparse_warning (_("help ID requires DIALOGEX"));
-	    $$->help = $8;
-	    $$->data = $9;
+	    $$->help = $9;
+	    $$->data = $10;
 	  }
 	;
 
-optresidc:
+optstringc:
 	  /* empty */
 	  {
-	    res_string_to_id (&$$, "");
-	  }
-	| posnumexpr ','
-	  {
-	    $$.named = 0;
-	    $$.u.id = $1;
+	    $$ = NULL;
 	  }
 	| QUOTEDSTRING
 	  {
-	    res_string_to_id (&$$, $1);
+	    $$ = $1;
 	  }
 	| QUOTEDSTRING ','
 	  {
-	    res_string_to_id (&$$, $1);
+	    $$ = $1;
 	  }
 	;
 
@@ -1762,7 +1732,8 @@ sizedposnumexpr:
 /* Set the language from the command line.  */
 
 void
-rcparse_set_language (int lang)
+rcparse_set_language (lang)
+     int lang;
 {
   language = lang;
 }
diff -urp --unidirectional-new-file binutils-2.15/binutils/sysinfo.y binutils-freebsd/binutils/sysinfo.y
--- binutils-2.15/binutils/sysinfo.y	2003-10-27 08:20:32.000000000 -0500
+++ binutils-freebsd/binutils/sysinfo.y	2002-01-27 06:58:35.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright 2001, 2003 Free Software Foundation, Inc.
+/* Copyright 2001 Free Software Foundation, Inc.
    Written by Steve Chamberlain of Cygnus Support (steve@cygnus.com).
 
 This file is part of GNU binutils.
@@ -406,7 +406,7 @@ enum_list:
 %%
 /* four modes
 
-   -d write structure definitions for sysroff in host format
+   -d write structure defintions for sysroff in host format
    -i write functions to swap into sysroff format in
    -o write functions to swap into sysroff format out
    -c write code to print info in human form */
@@ -415,7 +415,9 @@ int yydebug;
 char writecode;
 
 int 
-main (int ac, char **av)
+main(ac,av)
+int ac;
+char **av;
 {
   yydebug=0;
   if (ac > 1)
@@ -432,7 +434,8 @@ return 0;
 }
 
 int
-yyerror (char *s)
+yyerror(s)
+     char *s;
 {
   fprintf(stderr, "%s\n" , s);
   return 0;
diff -urp --unidirectional-new-file binutils-2.15/binutils/syslex.l binutils-freebsd/binutils/syslex.l
--- binutils-2.15/binutils/syslex.l	2003-09-14 08:20:17.000000000 -0400
+++ binutils-freebsd/binutils/syslex.l	2001-06-26 12:56:06.000000000 -0400
@@ -1,5 +1,5 @@
 %{
-/* Copyright 2001, 2003 Free Software Foundation, Inc.
+/* Copyright 2001 Free Software Foundation, Inc.
 
 This file is part of GLD, the Gnu Linker.
 
@@ -24,7 +24,7 @@ int number;
 int unit;
 
 #ifndef yywrap
-static int yywrap (void) { return 1; }
+static int yywrap () { return 1; }
 #endif
 %}
 %%
diff -urp --unidirectional-new-file binutils-2.15/config/acinclude.m4 binutils-freebsd/config/acinclude.m4
--- binutils-2.15/config/acinclude.m4	2004-01-14 08:41:37.000000000 -0500
+++ binutils-freebsd/config/acinclude.m4	2002-10-11 01:59:53.000000000 -0400
@@ -6,7 +6,7 @@ dnl and doesn't call AC_PROG_CXX_GNU, ca
 dnl We are probably using a cross compiler, which will not be able to fully
 dnl link an executable.  This should really be fixed in autoconf itself.
 dnl Find a working G++ cross compiler. This only works for the GNU C++ compiler.
-AC_DEFUN([CYG_AC_PROG_CXX_CROSS],
+AC_DEFUN(CYG_AC_PROG_CXX_CROSS,
 [AC_BEFORE([$0], [AC_PROG_CXXCPP])
 AC_CHECK_PROGS(CXX, $CCC c++ g++ gcc CC cxx cc++, gcc)
 
@@ -35,7 +35,7 @@ fi
 ])
 
 dnl See if the G++ compiler we found works.
-AC_DEFUN([CYG_AC_PROG_GXX_WORKS],
+AC_DEFUN(CYG_AC_PROG_GXX_WORKS,
 [AC_MSG_CHECKING([whether the G++ compiler ($CXX $CXXFLAGS $LDFLAGS) actually works])
 AC_LANG_SAVE
 AC_LANG_CPLUSPLUS
@@ -103,7 +103,7 @@ AC_SUBST(CXX)
 dnl ====================================================================
 dnl Find a working GCC cross compiler. This only works for the GNU gcc compiler.
 dnl This is based on the macros above for G++.
-AC_DEFUN([CYG_AC_PROG_CC_CROSS],
+AC_DEFUN(CYG_AC_PROG_CC_CROSS,
 [AC_BEFORE([$0], [AC_PROG_CCPP])
 AC_CHECK_PROGS(CC, cc, gcc)
 
@@ -132,7 +132,7 @@ fi
 ])
 
 dnl See if the GCC compiler we found works.
-AC_DEFUN([CYG_AC_PROG_GCC_WORKS],
+AC_DEFUN(CYG_AC_PROG_GCC_WORKS,
 [AC_MSG_CHECKING([whether the Gcc compiler ($CC $CFLAGS $LDFLAGS) actually works])
 AC_LANG_SAVE
 AC_LANG_C
@@ -199,7 +199,7 @@ AC_SUBST(CC)
 dnl ====================================================================
 dnl Find the BFD library in the build tree. This is used to access and
 dnl manipulate object or executable files.
-AC_DEFUN([CYG_AC_PATH_BFD], [
+AC_DEFUN(CYG_AC_PATH_BFD, [
 AC_MSG_CHECKING(for the bfd header in the build tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 dnl Look for the header file
@@ -241,7 +241,7 @@ AC_SUBST(BFDLIB)
 dnl ====================================================================
 dnl Find the libiberty library. This defines many commonly used C
 dnl functions that exists in various states based on the underlying OS.
-AC_DEFUN([CYG_AC_PATH_LIBERTY], [
+AC_DEFUN(CYG_AC_PATH_LIBERTY, [
 AC_MSG_CHECKING(for the liberty library in the build tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 AC_CACHE_VAL(ac_cv_c_liberty,[
@@ -262,7 +262,7 @@ AC_SUBST(LIBERTY)
 
 dnl ====================================================================
 dnl Find the opcodes library. This is used to do dissasemblies.
-AC_DEFUN([CYG_AC_PATH_OPCODES], [
+AC_DEFUN(CYG_AC_PATH_OPCODES, [
 AC_MSG_CHECKING(for the opcodes library in the build tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 AC_CACHE_VAL(ac_cv_c_opc,[
@@ -284,7 +284,7 @@ AC_SUBST(OPCODESLIB)
 dnl ====================================================================
 dnl Look for the DejaGnu header file in the source tree. This file
 dnl defines the functions used to testing support.
-AC_DEFUN([CYG_AC_PATH_DEJAGNU], [
+AC_DEFUN(CYG_AC_PATH_DEJAGNU, [
 AC_MSG_CHECKING(for the testing support files in the source tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 AC_CACHE_VAL(ac_cv_c_dejagnu,[
@@ -335,7 +335,7 @@ AC_SUBST(DEJAGNUHDIR)
 dnl ====================================================================
 dnl Find the libintl library in the build tree. This is for
 dnl  internationalization support.
-AC_DEFUN([CYG_AC_PATH_INTL], [
+AC_DEFUN(CYG_AC_PATH_INTL, [
 AC_MSG_CHECKING(for the intl header in the build tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 dnl Look for the header file
@@ -375,7 +375,7 @@ AC_SUBST(INTLLIB)
 
 dnl ====================================================================
 dnl Find the simulator library.
-AC_DEFUN([CYG_AC_PATH_SIM], [
+AC_DEFUN(CYG_AC_PATH_SIM, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.. ../../../../../../../../../.."
 case "$target_cpu" in
     powerpc)	target_dir=ppc ;;
@@ -457,7 +457,7 @@ AC_SUBST(SIMLIB)
 
 dnl ====================================================================
 dnl Find the libiberty library.
-AC_DEFUN([CYG_AC_PATH_LIBIBERTY], [
+AC_DEFUN(CYG_AC_PATH_LIBIBERTY, [
 AC_MSG_CHECKING(for the libiberty library in the build tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 AC_CACHE_VAL(ac_cv_c_libib,[
@@ -477,7 +477,7 @@ AC_SUBST(LIBIBERTY)
 ])
 
 dnl ====================================================================
-AC_DEFUN([CYG_AC_PATH_DEVO], [
+AC_DEFUN(CYG_AC_PATH_DEVO, [
 AC_MSG_CHECKING(for devo headers in the source tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 AC_CACHE_VAL(ac_cv_c_devoh,[
@@ -498,7 +498,7 @@ AC_SUBST(DEVOHDIR)
 
 dnl ====================================================================
 dnl find the IDE library and headers.
-AC_DEFUN([CYG_AC_PATH_IDE], [
+AC_DEFUN(CYG_AC_PATH_IDE, [
 AC_MSG_CHECKING(for IDE headers in the source tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 IDEHDIR=
@@ -591,7 +591,7 @@ AC_SUBST(IDETCLLIB)
 
 dnl ====================================================================
 dnl Find all the ILU headers and libraries
-AC_DEFUN([CYG_AC_PATH_ILU], [
+AC_DEFUN(CYG_AC_PATH_ILU, [
 AC_MSG_CHECKING(for ILU kernel headers in the source tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 AC_CACHE_VAL(ac_cv_c_iluh,[
@@ -752,7 +752,7 @@ dnl ====================================
 dnl This defines the byte order for the host. We can't use
 dnl AC_C_BIGENDIAN, cause we want to create a config file and
 dnl substitue the real value, so the header files work right
-AC_DEFUN([CYG_AC_C_ENDIAN], [
+AC_DEFUN(CYG_AC_C_ENDIAN, [
 AC_MSG_CHECKING(to see if this is a little endian host)
 AC_CACHE_VAL(ac_cv_c_little_endian, [
 ac_cv_c_little_endian=unknown
@@ -788,7 +788,7 @@ dnl Yes, this is ugly, and only used for
 dnl is just to keep configure from stopping here.
 case "${host}" in
 changequote(,)
-   i[3456789]86-*-*) ac_cv_c_little_endian=yes ;;
+   i[3456]86-*-*) ac_cv_c_little_endian=yes ;;
    sparc*-*-*)    ac_cv_c_little_endian=no ;;
 changequote([,])
   *)    AC_MSG_WARN(Can't cross compile this test) ;;
@@ -809,7 +809,7 @@ AC_SUBST(ENDIAN)
 dnl ====================================================================
 dnl Look for the path to libgcc, so we can use it to directly link
 dnl in libgcc.a with LD.
-AC_DEFUN([CYG_AC_PATH_LIBGCC],
+AC_DEFUN(CYG_AC_PATH_LIBGCC,
 [AC_MSG_CHECKING([Looking for the path to libgcc.a])
 AC_LANG_SAVE
 AC_LANG_C
@@ -844,12 +844,12 @@ dnl Warning: transition of version 9 to 
 dnl because 10 sorts before 9. We also look for just tcl. We have to
 dnl be careful that we don't match stuff like tclX by accident.
 dnl the alternative search directory is involked by --with-tclinclude
-AC_DEFUN([CYG_AC_PATH_TCL], [
+AC_DEFUN(CYG_AC_PATH_TCL, [
     CYG_AC_PATH_TCLH
     CYG_AC_PATH_TCLCONFIG
     CYG_AC_LOAD_TCLCONFIG
 ])
-AC_DEFUN([CYG_AC_PATH_TCLH], [
+AC_DEFUN(CYG_AC_PATH_TCLH, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 no_tcl=true
 AC_MSG_CHECKING(for Tcl headers in the source tree)
@@ -935,7 +935,7 @@ AC_SUBST(TCLHDIR)
 
 dnl ====================================================================
 dnl Ok, lets find the tcl configuration
-AC_DEFUN([CYG_AC_PATH_TCLCONFIG], [
+AC_DEFUN(CYG_AC_PATH_TCLCONFIG, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 dnl First, look for one uninstalled.  
 dnl the alternative search directory is invoked by --with-tclconfig
@@ -1024,7 +1024,7 @@ AC_SUBST(TCLCONFIG)
 
 dnl Defined as a separate macro so we don't have to cache the values
 dnl from PATH_TCLCONFIG (because this can also be cached).
-AC_DEFUN([CYG_AC_LOAD_TCLCONFIG], [
+AC_DEFUN(CYG_AC_LOAD_TCLCONFIG, [
     . $TCLCONFIG
 
 dnl AC_SUBST(TCL_VERSION)
@@ -1070,12 +1070,12 @@ dnl    AC_SUBST(TCL_UNSHARED_LIB_SUFFIX)
 ])
 
 dnl ====================================================================
-AC_DEFUN([CYG_AC_PATH_TK], [
+AC_DEFUN(CYG_AC_PATH_TK, [
     CYG_AC_PATH_TKH
     CYG_AC_PATH_TKCONFIG
     CYG_AC_LOAD_TKCONFIG
 ])
-AC_DEFUN([CYG_AC_PATH_TKH], [
+AC_DEFUN(CYG_AC_PATH_TKH, [
 #
 # Ok, lets find the tk source trees so we can use the headers
 # If the directory (presumably symlink) named "tk" exists, use that one
@@ -1168,7 +1168,7 @@ fi
 AC_SUBST(TKHDIR)
 ])
 
-AC_DEFUN([CYG_AC_PATH_TKCONFIG], [
+AC_DEFUN(CYG_AC_PATH_TKCONFIG, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 dnl First, look for one uninstalled.  
 dnl the alternative search directory is invoked by --with-tkconfig
@@ -1257,7 +1257,7 @@ AC_SUBST(TKCONFIG)
 
 dnl Defined as a separate macro so we don't have to cache the values
 dnl from PATH_TKCONFIG (because this can also be cached).
-AC_DEFUN([CYG_AC_LOAD_TKCONFIG], [
+AC_DEFUN(CYG_AC_LOAD_TKCONFIG, [
     if test -f "$TKCONFIG" ; then
       . $TKCONFIG
     fi
@@ -1287,13 +1287,13 @@ dnl    AC_SUBST(TK_EXEC_PREFIX)
 dnl ====================================================================
 dnl Ok, lets find the itcl source trees so we can use the headers
 dnl the alternative search directory is involked by --with-itclinclude
-AC_DEFUN([CYG_AC_PATH_ITCL], [
+AC_DEFUN(CYG_AC_PATH_ITCL, [
     CYG_AC_PATH_ITCLH
     CYG_AC_PATH_ITCLLIB
     CYG_AC_PATH_ITCLSH
     CYG_AC_PATH_ITCLMKIDX
 ])
-AC_DEFUN([CYG_AC_PATH_ITCLH], [
+AC_DEFUN(CYG_AC_PATH_ITCLH, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 no_itcl=true
 AC_MSG_CHECKING(for Itcl headers in the source tree)
@@ -1367,7 +1367,7 @@ AC_SUBST(ITCLHDIR)
 dnl Ok, lets find the itcl library
 dnl First, look for one uninstalled.  
 dnl the alternative search directory is invoked by --with-itcllib
-AC_DEFUN([CYG_AC_PATH_ITCLLIB], [
+AC_DEFUN(CYG_AC_PATH_ITCLLIB, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 if test x"${no_itcl}" = x ; then
     dnl we reset no_itcl incase something fails here
@@ -1454,7 +1454,7 @@ AC_SUBST(ITCLLIB)
 dnl ====================================================================
 dnl Ok, lets find the itcl source trees so we can use the itcl_sh script
 dnl the alternative search directory is involked by --with-itclinclude
-AC_DEFUN([CYG_AC_PATH_ITCLSH], [
+AC_DEFUN(CYG_AC_PATH_ITCLSH, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 no_itcl=true
 AC_MSG_CHECKING(for the itcl_sh script)
@@ -1516,7 +1516,7 @@ AC_SUBST(ITCLSH)
 dnl ====================================================================
 dnl Ok, lets find the itcl source trees so we can use the itcl_sh script
 dnl the alternative search directory is involked by --with-itclinclude
-AC_DEFUN([CYG_AC_PATH_ITCLMKIDX], [
+AC_DEFUN(CYG_AC_PATH_ITCLMKIDX, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 no_itcl=true
 AC_MSG_CHECKING(for itcl_mkindex.tcl script)
@@ -1582,11 +1582,11 @@ AC_SUBST(ITCLMKIDX)
 dnl ====================================================================
 dnl Ok, lets find the tix source trees so we can use the headers
 dnl the alternative search directory is involked by --with-tixinclude
-AC_DEFUN([CYG_AC_PATH_TIX], [
+AC_DEFUN(CYG_AC_PATH_TIX, [
     CYG_AC_PATH_TIXH
     CYG_AC_PATH_TIXLIB
 ])
-AC_DEFUN([CYG_AC_PATH_TIXH], [
+AC_DEFUN(CYG_AC_PATH_TIXH, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 no_tix=true
 AC_MSG_CHECKING(for Tix headers in the source tree)
@@ -1663,7 +1663,7 @@ fi
 AC_SUBST(TIXHDIR)
 ])
 
-AC_DEFUN([CYG_AC_PATH_TIXCONFIG], [
+AC_DEFUN(CYG_AC_PATH_TIXCONFIG, [
 #
 # Ok, lets find the tix configuration
 # First, look for one uninstalled.  
@@ -1737,7 +1737,7 @@ fi
 
 # Defined as a separate macro so we don't have to cache the values
 # from PATH_TIXCONFIG (because this can also be cached).
-AC_DEFUN([CYG_AC_LOAD_TIXCONFIG], [
+AC_DEFUN(CYG_AC_LOAD_TIXCONFIG, [
     if test -f "$TIXCONFIG" ; then
       . $TIXCONFIG
     fi
@@ -1746,7 +1746,7 @@ AC_DEFUN([CYG_AC_LOAD_TIXCONFIG], [
     AC_SUBST(TIX_LIB_FULL_PATH)
 ])
 
-AC_DEFUN([CYG_AC_PATH_ITCLCONFIG], [
+AC_DEFUN(CYG_AC_PATH_ITCLCONFIG, [
 #
 # Ok, lets find the itcl configuration
 # First, look for one uninstalled.  
@@ -1820,7 +1820,7 @@ fi
 
 # Defined as a separate macro so we don't have to cache the values
 # from PATH_ITCLCONFIG (because this can also be cached).
-AC_DEFUN([CYG_AC_LOAD_ITCLCONFIG], [
+AC_DEFUN(CYG_AC_LOAD_ITCLCONFIG, [
     if test -f "$ITCLCONFIG" ; then
       . $ITCLCONFIG
     fi
@@ -1833,7 +1833,7 @@ AC_DEFUN([CYG_AC_LOAD_ITCLCONFIG], [
 ])
 
 
-AC_DEFUN([CYG_AC_PATH_ITKCONFIG], [
+AC_DEFUN(CYG_AC_PATH_ITKCONFIG, [
 #
 # Ok, lets find the itk configuration
 # First, look for one uninstalled.  
@@ -1907,7 +1907,7 @@ fi
 
 # Defined as a separate macro so we don't have to cache the values
 # from PATH_ITKCONFIG (because this can also be cached).
-AC_DEFUN([CYG_AC_LOAD_ITKCONFIG], [
+AC_DEFUN(CYG_AC_LOAD_ITKCONFIG, [
     if test -f "$ITKCONFIG" ; then
       . $ITKCONFIG
     fi
@@ -1921,11 +1921,11 @@ AC_DEFUN([CYG_AC_LOAD_ITKCONFIG], [
 dnl ====================================================================
 dnl Ok, lets find the libgui source trees so we can use the headers
 dnl the alternative search directory is involked by --with-libguiinclude
-AC_DEFUN([CYG_AC_PATH_LIBGUI], [
+AC_DEFUN(CYG_AC_PATH_LIBGUI, [
     CYG_AC_PATH_LIBGUIH
     CYG_AC_PATH_LIBGUILIB
 ])
-AC_DEFUN([CYG_AC_PATH_LIBGUIH], [
+AC_DEFUN(CYG_AC_PATH_LIBGUIH, [
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../..../../../../../../../../../../.."
 no_libgui=true
 AC_MSG_CHECKING(for Libgui headers in the source tree)
@@ -1995,7 +1995,7 @@ AC_SUBST(LIBGUIHDIR)
 
 dnl ====================================================================
 dnl find the GUI library
-AC_DEFUN([CYG_AC_PATH_LIBGUILIB], [
+AC_DEFUN(CYG_AC_PATH_LIBGUILIB, [
 AC_MSG_CHECKING(for GUI library  in the build tree)
 dirlist=".. ../../ ../../../ ../../../../ ../../../../../ ../../../../../../ ../../../../../../.. ../../../../../../../.. ../../../../../../../../.. ../../../../../../../../../.."
 dnl look for the library
diff -urp --unidirectional-new-file binutils-2.15/config/mh-cxux binutils-freebsd/config/mh-cxux
--- binutils-2.15/config/mh-cxux	2002-12-28 02:09:15.000000000 -0500
+++ binutils-freebsd/config/mh-cxux	2002-10-11 01:59:53.000000000 -0400
@@ -1,5 +1,7 @@
 # Configuration for Harris CX/UX 7 (and maybe 6), based on sysv4 configuration.
 
+RANLIB = true
+
 # The l flag generates a warning from the SVR4 archiver, remove it.
 AR_FLAGS = cq
 
diff -urp --unidirectional-new-file binutils-2.15/config/mh-necv4 binutils-freebsd/config/mh-necv4
--- binutils-2.15/config/mh-necv4	2002-12-28 02:09:15.000000000 -0500
+++ binutils-freebsd/config/mh-necv4	2002-10-11 01:59:53.000000000 -0400
@@ -1,4 +1,6 @@
 # Host Makefile fragment for NEC MIPS SVR4.
 
+RANLIB = true
+
 # NEC -lX11 needs some other libraries.
 X11_EXTRA_LIBS = -lsocket -lnsl
diff -urp --unidirectional-new-file binutils-2.15/config/mh-openedition binutils-freebsd/config/mh-openedition
--- binutils-2.15/config/mh-openedition	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mh-openedition	2002-10-11 01:59:53.000000000 -0400
@@ -0,0 +1 @@
+RANLIB = true
diff -urp --unidirectional-new-file binutils-2.15/config/mh-sco binutils-freebsd/config/mh-sco
--- binutils-2.15/config/mh-sco	2002-12-28 02:09:15.000000000 -0500
+++ binutils-freebsd/config/mh-sco	2002-10-11 01:59:53.000000000 -0400
@@ -1,3 +1,4 @@
+RANLIB = true
 # You may need this if you don't have bison.
 # BISON = yacc -Sm10400
 
diff -urp --unidirectional-new-file binutils-2.15/config/mh-solaris binutils-freebsd/config/mh-solaris
--- binutils-2.15/config/mh-solaris	2002-12-28 02:09:15.000000000 -0500
+++ binutils-freebsd/config/mh-solaris	2002-10-11 01:59:53.000000000 -0400
@@ -1,2 +1,5 @@
 # Makefile changes for Suns running Solaris 2
+
+RANLIB = true
+
 X11_EXTRA_LIBS = -lnsl -lsocket
diff -urp --unidirectional-new-file binutils-2.15/config/mh-sysv binutils-freebsd/config/mh-sysv
--- binutils-2.15/config/mh-sysv	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mh-sysv	2002-10-11 01:59:53.000000000 -0400
@@ -0,0 +1 @@
+RANLIB = true
diff -urp --unidirectional-new-file binutils-2.15/config/mh-sysv4 binutils-freebsd/config/mh-sysv4
--- binutils-2.15/config/mh-sysv4	2002-12-28 02:09:15.000000000 -0500
+++ binutils-freebsd/config/mh-sysv4	2002-10-11 01:59:53.000000000 -0400
@@ -1,3 +1,5 @@
+RANLIB = true
+
 # The l flag generates a warning from the SVR4 archiver, remove it.
 AR_FLAGS = cr
 
diff -urp --unidirectional-new-file binutils-2.15/config/mh-sysv5 binutils-freebsd/config/mh-sysv5
--- binutils-2.15/config/mh-sysv5	2002-12-28 02:09:15.000000000 -0500
+++ binutils-freebsd/config/mh-sysv5	2002-10-11 01:59:53.000000000 -0400
@@ -1,3 +1,5 @@
+RANLIB = true
+
 # The l flag generates a warning from the SVR4 archiver, remove it.
 AR_FLAGS = cr
 
diff -urp --unidirectional-new-file binutils-2.15/config/mt-armpic binutils-freebsd/config/mt-armpic
--- binutils-2.15/config/mt-armpic	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mt-armpic	2000-05-12 19:14:48.000000000 -0400
@@ -0,0 +1 @@
+PICFLAG_FOR_TARGET=-fPIC
diff -urp --unidirectional-new-file binutils-2.15/config/mt-elfalphapic binutils-freebsd/config/mt-elfalphapic
--- binutils-2.15/config/mt-elfalphapic	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mt-elfalphapic	1998-09-06 18:56:59.000000000 -0400
@@ -0,0 +1 @@
+PICFLAG_FOR_TARGET=-fPIC
diff -urp --unidirectional-new-file binutils-2.15/config/mt-ia64pic binutils-freebsd/config/mt-ia64pic
--- binutils-2.15/config/mt-ia64pic	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mt-ia64pic	2001-11-01 04:23:55.000000000 -0500
@@ -0,0 +1 @@
+PICFLAG_FOR_TARGET=-fpic
diff -urp --unidirectional-new-file binutils-2.15/config/mt-papic binutils-freebsd/config/mt-papic
--- binutils-2.15/config/mt-papic	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mt-papic	1998-03-01 17:56:49.000000000 -0500
@@ -0,0 +1 @@
+PICFLAG_FOR_TARGET=-fPIC
diff -urp --unidirectional-new-file binutils-2.15/config/mt-ppcpic binutils-freebsd/config/mt-ppcpic
--- binutils-2.15/config/mt-ppcpic	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mt-ppcpic	2000-05-12 19:14:51.000000000 -0400
@@ -0,0 +1 @@
+PICFLAG_FOR_TARGET=-fPIC
diff -urp --unidirectional-new-file binutils-2.15/config/mt-s390pic binutils-freebsd/config/mt-s390pic
--- binutils-2.15/config/mt-s390pic	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mt-s390pic	2002-07-05 16:14:35.000000000 -0400
@@ -0,0 +1 @@
+PICFLAG_FOR_TARGET=-fpic
diff -urp --unidirectional-new-file binutils-2.15/config/mt-sparcpic binutils-freebsd/config/mt-sparcpic
--- binutils-2.15/config/mt-sparcpic	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mt-sparcpic	2001-05-28 01:20:04.000000000 -0400
@@ -0,0 +1 @@
+PICFLAG_FOR_TARGET=`case '${LIBCFLAGS} ${LIBCXXFLAGS}' in *-fpic* ) echo -fpic ;; * ) echo -fPIC ;; esac`
diff -urp --unidirectional-new-file binutils-2.15/config/mt-v810 binutils-freebsd/config/mt-v810
--- binutils-2.15/config/mt-v810	2002-12-28 02:09:15.000000000 -0500
+++ binutils-freebsd/config/mt-v810	1998-03-01 17:56:49.000000000 -0500
@@ -1,3 +1,4 @@
 CC_FOR_TARGET = ca732 -ansi
 AS_FOR_TARGET = as732
 AR_FOR_TARGET = ar732
+RANLIB_FOR_TARGET = true
diff -urp --unidirectional-new-file binutils-2.15/config/mt-x86pic binutils-freebsd/config/mt-x86pic
--- binutils-2.15/config/mt-x86pic	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/config/mt-x86pic	1998-03-01 17:56:49.000000000 -0500
@@ -0,0 +1 @@
+PICFLAG_FOR_TARGET=-fpic
diff -urp --unidirectional-new-file binutils-2.15/configure.in binutils-freebsd/configure.in
--- binutils-2.15/configure.in	2004-05-17 15:40:54.000000000 -0400
+++ binutils-freebsd/configure.in	2004-06-16 01:44:00.000000000 -0400
@@ -133,7 +133,7 @@ host_libs="intl mmalloc libiberty opcode
 # know that we are building the simulator.
 # binutils, gas and ld appear in that order because it makes sense to run
 # "make check" in that particular order.
-host_tools="byacc flex bison binutils gas ld gcc sid sim gdb make patch prms send-pr gprof etc expect dejagnu ash bash bzip2 m4 autoconf automake libtool diff rcs fileutils shellutils time textutils wdiff find uudecode hello tar gzip indent recode release sed utils guile perl gawk findutils gettext zip fastjar"
+host_tools="texinfo byacc flex bison binutils gas ld gcc sid sim gdb make patch prms send-pr gprof etc expect dejagnu ash bash bzip2 m4 autoconf automake libtool diff rcs fileutils shellutils time textutils wdiff find uudecode hello tar gzip indent recode release sed utils guile perl gawk findutils gettext zip fastjar"
 
 # libgcj represents the runtime libraries only used by gcj.
 libgcj="target-libffi \
diff -urp --unidirectional-new-file binutils-2.15/contrib/texi2pod.pl binutils-freebsd/contrib/texi2pod.pl
--- binutils-2.15/contrib/texi2pod.pl	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/contrib/texi2pod.pl	2002-10-11 01:59:53.000000000 -0400
@@ -0,0 +1,431 @@
+#! /usr/bin/perl -w
+
+#   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+
+# This file is part of GNU CC.
+
+# GNU CC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# GNU CC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with GNU CC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 59 Temple Place - Suite 330,
+# Boston MA 02111-1307, USA.
+
+# This does trivial (and I mean _trivial_) conversion of Texinfo
+# markup to Perl POD format.  It's intended to be used to extract
+# something suitable for a manpage from a Texinfo document.
+
+$output = 0;
+$skipping = 0;
+%sects = ();
+$section = "";
+@icstack = ();
+@endwstack = ();
+@skstack = ();
+@instack = ();
+$shift = "";
+%defs = ();
+$fnno = 1;
+$inf = "";
+$ibase = "";
+
+while ($_ = shift) {
+    if (/^-D(.*)$/) {
+	if ($1 ne "") {
+	    $flag = $1;
+	} else {
+	    $flag = shift;
+	}
+	$value = "";
+	($flag, $value) = ($flag =~ /^([^=]+)(?:=(.+))?/);
+	die "no flag specified for -D\n"
+	    unless $flag ne "";
+	die "flags may only contain letters, digits, hyphens, dashes and underscores\n"
+	    unless $flag =~ /^[a-zA-Z0-9_-]+$/;
+	$defs{$flag} = $value;
+    } elsif (/^-/) {
+	usage();
+    } else {
+	$in = $_, next unless defined $in;
+	$out = $_, next unless defined $out;
+	usage();
+    }
+}
+
+if (defined $in) {
+    $inf = gensym();
+    open($inf, "<$in") or die "opening \"$in\": $!\n";
+    $ibase = $1 if $in =~ m|^(.+)/[^/]+$|;
+} else {
+    $inf = \*STDIN;
+}
+
+if (defined $out) {
+    open(STDOUT, ">$out") or die "opening \"$out\": $!\n";
+}
+
+while(defined $inf) {
+while(<$inf>) {
+    # Certain commands are discarded without further processing.
+    /^\@(?:
+	 [a-z]+index		# @*index: useful only in complete manual
+	 |need			# @need: useful only in printed manual
+	 |(?:end\s+)?group	# @group .. @end group: ditto
+	 |page			# @page: ditto
+	 |node			# @node: useful only in .info file
+	 |(?:end\s+)?ifnottex   # @ifnottex .. @end ifnottex: use contents
+	)\b/x and next;
+
+    chomp;
+
+    # Look for filename and title markers.
+    /^\@setfilename\s+([^.]+)/ and $fn = $1, next;
+    /^\@settitle\s+([^.]+)/ and $tl = postprocess($1), next;
+
+    # Identify a man title but keep only the one we are interested in.
+    /^\@c\s+man\s+title\s+([A-Za-z0-9-]+)\s+(.+)/ and do {
+	if (exists $defs{$1}) {
+	    $fn = $1;
+	    $tl = postprocess($2);
+	}
+	next;
+    };
+
+    # Look for blocks surrounded by @c man begin SECTION ... @c man end.
+    # This really oughta be @ifman ... @end ifman and the like, but such
+    # would require rev'ing all other Texinfo translators.
+    /^\@c\s+man\s+begin\s+([A-Z]+)\s+([A-Za-z0-9-]+)/ and do {
+	$output = 1 if exists $defs{$2};
+        $sect = $1;
+	next;
+    };
+    /^\@c\s+man\s+begin\s+([A-Z]+)/ and $sect = $1, $output = 1, next;
+    /^\@c\s+man\s+end/ and do {
+	$sects{$sect} = "" unless exists $sects{$sect};
+	$sects{$sect} .= postprocess($section);
+	$section = "";
+	$output = 0;
+	next;
+    };
+
+    # handle variables
+    /^\@set\s+([a-zA-Z0-9_-]+)\s*(.*)$/ and do {
+	$defs{$1} = $2;
+	next;
+    };
+    /^\@clear\s+([a-zA-Z0-9_-]+)/ and do {
+	delete $defs{$1};
+	next;
+    };
+
+    next unless $output;
+
+    # Discard comments.  (Can't do it above, because then we'd never see
+    # @c man lines.)
+    /^\@c\b/ and next;
+
+    # End-block handler goes up here because it needs to operate even
+    # if we are skipping.
+    /^\@end\s+([a-z]+)/ and do {
+	# Ignore @end foo, where foo is not an operation which may
+	# cause us to skip, if we are presently skipping.
+	my $ended = $1;
+	next if $skipping && $ended !~ /^(?:ifset|ifclear|ignore|menu|iftex)$/;
+
+	die "\@end $ended without \@$ended at line $.\n" unless defined $endw;
+	die "\@$endw ended by \@end $ended at line $.\n" unless $ended eq $endw;
+
+	$endw = pop @endwstack;
+
+	if ($ended =~ /^(?:ifset|ifclear|ignore|menu|iftex)$/) {
+	    $skipping = pop @skstack;
+	    next;
+	} elsif ($ended =~ /^(?:example|smallexample|display)$/) {
+	    $shift = "";
+	    $_ = "";	# need a paragraph break
+	} elsif ($ended =~ /^(?:itemize|enumerate|[fv]?table)$/) {
+	    $_ = "\n=back\n";
+	    $ic = pop @icstack;
+	} else {
+	    die "unknown command \@end $ended at line $.\n";
+	}
+    };
+
+    # We must handle commands which can cause skipping even while we
+    # are skipping, otherwise we will not process nested conditionals
+    # correctly.
+    /^\@ifset\s+([a-zA-Z0-9_-]+)/ and do {
+	push @endwstack, $endw;
+	push @skstack, $skipping;
+	$endw = "ifset";
+	$skipping = 1 unless exists $defs{$1};
+	next;
+    };
+
+    /^\@ifclear\s+([a-zA-Z0-9_-]+)/ and do {
+	push @endwstack, $endw;
+	push @skstack, $skipping;
+	$endw = "ifclear";
+	$skipping = 1 if exists $defs{$1};
+	next;
+    };
+
+    /^\@(ignore|menu|iftex)\b/ and do {
+	push @endwstack, $endw;
+	push @skstack, $skipping;
+	$endw = $1;
+	$skipping = 1;
+	next;
+    };
+
+    next if $skipping;
+
+    # Character entities.  First the ones that can be replaced by raw text
+    # or discarded outright:
+    s/\@copyright\{\}/(c)/g;
+    s/\@dots\{\}/.../g;
+    s/\@enddots\{\}/..../g;
+    s/\@([.!? ])/$1/g;
+    s/\@[:-]//g;
+    s/\@bullet(?:\{\})?/*/g;
+    s/\@TeX\{\}/TeX/g;
+    s/\@pounds\{\}/\#/g;
+    s/\@minus(?:\{\})?/-/g;
+    s/\\,/,/g;
+
+    # Now the ones that have to be replaced by special escapes
+    # (which will be turned back into text by unmunge())
+    s/&/&amp;/g;
+    s/\@\{/&lbrace;/g;
+    s/\@\}/&rbrace;/g;
+    s/\@\@/&at;/g;
+
+    # Inside a verbatim block, handle @var specially.
+    if ($shift ne "") {
+	s/\@var\{([^\}]*)\}/<$1>/g;
+    }
+
+    # POD doesn't interpret E<> inside a verbatim block.
+    if ($shift eq "") {
+	s/</&lt;/g;
+	s/>/&gt;/g;
+    } else {
+	s/</&LT;/g;
+	s/>/&GT;/g;
+    }
+
+    # Single line command handlers.
+
+    /^\@include\s+(.+)$/ and do {
+	push @instack, $inf;
+	$inf = gensym();
+
+	# Try cwd and $ibase.
+	open($inf, "<" . $1) 
+	    or open($inf, "<" . $ibase . "/" . $1)
+		or die "cannot open $1 or $ibase/$1: $!\n";
+	next;
+    };
+
+    /^\@(?:section|unnumbered|unnumberedsec|center)\s+(.+)$/
+	and $_ = "\n=head2 $1\n";
+    /^\@subsection\s+(.+)$/
+	and $_ = "\n=head3 $1\n";
+
+    # Block command handlers:
+    /^\@itemize\s+(\@[a-z]+|\*|-)/ and do {
+	push @endwstack, $endw;
+	push @icstack, $ic;
+	$ic = $1;
+	$_ = "\n=over 4\n";
+	$endw = "itemize";
+    };
+
+    /^\@enumerate(?:\s+([a-zA-Z0-9]+))?/ and do {
+	push @endwstack, $endw;
+	push @icstack, $ic;
+	if (defined $1) {
+	    $ic = $1 . ".";
+	} else {
+	    $ic = "1.";
+	}
+	$_ = "\n=over 4\n";
+	$endw = "enumerate";
+    };
+
+    /^\@([fv]?table)\s+(\@[a-z]+)/ and do {
+	push @endwstack, $endw;
+	push @icstack, $ic;
+	$endw = $1;
+	$ic = $2;
+	$ic =~ s/\@(?:samp|strong|key|gcctabopt|env)/B/;
+	$ic =~ s/\@(?:code|kbd)/C/;
+	$ic =~ s/\@(?:dfn|var|emph|cite|i)/I/;
+	$ic =~ s/\@(?:file)/F/;
+	$_ = "\n=over 4\n";
+    };
+
+    /^\@((?:small)?example|display)/ and do {
+	push @endwstack, $endw;
+	$endw = $1;
+	$shift = "\t";
+	$_ = "";	# need a paragraph break
+    };
+
+    /^\@itemx?\s*(.+)?$/ and do {
+	if (defined $1) {
+	    # Entity escapes prevent munging by the <> processing below.
+	    $_ = "\n=item $ic\&LT;$1\&GT;\n";
+	} else {
+	    $_ = "\n=item $ic\n";
+	    $ic =~ y/A-Ya-y/B-Zb-z/;
+	    $ic =~ s/(\d+)/$1 + 1/eg;
+	}
+    };
+
+    $section .= $shift.$_."\n";
+}
+# End of current file.
+close($inf);
+$inf = pop @instack;
+}
+
+die "No filename or title\n" unless defined $fn && defined $tl;
+
+$sects{NAME} = "$fn \- $tl\n";
+$sects{FOOTNOTES} .= "=back\n" if exists $sects{FOOTNOTES};
+
+for $sect (qw(NAME SYNOPSIS DESCRIPTION OPTIONS ENVIRONMENT FILES
+	      BUGS NOTES FOOTNOTES SEEALSO AUTHOR COPYRIGHT)) {
+    if(exists $sects{$sect}) {
+	$head = $sect;
+	$head =~ s/SEEALSO/SEE ALSO/;
+	print "=head1 $head\n\n";
+	print scalar unmunge ($sects{$sect});
+	print "\n";
+    }
+}
+
+sub usage
+{
+    die "usage: $0 [-D toggle...] [infile [outfile]]\n";
+}
+
+sub postprocess
+{
+    local $_ = $_[0];
+
+    # @value{foo} is replaced by whatever 'foo' is defined as.
+    while (m/(\@value\{([a-zA-Z0-9_-]+)\})/g) {
+	if (! exists $defs{$2}) {
+	    print STDERR "Option $2 not defined\n";
+	    s/\Q$1\E//;
+	} else {
+	    $value = $defs{$2};
+	    s/\Q$1\E/$value/;
+	}
+    }
+
+    # Formatting commands.
+    # Temporary escape for @r.
+    s/\@r\{([^\}]*)\}/R<$1>/g;
+    s/\@(?:dfn|var|emph|cite|i)\{([^\}]*)\}/I<$1>/g;
+    s/\@(?:code|kbd)\{([^\}]*)\}/C<$1>/g;
+    s/\@(?:gccoptlist|samp|strong|key|option|env|command|b)\{([^\}]*)\}/B<$1>/g;
+    s/\@sc\{([^\}]*)\}/\U$1/g;
+    s/\@file\{([^\}]*)\}/F<$1>/g;
+    s/\@w\{([^\}]*)\}/S<$1>/g;
+    s/\@(?:dmn|math)\{([^\}]*)\}/$1/g;
+
+    # Cross references are thrown away, as are @noindent and @refill.
+    # (@noindent is impossible in .pod, and @refill is unnecessary.)
+    # @* is also impossible in .pod; we discard it and any newline that
+    # follows it.  Similarly, our macro @gol must be discarded.
+
+    s/\(?\@xref\{(?:[^\}]*)\}(?:[^.<]|(?:<[^<>]*>))*\.\)?//g;
+    s/\s+\(\@pxref\{(?:[^\}]*)\}\)//g;
+    s/;\s+\@pxref\{(?:[^\}]*)\}//g;
+    s/\@noindent\s*//g;
+    s/\@refill//g;
+    s/\@gol//g;
+    s/\@\*\s*\n?//g;
+
+    # @uref can take one, two, or three arguments, with different
+    # semantics each time.  @url and @email are just like @uref with
+    # one argument, for our purposes.
+    s/\@(?:uref|url|email)\{([^\},]*)\}/&lt;B<$1>&gt;/g;
+    s/\@uref\{([^\},]*),([^\},]*)\}/$2 (C<$1>)/g;
+    s/\@uref\{([^\},]*),([^\},]*),([^\},]*)\}/$3/g;
+
+    # Un-escape <> at this point.
+    s/&LT;/</g;
+    s/&GT;/>/g;
+
+    # Now un-nest all B<>, I<>, R<>.  Theoretically we could have
+    # indefinitely deep nesting; in practice, one level suffices.
+    1 while s/([BIR])<([^<>]*)([BIR])<([^<>]*)>/$1<$2>$3<$4>$1</g;
+
+    # Replace R<...> with bare ...; eliminate empty markup, B<>;
+    # shift white space at the ends of [BI]<...> expressions outside
+    # the expression.
+    s/R<([^<>]*)>/$1/g;
+    s/[BI]<>//g;
+    s/([BI])<(\s+)([^>]+)>/$2$1<$3>/g;
+    s/([BI])<([^>]+?)(\s+)>/$1<$2>$3/g;
+
+    # Extract footnotes.  This has to be done after all other
+    # processing because otherwise the regexp will choke on formatting
+    # inside @footnote.
+    while (/\@footnote/g) {
+	s/\@footnote\{([^\}]+)\}/[$fnno]/;
+	add_footnote($1, $fnno);
+	$fnno++;
+    }
+
+    return $_;
+}
+
+sub unmunge
+{
+    # Replace escaped symbols with their equivalents.
+    local $_ = $_[0];
+
+    s/&lt;/E<lt>/g;
+    s/&gt;/E<gt>/g;
+    s/&lbrace;/\{/g;
+    s/&rbrace;/\}/g;
+    s/&at;/\@/g;
+    s/&amp;/&/g;
+    return $_;
+}
+
+sub add_footnote
+{
+    unless (exists $sects{FOOTNOTES}) {
+	$sects{FOOTNOTES} = "\n=over 4\n\n";
+    }
+
+    $sects{FOOTNOTES} .= "=item $fnno.\n\n"; $fnno++;
+    $sects{FOOTNOTES} .= $_[0];
+    $sects{FOOTNOTES} .= "\n\n";
+}
+
+# stolen from Symbol.pm
+{
+    my $genseq = 0;
+    sub gensym
+    {
+	my $name = "GEN" . $genseq++;
+	my $ref = \*{$name};
+	delete $::{$name};
+	return $ref;
+    }
+}
diff -urp --unidirectional-new-file binutils-2.15/gas/config/obj-generic.c binutils-freebsd/gas/config/obj-generic.c
--- binutils-2.15/gas/config/obj-generic.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/gas/config/obj-generic.c	1998-03-01 17:57:47.000000000 -0500
@@ -0,0 +1,41 @@
+/* This file is obj-generic.c and is intended to be a template for
+   object format specific source files.
+
+   Copyright (C) 1987-1992 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* Chars that can be used to separate mant from exp in floating point nums */
+char EXP_CHARS[] = "eE";
+
+/* Chars that mean this number is a floating point constant */
+/* As in 0f12.456 */
+/* or    0d1.2345e12 */
+char FLT_CHARS[] = "rRsSfFdDxXpP";
+
+/* These chars start a comment anywhere in a source file (except inside
+   another comment */
+const char comment_chars[] = "#";
+
+/*
+ * Local Variables:
+ * comment-column: 0
+ * fill-column: 131
+ * End:
+ */
+
+/* end of obj-generic.c */
diff -urp --unidirectional-new-file binutils-2.15/gas/config/obj-generic.h binutils-freebsd/gas/config/obj-generic.h
--- binutils-2.15/gas/config/obj-generic.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/gas/config/obj-generic.h	2001-06-26 12:57:04.000000000 -0400
@@ -0,0 +1,79 @@
+/* This file is obj-generic.h
+   Copyright 1987, 1988, 1989, 1990, 1991, 1992, 1993, 2000
+   Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+/*
+ * This file is obj-generic.h and is intended to be a template for
+ * object format specific header files.
+ */
+
+/* define an obj specific macro off which target cpu back ends may key.  */
+#define OBJ_GENERIC 1
+
+/* include whatever target cpu is appropriate.  */
+#include "targ-cpu.h"
+
+/*
+ * SYMBOLS
+ */
+
+/*
+ * If your object format needs to reorder symbols, define this.  When
+ * defined, symbols are kept on a doubly linked list and functions are
+ * made available for push, insert, append, and delete.  If not defined,
+ * symbols are kept on a singly linked list, only the append and clear
+ * facilities are available, and they are macros.
+ */
+
+/* #define SYMBOLS_NEED_PACKPOINTERS */
+
+/*  */
+typedef struct
+  {
+    void *nothing;
+  }
+
+obj_symbol_type;		/* should be the format's symbol structure */
+
+typedef void *object_headers;
+
+/* symbols have names */
+#define S_GET_NAME(s)		("foo")	/* get the name of a symbolP */
+#define S_SET_NAME(s,v)		;
+/* symbols have segments */
+#define S_GET_SEGMENT(s)	(SEG_UNKNOWN)
+#define S_SET_SEGMENT(s,v)	;
+/* symbols may be external */
+#define S_IS_EXTERNAL(s)	(0)
+#define S_SET_EXTERNAL(s)	;
+
+/* symbols may or may not be defined */
+#define S_IS_DEFINED(s)		(0)
+
+#define DEFAULT_MAGIC_NUMBER_FOR_OBJECT_FILE (0)	/* your magic number */
+
+#define OBJ_EMIT_LINENO(a,b,c)	/* must be *something*.  This no-op's it out.  */
+
+/*
+ * Local Variables:
+ * comment-column: 0
+ * fill-column: 131
+ * End:
+ */
diff -urp --unidirectional-new-file binutils-2.15/gas/doc/gasp.texi binutils-freebsd/gas/doc/gasp.texi
--- binutils-2.15/gas/doc/gasp.texi	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/gas/doc/gasp.texi	2002-10-11 03:06:21.000000000 -0400
@@ -0,0 +1,1456 @@
+\input texinfo               @c             -*- Texinfo -*-
+@setfilename gasp.info
+@c
+@c This file documents the assembly preprocessor "GASP"
+@c
+@c Copyright 1994, 1995, 2000, 2002 Free Software Foundation, Inc.
+@c
+@c    Permission is granted to copy, distribute and/or modify this document
+@c    under the terms of the GNU Free Documentation License, Version 1.1
+@c    or any later version published by the Free Software Foundation;
+@c    with no Invariant Sections, with no Front-Cover Texts, and with no
+@c    Back-Cover Texts.  A copy of the license is included in the
+@c    section entitled "GNU Free Documentation License".
+
+@ifinfo
+@format
+START-INFO-DIR-ENTRY
+* gasp: (gasp).                     The GNU Assembler Preprocessor
+END-INFO-DIR-ENTRY
+@end format
+@end ifinfo
+
+@syncodeindex ky cp
+@syncodeindex fn cp
+
+@finalout
+@setchapternewpage odd
+@settitle GASP
+@titlepage
+@c FIXME boring title
+@title GASP, an assembly preprocessor
+@subtitle for GASP version 1
+@sp 1
+@subtitle March 1994
+@author Roland Pesch
+@page
+
+@tex
+{\parskip=0pt \hfill Cygnus Support\par
+}
+@end tex
+
+@vskip 0pt plus 1filll
+Copyright @copyright{} 1994, 1995, 2000, 2002 Free Software Foundation, Inc.
+
+      Permission is granted to copy, distribute and/or modify this document
+      under the terms of the GNU Free Documentation License, Version 1.1
+      or any later version published by the Free Software Foundation;
+      with no Invariant Sections, with no Front-Cover Texts, and with no
+      Back-Cover Texts.  A copy of the license is included in the
+      section entitled "GNU Free Documentation License".
+
+@end titlepage
+
+@ifinfo
+Copyright @copyright{} 1994, 1995, 2000, 2002 Free Software Foundation, Inc.
+
+@ignore
+Permission is granted to process this file through TeX and print the
+results, provided the printed document carries a copying permission
+notice identical to this one except for the removal of this paragraph
+(this paragraph not being relevant to the printed manual).
+@end ignore
+
+      Permission is granted to copy, distribute and/or modify this document
+      under the terms of the GNU Free Documentation License, Version 1.1
+      or any later version published by the Free Software Foundation;
+      with no Invariant Sections, with no Front-Cover Texts, and with no
+      Back-Cover Texts.  A copy of the license is included in the
+      section entitled "GNU Free Documentation License".
+
+
+@node Top
+@top GASP
+
+GASP is a preprocessor for assembly programs.
+
+This file describes version 1 of GASP.
+
+Steve Chamberlain wrote GASP; Roland Pesch wrote this manual.
+
+@menu
+* Overview::                    What is GASP?
+* Invoking GASP::               Command line options.
+* Commands::                    Preprocessor commands.
+* GNU Free Documentation License::  GNU Free Documentation License
+* Index::                       Index.
+@end menu
+@end ifinfo
+
+@node Overview
+@chapter What is GASP?
+
+The primary purpose of the @sc{gnu} assembler is to assemble the output of
+other programs---notably compilers.  When you have to hand-code
+specialized routines in assembly, that means the @sc{gnu} assembler is
+an unfriendly processor: it has no directives for macros, conditionals,
+or many other conveniences that you might expect.
+
+In some cases you can simply use the C preprocessor, or a generalized
+preprocessor like @sc{m4}; but this can be awkward, since none of these
+things are designed with assembly in mind.
+
+@sc{gasp} fills this need.  It is expressly designed to provide the
+facilities you need with hand-coded assembly code.  Implementing it as a
+preprocessor, rather than part of the assembler, allows the maximum
+flexibility: you can use it with hand-coded assembly, without paying a
+penalty of added complexity in the assembler you use for compiler
+output.
+
+@emph{Note} The use of @sc{gasp} has now been deprecated.  Anything
+that it could do can now be done by the macro facilities built into
+@sc{gas} itself.  At some point in the future the @sc{gasp} sources will
+be removed entirely from the binutils distribution.
+
+Here is a small example to give the flavor of @sc{gasp}.  This input to
+@sc{gasp}
+
+@cartouche
+@example
+        .MACRO  saveregs from=8 to=14
+count   .ASSIGNA \from
+        ! save r\from..r\to
+        .AWHILE  \&count LE \to
+        mov     r\&count,@@-sp
+count   .ASSIGNA  \&count + 1
+        .AENDW
+        .ENDM
+
+        saveregs from=12
+
+bar:    mov     #H'dead+10,r0
+foo     .SDATAC "hello"<10>
+        .END
+@end example
+@end cartouche
+
+@noindent
+generates this assembly program:
+
+@cartouche
+@example
+        ! save r12..r14
+        mov     r12,@@-sp
+        mov     r13,@@-sp
+        mov     r14,@@-sp
+
+bar:    mov     #57005+10,r0
+foo:    .byte   6,104,101,108,108,111,10
+@end example
+@end cartouche
+
+@node Invoking GASP
+@chapter Command Line Options
+
+@c FIXME!  Or is there a simpler way, calling from GAS option?
+The simplest way to use @sc{gasp} is to run it as a filter and assemble
+its output.  In Unix and its ilk, you can do this, for example:
+
+@c FIXME! GASP filename suffix convention?
+@example
+$ gasp prog.asm | as -o prog.o
+@end example
+
+Naturally, there are also a few command-line options to allow you to
+request variations on this basic theme.  Here is the full set of
+possibilities for the @sc{gasp} command line.
+
+@example
+gasp  [ -a | --alternate ]
+      [ -c @var{char} | --commentchar @var{char} ]
+      [ -d | --debug ]  [ -h | --help ] [ -M | --mri ]
+      [ -o @var{outfile} | --output @var{outfile} ]
+      [ -p | --print ]  [ -s | --copysource ]
+      [ -u | --unreasonable ]  [ -v | --version ]
+      @var{infile} @dots{}
+@end example
+
+@ftable @code
+@item @var{infile} @dots{}
+@c FIXME! Why not stdin as default infile?
+The input file names.  You must specify at least one input file; if you
+specify more, @sc{gasp} preprocesses them all, concatenating the output
+in the order you list the @var{infile} arguments.
+
+Mark the end of each input file with the preprocessor command
+@code{.END}.  @xref{Other Commands,, Miscellaneous commands}.
+
+@item -a
+@itemx --alternate
+Use alternative macro syntax.  @xref{Alternate,, Alternate macro
+syntax}, for a discussion of how this syntax differs from the default
+@sc{gasp} syntax.
+
+@cindex comment character, changing
+@cindex semicolon, as comment
+@cindex exclamation mark, as comment
+@cindex shriek, as comment
+@cindex bang, as comment
+@cindex @code{!} default comment char
+@cindex @code{;} as comment char
+@item -c '@var{char}'
+@itemx --commentchar '@var{char}'
+Use @var{char} as the comment character.  The default comment character
+is @samp{!}.  For example, to use a semicolon as the comment character,
+specify @w{@samp{-c ';'}} on the @sc{gasp} command line.  Since
+assembler command characters often have special significance to command
+shells, it is a good idea to quote or escape @var{char} when you specify
+a comment character.
+
+For the sake of simplicity, all examples in this manual use the default
+comment character @samp{!}.
+
+@item -d
+@itemx --debug
+Show debugging statistics.  In this version of @sc{gasp}, this option
+produces statistics about the string buffers that @sc{gasp} allocates
+internally.  For each defined buffersize @var{s}, @sc{gasp} shows the
+number of strings @var{n} that it allocated, with a line like this:
+
+@example
+strings size @var{s} : @var{n}
+@end example
+
+@noindent
+@sc{gasp} displays these statistics on the standard error stream, when
+done preprocessing.
+
+@item -h
+@itemx --help
+Display a summary of the @sc{gasp} command line options.
+
+@item -M
+@itemx --mri
+Use MRI compatibility mode.  Using this option causes @sc{gasp} to
+accept the syntax and pseudo-ops used by the Microtec Research
+@code{ASM68K} assembler.
+
+@item -o @var{outfile}
+@itemx --output @var{outfile}
+Write the output in a file called @var{outfile}.  If you do not use the
+@samp{-o} option, @sc{gasp} writes its output on the standard output
+stream.
+
+@item -p
+@itemx --print
+Print line numbers.  @sc{gasp} obeys this option @emph{only} if you also
+specify @samp{-s} to copy source lines to its output.  With @samp{-s
+-p}, @sc{gasp} displays the line number of each source line copied
+(immediately after the comment character at the beginning of the line).
+
+@item -s
+@itemx --copysource
+Copy the source lines to the output file.  Use this option
+to see the effect of each preprocessor line on the @sc{gasp} output.
+@sc{gasp} places a comment character (@samp{!} by default) at
+the beginning of each source line it copies, so that you can use this
+option and still assemble the result.
+
+@item -u
+@itemx --unreasonable
+Bypass ``unreasonable expansion'' limit.  Since you can define @sc{gasp}
+macros inside other macro definitions, the preprocessor normally
+includes a sanity check.  If your program requires more than 1,000
+nested expansions, @sc{gasp} normally exits with an error message.  Use
+this option to turn off this check, allowing unlimited nested
+expansions.
+
+@item -v
+@itemx --version
+Display the @sc{gasp} version number.
+@end ftable
+
+@node Commands
+@chapter Preprocessor Commands
+
+@sc{gasp} commands have a straightforward syntax that fits in well with
+assembly conventions.  In general, a command extends for a line, and may
+have up to three fields: an optional label, the command itself, and
+optional arguments to the command.  You can write commands in upper or
+lower case, though this manual shows them in upper case.  @xref{Syntax
+Details,, Details of the GASP syntax}, for more information.
+
+@menu
+* Conditionals::
+* Loops::
+* Variables::
+* Macros::
+* Data::
+* Listings::
+* Other Commands::
+* Syntax Details::
+* Alternate::
+@end menu
+
+@node Conditionals
+@section Conditional assembly
+
+The conditional-assembly directives allow you to include or exclude
+portions of an assembly depending on how a pair of expressions, or a
+pair of strings, compare.
+
+The overall structure of conditionals is familiar from many other
+contexts.  @code{.AIF} marks the start of a conditional, and precedes
+assembly for the case when the condition is true.   An optional
+@code{.AELSE} precedes assembly for the converse case, and an
+@code{.AENDI} marks the end of the condition.
+
+@c FIXME! Why doesn't -u turn off this check?
+You may nest conditionals up to a depth of 100; @sc{gasp} rejects
+nesting beyond that, because it may indicate a bug in your macro
+structure.
+
+@c FIXME! Why isn't there something like cpp's -D option?  Conditionals
+@c        would be much more useful if there were.
+Conditionals are primarily useful inside macro definitions, where you
+often need different effects depending on argument values.
+@xref{Macros,, Defining your own directives}, for details about defining
+macros.
+
+@ftable @code
+@item .AIF @var{expra} @var{cmp} @var{exprb}
+@itemx .AIF "@var{stra}" @var{cmp} "@var{strb}"
+
+The governing condition goes on the same line as the @code{.AIF}
+preprocessor command.  You may compare either two strings, or two
+expressions.
+
+When you compare strings, only two conditional @var{cmp} comparison
+operators are available: @samp{EQ} (true if @var{stra} and @var{strb}
+are identical), and @samp{NE} (the opposite).
+
+When you compare two expressions, @emph{both expressions must be
+absolute} (@pxref{Expressions,, Arithmetic expressions in GASP}).  You
+can use these @var{cmp} comparison operators with expressions:
+
+@ftable @code
+@item EQ
+Are @var{expra} and @var{exprb} equal?  (For strings, are @var{stra} and
+@var{strb} identical?)
+
+@item NE
+Are @var{expra} and @var{exprb} different?  (For strings, are @var{stra}
+and @var{strb} different?
+
+@item LT
+Is @var{expra} less than @var{exprb}?  (Not allowed for strings.)
+
+@item LE
+Is @var{expra} less than or equal to @var{exprb}?  (Not allowed for strings.)
+
+@item GT
+Is @var{expra} greater than @var{exprb}?  (Not allowed for strings.)
+
+@item GE
+Is @var{expra} greater than or equal to @var{exprb}?  (Not allowed for
+strings.)
+@end ftable
+
+@item .AELSE
+Marks the start of assembly code to be included if the condition fails.
+Optional, and only allowed within a conditional (between @code{.AIF} and
+@code{.AENDI}).
+
+@item .AENDI
+Marks the end of a conditional assembly.
+@end ftable
+
+@node Loops
+@section Repetitive sections of assembly
+
+Two preprocessor directives allow you to repeatedly issue copies of the
+same block of assembly code.
+
+@ftable @code
+@item .AREPEAT @var{aexp}
+@itemx .AENDR
+If you simply need to repeat the same block of assembly over and over a
+fixed number of times, sandwich one instance of the repeated block
+between @code{.AREPEAT} and @code{.AENDR}.  Specify the number of
+copies as @var{aexp} (which must be an absolute expression).  For
+example, this repeats two assembly statements three times in succession:
+
+@cartouche
+@example
+        .AREPEAT        3
+        rotcl   r2
+        div1    r0,r1
+        .AENDR
+@end example
+@end cartouche
+
+@item .AWHILE @var{expra} @var{cmp} @var{exprb}
+@itemx .AENDW
+@itemx .AWHILE @var{stra} @var{cmp} @var{strb}
+@itemx .AENDW
+To repeat a block of assembly depending on a conditional test, rather
+than repeating it for a specific number of times, use @code{.AWHILE}.
+@code{.AENDW} marks the end of the repeated block.  The conditional
+comparison works exactly the same way as for @code{.AIF}, with the same
+comparison operators (@pxref{Conditionals,, Conditional assembly}).
+
+Since the terms of the comparison must be absolute expression,
+@code{.AWHILE} is primarily useful within macros.  @xref{Macros,,
+Defining your own directives}.
+@end ftable
+
+@cindex loops, breaking out of
+@cindex breaking out of loops
+You can use the @code{.EXITM} preprocessor directive to break out of
+loops early (as well as to break out of macros).  @xref{Macros,,
+Defining your own directives}.
+
+@node Variables
+@section Preprocessor variables
+
+You can use variables in @sc{gasp} to represent strings, registers, or
+the results of expressions.
+
+You must distinguish two kinds of variables: 
+@enumerate
+@item
+Variables defined with @code{.EQU} or @code{.ASSIGN}.  To evaluate this
+kind of variable in your assembly output, simply mention its name.  For
+example, these two lines define and use a variable @samp{eg}:
+
+@cartouche
+@example
+eg     .EQU   FLIP-64
+       @dots{}
+       mov.l  eg,r0
+@end example
+@end cartouche
+
+@emph{Do not use} this kind of variable in conditional expressions or
+while loops; @sc{gasp} only evaluates these variables when writing
+assembly output.
+
+@item
+Variables for use during preprocessing.  You can define these
+with @code{.ASSIGNC} or @code{.ASSIGNA}.  To evaluate this
+kind of variable, write @samp{\&} before the variable name; for example,
+
+@cartouche
+@example
+opcit  .ASSIGNA  47
+       @dots{}
+       .AWHILE  \&opcit GT 0
+       @dots{}
+       .AENDW
+@end example
+@end cartouche
+
+@sc{gasp} treats macro arguments almost the same way, but to evaluate
+them you use the prefix @samp{\} rather than @samp{\&}.
+@xref{Macros,, Defining your own directives}.
+@end enumerate
+
+@ftable @code
+@item @var{pvar} .EQU @var{expr}
+@c FIXME!  Anything to beware of re GAS directive of same name?
+Assign preprocessor variable @var{pvar} the value of the expression
+@var{expr}.  There are no restrictions on redefinition; use @samp{.EQU}
+with the same @var{pvar} as often as you find it convenient.
+
+@item @var{pvar} .ASSIGN @var{expr}
+Almost the same as @code{.EQU}, save that you may not redefine
+@var{pvar} using @code{.ASSIGN} once it has a value.
+@c FIXME!!  Supposed to work this way, apparently, but on 9feb94 works
+@c          just like .EQU
+
+@item @var{pvar} .ASSIGNA @var{aexpr}
+Define a variable with a numeric value, for use during preprocessing.
+@var{aexpr} must be an absolute expression.  You can redefine variables
+with @code{.ASSIGNA} at any time.
+
+@item @var{pvar} .ASSIGNC "@var{str}"
+Define a variable with a string value, for use during preprocessing.
+You can redefine variables with @code{.ASSIGNC} at any time.
+
+@item @var{pvar} .REG (@var{register})
+Use @code{.REG} to define a variable that represents a register.  In
+particular, @var{register} is @emph{not evaluated} as an expression.
+You may use @code{.REG} at will to redefine register variables.
+@end ftable
+
+All these directives accept the variable name in the ``label'' position,
+that is at the left margin.  You may specify a colon after the variable
+name if you wish; the first example above could have started @samp{eg:}
+with the same effect.
+
+@c pagebreak makes for better aesthetics---ensures macro and expansion together
+@page
+@node Macros
+@section Defining your own directives
+
+The commands @code{.MACRO} and @code{.ENDM} allow you to define macros
+that generate assembly output.  You can use these macros with a syntax
+similar to built-in @sc{gasp} or assembler directives.  For example,
+this definition specifies a macro @code{SUM} that adds together a range of
+consecutive registers:
+
+@cartouche
+@example
+        .MACRO  SUM FROM=0, TO=9
+        ! \FROM \TO
+        mov     r\FROM,r10
+COUNT   .ASSIGNA        \FROM+1
+        .AWHILE \&COUNT LE \TO
+        add     r\&COUNT,r10
+COUNT   .ASSIGNA        \&COUNT+1
+        .AENDW
+        .ENDM
+@end example
+@end cartouche
+
+@noindent
+With that definition, @samp{SUM 0,5} generates this assembly output:
+
+@cartouche
+@example
+        ! 0 5
+        mov     r0,r10
+        add     r1,r10
+        add     r2,r10
+        add     r3,r10
+        add     r4,r10
+        add     r5,r10
+@end example
+@end cartouche
+
+@ftable @code
+@item .MACRO @var{macname}
+@itemx .MACRO @var{macname} @var{macargs} @dots{}
+Begin the definition of a macro called @var{macname}.  If your macro
+definition requires arguments, specify their names after the macro name,
+separated by commas or spaces.  You can supply a default value for any
+macro argument by following the name with @samp{=@var{deflt}}.  For
+example, these are all valid @code{.MACRO} statements:
+
+@table @code
+@item .MACRO COMM
+Begin the definition of a macro called @code{COMM}, which takes no
+arguments.
+
+@item .MACRO PLUS1 P, P1
+@itemx .MACRO PLUS1 P P1
+Either statement begins the definition of a macro called @code{PLUS1},
+which takes two arguments; within the macro definition, write
+@samp{\P} or @samp{\P1} to evaluate the arguments.
+
+@item .MACRO RESERVE_STR P1=0 P2
+Begin the definition of a macro called @code{RESERVE_STR}, with two
+arguments.  The first argument has a default value, but not the second.
+After the definition is complete, you can call the macro either as
+@samp{RESERVE_STR @var{a},@var{b}} (with @samp{\P1} evaluating to
+@var{a} and @samp{\P2} evaluating to @var{b}), or as @samp{RESERVE_STR
+,@var{b}} (with @samp{\P1} evaluating as the default, in this case
+@samp{0}, and @samp{\P2} evaluating to @var{b}).
+@end table
+
+When you call a macro, you can specify the argument values either by
+position, or by keyword.  For example, @samp{SUM 9,17} is equivalent to
+@samp{SUM TO=17, FROM=9}.  Macro arguments are preprocessor variables
+similar to the variables you define with @samp{.ASSIGNA} or
+@samp{.ASSIGNC}; in particular, you can use them in conditionals or for
+loop control.  (The only difference is the prefix you write to evaluate
+the variable: for a macro argument, write @samp{\@var{argname}}, but for
+a preprocessor variable, write @samp{\&@var{varname}}.)
+
+@item @var{name} .MACRO
+@itemx @var{name} .MACRO ( @var{macargs} @dots{} )
+@c FIXME check: I think no error _and_ no args recognized if I use form
+@c       NAME  .MACRO   ARG ARG
+An alternative form of introducing a macro definition: specify the macro
+name in the label position, and the arguments (if any) between
+parentheses after the name.  Defaulting rules and usage work the same
+way as for the other macro definition syntax.
+
+@item .ENDM
+Mark the end of a macro definition.
+
+@item .EXITM
+Exit early from the current macro definition, @code{.AREPEAT} loop, or
+@code{.AWHILE} loop.
+
+@cindex number of macros executed
+@cindex macros, count executed
+@item \@@
+@sc{gasp} maintains a counter of how many macros it has
+executed in this pseudo-variable; you can copy that number to your
+output with @samp{\@@}, but @emph{only within a macro definition}.
+
+@item LOCAL @var{name} [ , @dots{} ]
+@emph{Warning: @code{LOCAL} is only available if you select ``alternate
+macro syntax'' with @samp{-a} or @samp{--alternate}.}  @xref{Alternate,,
+Alternate macro syntax}.
+
+Generate a string replacement for each of the @var{name} arguments, and
+replace any instances of @var{name} in each macro expansion.  The
+replacement string is unique in the assembly, and different for each
+separate macro expansion.  @code{LOCAL} allows you to write macros that
+define symbols, without fear of conflict between separate macro expansions.
+@end ftable
+
+@node Data
+@section Data output
+
+In assembly code, you often need to specify working areas of memory;
+depending on the application, you may want to initialize such memory or
+not.  @sc{gasp} provides preprocessor directives to help you avoid
+repetitive coding for both purposes.
+
+You can use labels as usual to mark the data areas.
+
+@menu
+* Initialized::
+* Uninitialized::
+@end menu
+
+@node Initialized
+@subsection Initialized data
+
+These are the @sc{gasp} directives for initialized data, and the standard
+@sc{gnu} assembler directives they expand to:
+
+@ftable @code
+@item .DATA @var{expr}, @var{expr}, @dots{}
+@itemx .DATA.B @var{expr}, @var{expr}, @dots{}
+@itemx .DATA.W @var{expr}, @var{expr}, @dots{}
+@itemx .DATA.L @var{expr}, @var{expr}, @dots{}
+Evaluate arithmetic expressions @var{expr}, and emit the corresponding
+@code{as} directive (labelled with @var{lab}).  The unqualified
+@code{.DATA} emits @samp{.long}; @code{.DATA.B} emits @samp{.byte};
+@code{.DATA.W} emits @samp{.short}; and @code{.DATA.L} emits
+@samp{.long}.
+
+For example, @samp{foo .DATA 1,2,3} emits @samp{foo: .long 1,2,3}.
+
+@item .DATAB @var{repeat}, @var{expr}
+@itemx .DATAB.B @var{repeat}, @var{expr}
+@itemx .DATAB.W @var{repeat}, @var{expr}
+@itemx .DATAB.L @var{repeat}, @var{expr}
+@c FIXME! Looks like gasp accepts and ignores args after 2nd.
+Make @code{as} emit @var{repeat} copies of the value of the expression
+@var{expr} (using the @code{as} directive @code{.fill}).
+@samp{.DATAB.B} repeats one-byte values; @samp{.DATAB.W} repeats
+two-byte values; and @samp{.DATAB.L} repeats four-byte values.
+@samp{.DATAB} without a suffix repeats four-byte values, just like
+@samp{.DATAB.L}.
+
+@c FIXME! Allowing zero might be useful for edge conditions in macros.
+@var{repeat} must be an absolute expression with a positive value.
+
+@item .SDATA "@var{str}" @dots{}
+String data.  Emits a concatenation of bytes, precisely as you specify
+them (in particular, @emph{nothing is added to mark the end} of the
+string).  @xref{Constants,, String and numeric constants}, for details
+about how to write strings.  @code{.SDATA} concatenates multiple
+arguments, making it easy to switch between string representations.  You
+can use commas to separate the individual arguments for clarity, if you
+choose.
+
+@item .SDATAB @var{repeat}, "@var{str}" @dots{}
+Repeated string data.  The first argument specifies how many copies of
+the string to emit; the remaining arguments specify the string, in the
+same way as the arguments to @code{.SDATA}.
+
+@item .SDATAZ "@var{str}" @dots{}
+Zero-terminated string data.  Just like @code{.SDATA}, except that
+@code{.SDATAZ} writes a zero byte at the end of the string.
+
+@item .SDATAC "@var{str}" @dots{}
+Count-prefixed string data.  Just like @code{.SDATA}, except that
+@sc{gasp} precedes the string with a leading one-byte count.  For
+example, @samp{.SDATAC "HI"} generates @samp{.byte 2,72,73}.  Since the
+count field is only one byte, you can only use @code{.SDATAC} for
+strings less than 256 bytes in length.
+@end ftable
+
+@node Uninitialized
+@subsection Uninitialized data
+
+@c FIXME!  .space different on some platforms, notably HPPA.  Config?
+Use the @code{.RES}, @code{.SRES}, @code{.SRESC}, and @code{.SRESZ}
+directives to reserve memory and leave it uninitialized.  @sc{gasp}
+resolves these directives to appropriate calls of the @sc{gnu}
+@code{as} @code{.space} directive.
+
+@ftable @code
+@item .RES @var{count}
+@itemx .RES.B @var{count}
+@itemx .RES.W @var{count}
+@itemx .RES.L @var{count}
+Reserve room for @var{count} uninitialized elements of data.  The
+suffix specifies the size of each element: @code{.RES.B} reserves
+@var{count} bytes, @code{.RES.W} reserves @var{count} pairs of bytes,
+and @code{.RES.L} reserves @var{count} quartets.  @code{.RES} without a
+suffix is equivalent to @code{.RES.L}.
+
+@item .SRES @var{count}
+@itemx .SRES.B @var{count}
+@itemx .SRES.W @var{count}
+@itemx .SRES.L @var{count}
+@c FIXME!  This is boring.  Shouldn't it at least have a different
+@c         default size?  (e.g. the "S" suggests "string", for which .B
+@c         would be more appropriate)
+@code{.SRES} is a synonym for @samp{.RES}.
+
+@item .SRESC @var{count}
+@itemx .SRESC.B @var{count}
+@itemx .SRESC.W @var{count}
+@itemx .SRESC.L @var{count}
+Like @code{.SRES}, but reserves space for @code{@var{count}+1} elements.
+
+@item .SRESZ @var{count}
+@itemx .SRESZ.B @var{count}
+@itemx .SRESZ.W @var{count}
+@itemx .SRESZ.L @var{count}
+Like @code{.SRES}, but reserves space for @code{@var{count}+1} elements.
+@end ftable
+
+@node Listings
+@section Assembly listing control
+
+The @sc{gasp} listing-control directives correspond to
+related @sc{gnu} @code{as} directives.
+
+@ftable @code
+@item .PRINT LIST
+@itemx .PRINT NOLIST
+Print control.  This directive emits the @sc{gnu} @code{as} directive
+@code{.list} or @code{.nolist}, according to its argument.  @xref{List,,
+@code{.list}, as.info, Using as}, for details on how these directives
+interact.
+
+@item .FORM LIN=@var{ln}
+@itemx .FORM COL=@var{cols}
+@itemx .FORM LIN=@var{ln} COL=@var{cols}
+Specify the page size for assembly listings: @var{ln} represents the
+number of lines, and @var{cols} the number of columns.  You may specify
+either page dimension independently, or both together.  If you do not
+specify the number of lines, @sc{gasp} assumes 60 lines; if you do not
+specify the number of columns, @sc{gasp} assumes 132 columns.
+(Any values you may have specified in previous instances of @code{.FORM}
+do @emph{not} carry over as defaults.)  Emits the @code{.psize}
+assembler directive.
+
+@item .HEADING @var{string}
+Specify @var{string} as the title of your assembly listings.  Emits
+@samp{.title "@var{string}"}.
+
+@item .PAGE
+Force a new page in assembly listings.  Emits @samp{.eject}.
+@end ftable
+
+@node Other Commands
+@section Miscellaneous commands
+
+@ftable @code
+@item .ALTERNATE
+Use the alternate macro syntax henceforth in the assembly.
+@xref{Alternate,, Alternate macro syntax}.
+
+@item .ORG
+@c FIXME!  This is very strange, since _GAS_ understands .org
+This command is recognized, but not yet implemented.  @sc{gasp}
+generates an error message for programs that use @code{.ORG}.
+
+@item .RADIX @var{s}
+@c FIXME no test cases in testsuite/gasp
+@sc{gasp} understands numbers in any of base two, eight, ten, or
+sixteen.  You can encode the base explicitly in any numeric constant
+(@pxref{Constants,, String and numeric constants}).  If you write
+numbers without an explicit indication of the base, the most recent
+@samp{.RADIX @var{s}} command determines how they are interpreted.
+@var{s} is a single letter, one of the following:
+
+@table @code
+@item .RADIX B
+Base 2.
+
+@item .RADIX Q
+Base 8.
+
+@item .RADIX D
+Base 10.  This is the original default radix.
+
+@item .RADIX H
+Base 16.
+@end table
+
+You may specify the argument @var{s} in lower case (any of @samp{bqdh})
+with the same effects.
+
+@item .EXPORT @var{name}
+@itemx .GLOBAL @var{name}
+@c FIXME! No test cases in testsuite/gasp
+Declare @var{name} global (emits @samp{.global @var{name}}).  The two
+directives are synonymous.
+
+@item .PROGRAM
+No effect: @sc{gasp} accepts this directive, and silently ignores it.
+
+@item .END
+Mark end of each preprocessor file.  @sc{gasp} issues a warning if it
+reaches end of file without seeing this command.
+
+@item .INCLUDE "@var{str}"
+Preprocess the file named by @var{str}, as if its contents appeared
+where the @code{.INCLUDE} directive does.  @sc{gasp} imposes a maximum
+limit of 30 stacked include files, as a sanity check.
+@c FIXME!  Why is include depth not affected by -u?
+
+@item .ALIGN @var{size}
+@c FIXME! Why is this not utterly pointless?
+Evaluate the absolute expression @var{size}, and emit the assembly
+instruction @samp{.align @var{size}} using the result.
+@end ftable
+
+@node Syntax Details
+@section Details of the GASP syntax
+
+Since @sc{gasp} is meant to work with assembly code, its statement
+syntax has no surprises for the assembly programmer.
+
+@cindex whitespace
+@emph{Whitespace} (blanks or tabs; @emph{not} newline) is partially
+significant, in that it delimits up to three fields in a line.  The
+amount of whitespace does not matter; you may line up fields in separate
+lines if you wish, but @sc{gasp} does not require that.
+
+@cindex fields of @sc{gasp} source line
+@cindex label field
+The @emph{first field}, an optional @dfn{label}, must be flush left in a
+line (with no leading whitespace) if it appears at all.  You may use a
+colon after the label if you wish; @sc{gasp} neither requires the colon
+nor objects to it (but will not include it as part of the label name).
+
+@cindex directive field
+The @emph{second field}, which must appear after some whitespace,
+contains a @sc{gasp} or assembly @dfn{directive}.
+
+@cindex argument fields
+Any @emph{further fields} on a line are @dfn{arguments} to the
+directive; you can separate them from one another using either commas or
+whitespace.
+
+@menu
+* Markers::
+* Constants::
+* Symbols::
+* Expressions::
+* String Builtins::
+@end menu
+
+@node Markers
+@subsection Special syntactic markers
+
+@sc{gasp} recognizes a few special markers: to delimit comments, to
+continue a statement on the next line, to separate symbols from other
+characters, and to copy text to the output literally.  (One other
+special marker, @samp{\@@}, works only within macro definitions;
+@pxref{Macros,, Defining your own directives}.)
+
+@cindex comments
+The trailing part of any @sc{gasp} source line may be a @dfn{comment}.
+A comment begins with the first unquoted comment character (@samp{!} by
+default), or an escaped or doubled comment character (@samp{\!} or
+@samp{!!} by default), and extends to the end of a line.  You can
+specify what comment character to use with the @samp{-c} option
+(@pxref{Invoking GASP,, Command Line Options}).  The two kinds of
+comment markers lead to slightly different treatment:
+
+@table @code
+@item !
+A single, un-escaped comment character generates an assembly comment in
+the @sc{gasp} output.  @sc{gasp} evaluates any preprocessor variables
+(macro arguments, or variables defined with @code{.ASSIGNA} or
+@code{.ASSIGNC}) present.  For example, a macro that begins like this
+
+@example
+        .MACRO  SUM FROM=0, TO=9
+        ! \FROM \TO
+@end example
+
+@noindent
+issues as the first line of output a comment that records the
+values you used to call the macro.
+
+@c comments, preprocessor-only
+@c preprocessor-only comments
+@c GASP-only comments
+@item \!
+@itemx !!
+Either an escaped comment character, or a double comment character,
+marks a @sc{gasp} source comment.  @sc{gasp} does not copy such comments
+to the assembly output.
+@end table
+
+@cindex continuation character
+@kindex +
+To @emph{continue a statement} on the next line of the file, begin the
+second line with the character @samp{+}.
+
+@cindex literal copy to output
+@cindex copying literally to output
+@cindex preprocessing, avoiding
+@cindex avoiding preprocessing
+Occasionally you may want to prevent @sc{gasp} from preprocessing some
+particular bit of text.  To @emph{copy literally} from the @sc{gasp}
+source to its output, place @samp{\(} before the string to copy, and
+@samp{)} at the end.  For example, write @samp{\(\!)} if you need the
+characters @samp{\!} in your assembly output.
+
+@cindex symbol separator
+@cindex text, separating from symbols
+@cindex symbols, separating from text
+To @emph{separate a preprocessor variable} from text to appear
+immediately after its value, write a single quote (@code{'}).  For
+example, @samp{.SDATA "\P'1"} writes a string built by concatenating the
+value of @code{P} and the digit @samp{1}.  (You cannot achieve this by
+writing just @samp{\P1}, since @samp{P1} is itself a valid name for a
+preprocessor variable.)
+
+@node Constants
+@subsection String and numeric constants
+
+There are two ways of writing @dfn{string constants} in @sc{gasp}: as
+literal text, and by numeric byte value.  Specify a string literal
+between double quotes (@code{"@var{str}"}).  Specify an individual
+numeric byte value as an absolute expression between angle brackets
+(@code{<@var{expr}>}.  Directives that output strings allow you to
+specify any number of either kind of value, in whatever order is
+convenient, and concatenate the result.  (Alternate syntax mode
+introduces a number of alternative string notations; @pxref{Alternate,,
+Alternate macro syntax}.)
+
+@c Details of numeric notation, e.g. base prefixes
+You can write @dfn{numeric constants} either in a specific base, or in
+whatever base is currently selected (either 10, or selected by the most
+recent @code{.RADIX}).
+
+To write a number in a @emph{specific base}, use the pattern
+@code{@var{s}'@var{ddd}}: a base specifier character @var{s}, followed
+by a single quote followed by digits @var{ddd}.  The base specifier
+character matches those you can specify with @code{.RADIX}: @samp{B} for
+base 2, @samp{Q} for base 8, @samp{D} for base 10, and @samp{H} for base
+16.  (You can write this character in lower case if you prefer.)
+
+You can write floating point constants using the same syntax recognised
+by GAS @ref{Flonums,,Flonums,as,The GNU Assembler.}.  A constraint is
+that these constants will be interpreted as decimal values irrespective
+of the currently selected base.
+
+@c FIXME! What are rules for recognizing number in deflt base?  Whatever
+@c        is left over after parsing other things??
+
+@node Symbols
+@subsection Symbols
+
+@sc{gasp} recognizes symbol names that start with any alphabetic character,
+@samp{_}, or @samp{$}, and continue with any of the same characters or
+with digits.  Label names follow the same rules.
+
+@node Expressions
+@subsection Arithmetic expressions in GASP
+
+@cindex absolute expressions
+@cindex relocatable expressions
+There are two kinds of expressions, depending on their result:
+@dfn{absolute} expressions, which resolve to a constant (that is, they
+do not involve any values unknown to @sc{gasp}), and @dfn{relocatable}
+expressions, which must reduce to the form
+
+@example
+@var{addsym}+@var{const}-@var{subsym}
+@end example
+
+@noindent
+where @var{addsym} and @var{subsym} are assembly symbols of unknown
+value, and @var{const} is a constant.
+
+Arithmetic for @sc{gasp} expressions follows very similar rules to C.
+You can use parentheses to change precedence; otherwise, arithmetic
+primitives have decreasing precedence in the order of the following
+list.
+
+@enumerate
+@item
+Single-argument @code{+} (identity), @code{-} (arithmetic opposite), or
+@code{~} (bitwise negation).  @emph{The argument must be an absolute
+expression.}
+
+@item
+@code{*} (multiplication) and @code{/} (division).  @emph{Both arguments
+must be absolute expressions.}
+
+@item
+@code{+} (addition) and @code{-} (subtraction).  @emph{At least one argument
+must be absolute.}
+@c FIXME!  Actually, subtraction doesn't check for this.
+
+@item
+@code{&} (bitwise and).  @emph{Both arguments must be absolute.}
+
+@item
+@c FIXME!  I agree ~ is a better notation than ^ for xor, but is the
+@c         improvement worth differing from C?
+@code{|} (bitwise or) and @code{~} (bitwise exclusive or; @code{^} in
+C).  @emph{Both arguments must be absolute.}
+@end enumerate
+
+@node String Builtins
+@subsection String primitives
+
+You can use these primitives to manipulate strings (in the argument
+field of @sc{gasp} statements):
+
+@ftable @code
+@item .LEN("@var{str}")
+Calculate the length of string @code{"@var{str}"}, as an absolute
+expression.  For example, @samp{.RES.B .LEN("sample")} reserves six
+bytes of memory.
+
+@item .INSTR("@var{string}", "@var{seg}", @var{ix})
+Search for the first occurrence of @var{seg} after position @var{ix} of
+@var{string}.  For example, @samp{.INSTR("ABCDEFG", "CDE", 0)} evaluates
+to the absolute result @code{2}.
+
+The result is @code{-1} if @var{seg} does not occur in @var{string}
+after position @var{ix}.
+
+@item .SUBSTR("@var{string}",@var{start},@var{len})
+The substring of @var{string} beginning at byte number @var{start} and
+extending for @var{len} bytes.
+@end ftable
+
+@node Alternate
+@section Alternate macro syntax
+
+If you specify @samp{-a} or @samp{--alternate} on the @sc{gasp} command
+line, the preprocessor uses somewhat different syntax.  This syntax is
+reminiscent of the syntax of Phar Lap macro assembler, but it
+is @emph{not} meant to be a full emulation of Phar Lap or similar
+assemblers.  In particular, @sc{gasp} does not support directives such
+as @code{DB} and @code{IRP}, even in alternate syntax mode.
+
+In particular, @samp{-a} (or @samp{--alternate}) elicits these
+differences:
+
+@table @emph
+@item Preprocessor directives
+You can use @sc{gasp} preprocessor directives without a leading @samp{.}
+dot.  For example, you can write @samp{SDATA} with the same effect as
+@samp{.SDATA}.
+
+@item LOCAL
+One additional directive, @code{LOCAL}, is available.  @xref{Macros,,
+Defining your own directives}, for an explanation of how to use
+@code{LOCAL}.
+
+@need 2000
+@item String delimiters
+You can write strings delimited in these other ways besides
+@code{"@var{string}"}:
+
+@table @code
+@item '@var{string}'
+You can delimit strings with single-quote charaters.
+
+@item <@var{string}>
+You can delimit strings with matching angle brackets.
+@end table
+
+@item single-character string escape
+To include any single character literally in a string (even if the
+character would otherwise have some special meaning), you can prefix the
+character with @samp{!} (an exclamation mark).  For example, you can
+write @samp{<4.3 !> 5.4!!>} to get the literal text @samp{4.3 > 5.4!}.
+
+@item Expression results as strings
+You can write @samp{%@var{expr}} to evaluate the expression @var{expr}
+and use the result as a string.  
+@end table
+
+@node GNU Free Documentation License
+@chapter GNU Free Documentation License
+
+                GNU Free Documentation License
+                
+                   Version 1.1, March 2000
+
+ Copyright (C) 2000  Free Software Foundation, Inc.
+  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+     
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+
+0. PREAMBLE
+
+The purpose of this License is to make a manual, textbook, or other
+written document "free" in the sense of freedom: to assure everyone
+the effective freedom to copy and redistribute it, with or without
+modifying it, either commercially or noncommercially.  Secondarily,
+this License preserves for the author and publisher a way to get
+credit for their work, while not being considered responsible for
+modifications made by others.
+
+This License is a kind of "copyleft", which means that derivative
+works of the document must themselves be free in the same sense.  It
+complements the GNU General Public License, which is a copyleft
+license designed for free software.
+
+We have designed this License in order to use it for manuals for free
+software, because free software needs free documentation: a free
+program should come with manuals providing the same freedoms that the
+software does.  But this License is not limited to software manuals;
+it can be used for any textual work, regardless of subject matter or
+whether it is published as a printed book.  We recommend this License
+principally for works whose purpose is instruction or reference.
+
+
+1. APPLICABILITY AND DEFINITIONS
+
+This License applies to any manual or other work that contains a
+notice placed by the copyright holder saying it can be distributed
+under the terms of this License.  The "Document", below, refers to any
+such manual or work.  Any member of the public is a licensee, and is
+addressed as "you".
+
+A "Modified Version" of the Document means any work containing the
+Document or a portion of it, either copied verbatim, or with
+modifications and/or translated into another language.
+
+A "Secondary Section" is a named appendix or a front-matter section of
+the Document that deals exclusively with the relationship of the
+publishers or authors of the Document to the Document's overall subject
+(or to related matters) and contains nothing that could fall directly
+within that overall subject.  (For example, if the Document is in part a
+textbook of mathematics, a Secondary Section may not explain any
+mathematics.)  The relationship could be a matter of historical
+connection with the subject or with related matters, or of legal,
+commercial, philosophical, ethical or political position regarding
+them.
+
+The "Invariant Sections" are certain Secondary Sections whose titles
+are designated, as being those of Invariant Sections, in the notice
+that says that the Document is released under this License.
+
+The "Cover Texts" are certain short passages of text that are listed,
+as Front-Cover Texts or Back-Cover Texts, in the notice that says that
+the Document is released under this License.
+
+A "Transparent" copy of the Document means a machine-readable copy,
+represented in a format whose specification is available to the
+general public, whose contents can be viewed and edited directly and
+straightforwardly with generic text editors or (for images composed of
+pixels) generic paint programs or (for drawings) some widely available
+drawing editor, and that is suitable for input to text formatters or
+for automatic translation to a variety of formats suitable for input
+to text formatters.  A copy made in an otherwise Transparent file
+format whose markup has been designed to thwart or discourage
+subsequent modification by readers is not Transparent.  A copy that is
+not "Transparent" is called "Opaque".
+
+Examples of suitable formats for Transparent copies include plain
+ASCII without markup, Texinfo input format, LaTeX input format, SGML
+or XML using a publicly available DTD, and standard-conforming simple
+HTML designed for human modification.  Opaque formats include
+PostScript, PDF, proprietary formats that can be read and edited only
+by proprietary word processors, SGML or XML for which the DTD and/or
+processing tools are not generally available, and the
+machine-generated HTML produced by some word processors for output
+purposes only.
+
+The "Title Page" means, for a printed book, the title page itself,
+plus such following pages as are needed to hold, legibly, the material
+this License requires to appear in the title page.  For works in
+formats which do not have any title page as such, "Title Page" means
+the text near the most prominent appearance of the work's title,
+preceding the beginning of the body of the text.
+
+
+2. VERBATIM COPYING
+
+You may copy and distribute the Document in any medium, either
+commercially or noncommercially, provided that this License, the
+copyright notices, and the license notice saying this License applies
+to the Document are reproduced in all copies, and that you add no other
+conditions whatsoever to those of this License.  You may not use
+technical measures to obstruct or control the reading or further
+copying of the copies you make or distribute.  However, you may accept
+compensation in exchange for copies.  If you distribute a large enough
+number of copies you must also follow the conditions in section 3.
+
+You may also lend copies, under the same conditions stated above, and
+you may publicly display copies.
+
+
+3. COPYING IN QUANTITY
+
+If you publish printed copies of the Document numbering more than 100,
+and the Document's license notice requires Cover Texts, you must enclose
+the copies in covers that carry, clearly and legibly, all these Cover
+Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
+the back cover.  Both covers must also clearly and legibly identify
+you as the publisher of these copies.  The front cover must present
+the full title with all words of the title equally prominent and
+visible.  You may add other material on the covers in addition.
+Copying with changes limited to the covers, as long as they preserve
+the title of the Document and satisfy these conditions, can be treated
+as verbatim copying in other respects.
+
+If the required texts for either cover are too voluminous to fit
+legibly, you should put the first ones listed (as many as fit
+reasonably) on the actual cover, and continue the rest onto adjacent
+pages.
+
+If you publish or distribute Opaque copies of the Document numbering
+more than 100, you must either include a machine-readable Transparent
+copy along with each Opaque copy, or state in or with each Opaque copy
+a publicly-accessible computer-network location containing a complete
+Transparent copy of the Document, free of added material, which the
+general network-using public has access to download anonymously at no
+charge using public-standard network protocols.  If you use the latter
+option, you must take reasonably prudent steps, when you begin
+distribution of Opaque copies in quantity, to ensure that this
+Transparent copy will remain thus accessible at the stated location
+until at least one year after the last time you distribute an Opaque
+copy (directly or through your agents or retailers) of that edition to
+the public.
+
+It is requested, but not required, that you contact the authors of the
+Document well before redistributing any large number of copies, to give
+them a chance to provide you with an updated version of the Document.
+
+
+4. MODIFICATIONS
+
+You may copy and distribute a Modified Version of the Document under
+the conditions of sections 2 and 3 above, provided that you release
+the Modified Version under precisely this License, with the Modified
+Version filling the role of the Document, thus licensing distribution
+and modification of the Modified Version to whoever possesses a copy
+of it.  In addition, you must do these things in the Modified Version:
+
+A. Use in the Title Page (and on the covers, if any) a title distinct
+   from that of the Document, and from those of previous versions
+   (which should, if there were any, be listed in the History section
+   of the Document).  You may use the same title as a previous version
+   if the original publisher of that version gives permission.
+B. List on the Title Page, as authors, one or more persons or entities
+   responsible for authorship of the modifications in the Modified
+   Version, together with at least five of the principal authors of the
+   Document (all of its principal authors, if it has less than five).
+C. State on the Title page the name of the publisher of the
+   Modified Version, as the publisher.
+D. Preserve all the copyright notices of the Document.
+E. Add an appropriate copyright notice for your modifications
+   adjacent to the other copyright notices.
+F. Include, immediately after the copyright notices, a license notice
+   giving the public permission to use the Modified Version under the
+   terms of this License, in the form shown in the Addendum below.
+G. Preserve in that license notice the full lists of Invariant Sections
+   and required Cover Texts given in the Document's license notice.
+H. Include an unaltered copy of this License.
+I. Preserve the section entitled "History", and its title, and add to
+   it an item stating at least the title, year, new authors, and
+   publisher of the Modified Version as given on the Title Page.  If
+   there is no section entitled "History" in the Document, create one
+   stating the title, year, authors, and publisher of the Document as
+   given on its Title Page, then add an item describing the Modified
+   Version as stated in the previous sentence.
+J. Preserve the network location, if any, given in the Document for
+   public access to a Transparent copy of the Document, and likewise
+   the network locations given in the Document for previous versions
+   it was based on.  These may be placed in the "History" section.
+   You may omit a network location for a work that was published at
+   least four years before the Document itself, or if the original
+   publisher of the version it refers to gives permission.
+K. In any section entitled "Acknowledgements" or "Dedications",
+   preserve the section's title, and preserve in the section all the
+   substance and tone of each of the contributor acknowledgements
+   and/or dedications given therein.
+L. Preserve all the Invariant Sections of the Document,
+   unaltered in their text and in their titles.  Section numbers
+   or the equivalent are not considered part of the section titles.
+M. Delete any section entitled "Endorsements".  Such a section
+   may not be included in the Modified Version.
+N. Do not retitle any existing section as "Endorsements"
+   or to conflict in title with any Invariant Section.
+
+If the Modified Version includes new front-matter sections or
+appendices that qualify as Secondary Sections and contain no material
+copied from the Document, you may at your option designate some or all
+of these sections as invariant.  To do this, add their titles to the
+list of Invariant Sections in the Modified Version's license notice.
+These titles must be distinct from any other section titles.
+
+You may add a section entitled "Endorsements", provided it contains
+nothing but endorsements of your Modified Version by various
+parties--for example, statements of peer review or that the text has
+been approved by an organization as the authoritative definition of a
+standard.
+
+You may add a passage of up to five words as a Front-Cover Text, and a
+passage of up to 25 words as a Back-Cover Text, to the end of the list
+of Cover Texts in the Modified Version.  Only one passage of
+Front-Cover Text and one of Back-Cover Text may be added by (or
+through arrangements made by) any one entity.  If the Document already
+includes a cover text for the same cover, previously added by you or
+by arrangement made by the same entity you are acting on behalf of,
+you may not add another; but you may replace the old one, on explicit
+permission from the previous publisher that added the old one.
+
+The author(s) and publisher(s) of the Document do not by this License
+give permission to use their names for publicity for or to assert or
+imply endorsement of any Modified Version.
+
+
+5. COMBINING DOCUMENTS
+
+You may combine the Document with other documents released under this
+License, under the terms defined in section 4 above for modified
+versions, provided that you include in the combination all of the
+Invariant Sections of all of the original documents, unmodified, and
+list them all as Invariant Sections of your combined work in its
+license notice.
+
+The combined work need only contain one copy of this License, and
+multiple identical Invariant Sections may be replaced with a single
+copy.  If there are multiple Invariant Sections with the same name but
+different contents, make the title of each such section unique by
+adding at the end of it, in parentheses, the name of the original
+author or publisher of that section if known, or else a unique number.
+Make the same adjustment to the section titles in the list of
+Invariant Sections in the license notice of the combined work.
+
+In the combination, you must combine any sections entitled "History"
+in the various original documents, forming one section entitled
+"History"; likewise combine any sections entitled "Acknowledgements",
+and any sections entitled "Dedications".  You must delete all sections
+entitled "Endorsements."
+
+
+6. COLLECTIONS OF DOCUMENTS
+
+You may make a collection consisting of the Document and other documents
+released under this License, and replace the individual copies of this
+License in the various documents with a single copy that is included in
+the collection, provided that you follow the rules of this License for
+verbatim copying of each of the documents in all other respects.
+
+You may extract a single document from such a collection, and distribute
+it individually under this License, provided you insert a copy of this
+License into the extracted document, and follow this License in all
+other respects regarding verbatim copying of that document.
+
+
+7. AGGREGATION WITH INDEPENDENT WORKS
+
+A compilation of the Document or its derivatives with other separate
+and independent documents or works, in or on a volume of a storage or
+distribution medium, does not as a whole count as a Modified Version
+of the Document, provided no compilation copyright is claimed for the
+compilation.  Such a compilation is called an "aggregate", and this
+License does not apply to the other self-contained works thus compiled
+with the Document, on account of their being thus compiled, if they
+are not themselves derivative works of the Document.
+
+If the Cover Text requirement of section 3 is applicable to these
+copies of the Document, then if the Document is less than one quarter
+of the entire aggregate, the Document's Cover Texts may be placed on
+covers that surround only the Document within the aggregate.
+Otherwise they must appear on covers around the whole aggregate.
+
+
+8. TRANSLATION
+
+Translation is considered a kind of modification, so you may
+distribute translations of the Document under the terms of section 4.
+Replacing Invariant Sections with translations requires special
+permission from their copyright holders, but you may include
+translations of some or all Invariant Sections in addition to the
+original versions of these Invariant Sections.  You may include a
+translation of this License provided that you also include the
+original English version of this License.  In case of a disagreement
+between the translation and the original English version of this
+License, the original English version will prevail.
+
+
+9. TERMINATION
+
+You may not copy, modify, sublicense, or distribute the Document except
+as expressly provided for under this License.  Any other attempt to
+copy, modify, sublicense or distribute the Document is void, and will
+automatically terminate your rights under this License.  However,
+parties who have received copies, or rights, from you under this
+License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+
+10. FUTURE REVISIONS OF THIS LICENSE
+
+The Free Software Foundation may publish new, revised versions
+of the GNU Free Documentation License from time to time.  Such new
+versions will be similar in spirit to the present version, but may
+differ in detail to address new problems or concerns.  See
+http://www.gnu.org/copyleft/.
+
+Each version of the License is given a distinguishing version number.
+If the Document specifies that a particular numbered version of this
+License "or any later version" applies to it, you have the option of
+following the terms and conditions either of that specified version or
+of any later version that has been published (not as a draft) by the
+Free Software Foundation.  If the Document does not specify a version
+number of this License, you may choose any version ever published (not
+as a draft) by the Free Software Foundation.
+
+
+ADDENDUM: How to use this License for your documents
+
+To use this License in a document you have written, include a copy of
+the License in the document and put the following copyright and
+license notices just after the title page:
+
+@smallexample
+    Copyright (c)  YEAR  YOUR NAME.
+    Permission is granted to copy, distribute and/or modify this document
+    under the terms of the GNU Free Documentation License, Version 1.1
+    or any later version published by the Free Software Foundation;
+    with the Invariant Sections being LIST THEIR TITLES, with the
+    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
+    A copy of the license is included in the section entitled "GNU
+    Free Documentation License".
+@end smallexample
+
+If you have no Invariant Sections, write "with no Invariant Sections"
+instead of saying which ones are invariant.  If you have no
+Front-Cover Texts, write "no Front-Cover Texts" instead of
+"Front-Cover Texts being LIST"; likewise for Back-Cover Texts.
+
+If your document contains nontrivial examples of program code, we
+recommend releasing these examples in parallel under your choice of
+free software license, such as the GNU General Public License,
+to permit their use in free software.
+
+@node Index
+@unnumbered Index
+
+@printindex cp
+
+@contents
+@bye
diff -urp --unidirectional-new-file binutils-2.15/gas/expr.c binutils-freebsd/gas/expr.c
--- binutils-2.15/gas/expr.c	2004-05-17 15:36:07.000000000 -0400
+++ binutils-freebsd/gas/expr.c	2004-06-16 01:45:10.000000000 -0400
@@ -1021,8 +1021,9 @@ operand (expressionS *expressionP)
       break;
 
     case '+':
-      /* Do not accept ++e as +(+e) */
-      if (*input_line_pointer == '+')
+      /* Do not accept ++e as +(+e).
+	 Disabled, since the preprocessor removes whitespace.  */
+      if (0 && *input_line_pointer == '+')
 	goto target_op;
       (void) operand (expressionP);
       break;
@@ -1041,8 +1042,9 @@ operand (expressionS *expressionP)
     case '!':
     case '-':
       {
-        /* Do not accept --e as -(-e) */
-	if (c == '-' && *input_line_pointer == '-')
+        /* Do not accept --e as -(-e)
+	   Disabled, since the preprocessor removes whitespace.  */
+	if (0 && c == '-' && *input_line_pointer == '-')
 	  goto target_op;
 	
 	operand (expressionP);
@@ -1551,8 +1553,9 @@ operator (int *num_chars)
 
     case '+':
     case '-':
-      /* Do not allow a++b and a--b to be a + (+b) and a - (-b) */
-      if (input_line_pointer[1] != c)
+      /* Do not allow a++b and a--b to be a + (+b) and a - (-b)
+	 Disabled, since the preprocessor removes whitespace.  */
+      if (1 || input_line_pointer[1] != c)
 	return op_encoding[c];
       return O_illegal;
 
diff -urp --unidirectional-new-file binutils-2.15/gas/gasp.c binutils-freebsd/gas/gasp.c
--- binutils-2.15/gas/gasp.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/gas/gasp.c	2002-10-11 02:00:09.000000000 -0400
@@ -0,0 +1,3761 @@
+/* gasp.c - Gnu assembler preprocessor main program.
+   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
+   Free Software Foundation, Inc.
+
+   Written by Steve and Judy Chamberlain of Cygnus Support,
+      sac@cygnus.com
+
+   This file is part of GASP, the GNU Assembler Preprocessor.
+
+   GASP is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GASP is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GASP; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+/*
+This program translates the input macros and stuff into a form
+suitable for gas to consume.
+
+  gasp [-sdhau] [-c char] [-o <outfile>] <infile>*
+
+  -s copy source to output
+  -c <char> comments are started with <char> instead of !
+  -u allow unreasonable stuff
+  -p print line numbers
+  -d print debugging stats
+  -s semi colons start comments
+  -a use alternate syntax
+     Pseudo ops can start with or without a .
+     Labels have to be in first column.
+  -I specify include dir
+    Macro arg parameters subsituted by name, don't need the &.
+     String can start with ' too.
+     Strings can be surrounded by <..>
+     A %<exp> in a string evaluates the expression
+     Literal char in a string with !
+*/
+
+#include "config.h"
+#include "bin-bugs.h"
+
+#include <assert.h>
+#include <stdio.h>
+#include <string.h>
+#include "getopt.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#ifdef NEED_MALLOC_DECLARATION
+extern char *malloc ();
+#endif
+
+#include "ansidecl.h"
+#include "libiberty.h"
+#include "safe-ctype.h"
+#include "sb.h"
+#include "macro.h"
+#include "asintl.h"
+#include "xregex.h"
+
+char *program_version = "1.2";
+
+/* This is normally declared in as.h, but we don't include that.  We
+   need the function because other files linked with gasp.c might call
+   it.  */
+extern void as_abort PARAMS ((const char *, int, const char *));
+
+/* The default obstack chunk size.  If we set this to zero, the
+   obstack code will use whatever will fit in a 4096 byte block.  This
+   is used by the hash table code used by macro.c.  */
+int chunksize = 0;
+
+#define MAX_INCLUDES 30		/* Maximum include depth.  */
+#define MAX_REASONABLE 1000	/* Maximum number of expansions.  */
+
+int unreasonable;		/* -u on command line.  */
+int stats;			/* -d on command line.  */
+int print_line_number;		/* -p flag on command line.  */
+int copysource;			/* -c flag on command line.  */
+int warnings;			/* Number of WARNINGs generated so far.  */
+int errors;			/* Number of ERRORs generated so far.  */
+int fatals;			/* Number of fatal ERRORs generated so far (either 0 or 1).  */
+int alternate = 0;              /* -a on command line.  */
+int mri = 0;			/* -M on command line.  */
+char comment_char = '!';
+int radix = 10;			/* Default radix.  */
+
+int had_end; /* Seen .END.  */
+
+/* The output stream.  */
+FILE *outfile;
+
+/* The attributes of each character are stored as a bit pattern
+   chartype, which gives us quick tests.  */
+
+#define FIRSTBIT 1
+#define NEXTBIT  2
+#define SEPBIT   4
+#define WHITEBIT 8
+#define COMMENTBIT 16
+#define BASEBIT  32
+#define ISCOMMENTCHAR(x) (chartype[(unsigned char)(x)] & COMMENTBIT)
+#define ISFIRSTCHAR(x)  (chartype[(unsigned char)(x)] & FIRSTBIT)
+#define ISNEXTCHAR(x)   (chartype[(unsigned char)(x)] & NEXTBIT)
+#define ISSEP(x)        (chartype[(unsigned char)(x)] & SEPBIT)
+#define ISWHITE(x)      (chartype[(unsigned char)(x)] & WHITEBIT)
+#define ISBASE(x)       (chartype[(unsigned char)(x)] & BASEBIT)
+static char chartype[256];
+
+/* Conditional assembly uses the `ifstack'.  Each aif pushes another
+   entry onto the stack, and sets the on flag if it should.  The aelse
+   sets hadelse, and toggles on.  An aend pops a level.  We limit to
+   100 levels of nesting, not because we're facists pigs with read
+   only minds, but because more than 100 levels of nesting is probably
+   a bug in the user's macro structure.  */
+
+#define IFNESTING 100
+struct {
+  int on;			/* Is the level being output.  */
+  int hadelse;			/* Has an aelse been seen.  */
+} ifstack[IFNESTING];
+
+int ifi;
+
+/* The final and intermediate results of expression evaluation are kept in
+   exp_t's.  Note that a symbol is not an sb, but a pointer into the input
+   line.  It must be coped somewhere safe before the next line is read in.  */
+
+typedef struct {
+  char *name;
+  int len;
+} symbol;
+
+typedef struct {
+  int value;			/* Constant part.  */
+  symbol add_symbol;		/* Name part.  */
+  symbol sub_symbol;		/* Name part.  */
+} exp_t;
+
+/* Hashing is done in a pretty standard way.  A hash_table has a
+   pointer to a vector of pointers to hash_entrys, and the size of the
+   vector.  A hash_entry contains a union of all the info we like to
+   store in hash table.  If there is a hash collision, hash_entries
+   with the same hash are kept in a chain.  */
+
+/* What the data in a hash_entry means.  */
+typedef enum {
+  hash_integer,			/* Name->integer mapping.  */
+  hash_string,			/* Name->string mapping.  */
+  hash_macro,			/* Name is a macro.  */
+  hash_formal			/* Name is a formal argument.  */
+} hash_type;
+
+typedef struct hs {
+  sb key;			/* Symbol name.  */
+  hash_type type;		/* Symbol meaning.  */
+  union {
+    sb s;
+    int i;
+    struct macro_struct *m;
+    struct formal_struct *f;
+  } value;
+  struct hs *next;		/* Next hash_entry with same hash key.  */
+} hash_entry;
+
+typedef struct {
+  hash_entry **table;
+  int size;
+} hash_table;
+
+/* How we nest files and expand macros etc.
+
+   We keep a stack of of include_stack structs.  Each include file
+   pushes a new level onto the stack.  We keep an sb with a pushback
+   too.  unget chars are pushed onto the pushback sb, getchars first
+   checks the pushback sb before reading from the input stream.
+
+   Small things are expanded by adding the text of the item onto the
+   pushback sb.  Larger items are grown by pushing a new level and
+   allocating the entire pushback buf for the item.  Each time
+   something like a macro is expanded, the stack index is changed.  We
+   can then perform an exitm by popping all entries off the stack with
+   the same stack index.  If we're being reasonable, we can detect
+   recusive expansion by checking the index is reasonably small.  */
+
+typedef enum {
+  include_file, include_repeat, include_while, include_macro
+} include_type;
+
+struct include_stack {
+  sb pushback;			/* Current pushback stream.  */
+  int pushback_index;		/* Next char to read from stream.  */
+  FILE *handle;			/* Open file.  */
+  sb name;			/* Name of file.  */
+  int linecount;		/* Number of lines read so far.  */
+  include_type type;
+  int index;			/* Index of this layer.  */
+} include_stack[MAX_INCLUDES];
+
+struct include_stack *sp;
+#define isp (sp - include_stack)
+
+/* Include file list.  */
+
+typedef struct include_path {
+  struct include_path *next;
+  sb path;
+} include_path;
+
+include_path *paths_head;
+include_path *paths_tail;
+
+static void quit PARAMS ((void));
+static void hash_new_table PARAMS ((int, hash_table *));
+static int hash PARAMS ((sb *));
+static hash_entry *hash_create PARAMS ((hash_table *, sb *));
+static void hash_add_to_string_table PARAMS ((hash_table *, sb *, sb *, int));
+static void hash_add_to_int_table PARAMS ((hash_table *, sb *, int));
+static hash_entry *hash_lookup PARAMS ((hash_table *, sb *));
+static void checkconst PARAMS ((int, exp_t *));
+static int is_flonum PARAMS ((int, sb *));
+static int chew_flonum PARAMS ((int, sb *, sb *));
+static int sb_strtol PARAMS ((int, sb *, int, int *));
+static int level_0 PARAMS ((int, sb *, exp_t *));
+static int level_1 PARAMS ((int, sb *, exp_t *));
+static int level_2 PARAMS ((int, sb *, exp_t *));
+static int level_3 PARAMS ((int, sb *, exp_t *));
+static int level_4 PARAMS ((int, sb *, exp_t *));
+static int level_5 PARAMS ((int, sb *, exp_t *));
+static int exp_parse PARAMS ((int, sb *, exp_t *));
+static void exp_string PARAMS ((exp_t *, sb *));
+static int exp_get_abs PARAMS ((const char *, int, sb *, int *));
+#if 0
+static void strip_comments PARAMS ((sb *));
+#endif
+static void unget PARAMS ((int));
+static void include_buf PARAMS ((sb *, sb *, include_type, int));
+static void include_print_where_line PARAMS ((FILE *));
+static void include_print_line PARAMS ((FILE *));
+static int get_line PARAMS ((sb *));
+static int grab_label PARAMS ((sb *, sb *));
+static void change_base PARAMS ((int, sb *, sb *));
+static void do_end PARAMS ((sb *));
+static void do_assign PARAMS ((int, int, sb *));
+static void do_radix PARAMS ((sb *));
+static int get_opsize PARAMS ((int, sb *, int *));
+static int eol PARAMS ((int, sb *));
+static void do_data PARAMS ((int, sb *, int));
+static void do_datab PARAMS ((int, sb *));
+static void do_align PARAMS ((int, sb *));
+static void do_res PARAMS ((int, sb *, int));
+static void do_export PARAMS ((sb *));
+static void do_print PARAMS ((int, sb *));
+static void do_heading PARAMS ((int, sb *));
+static void do_page PARAMS ((void));
+static void do_form PARAMS ((int, sb *));
+static int get_any_string PARAMS ((int, sb *, sb *, int, int));
+static int skip_openp PARAMS ((int, sb *));
+static int skip_closep PARAMS ((int, sb *));
+static int dolen PARAMS ((int, sb *, sb *));
+static int doinstr PARAMS ((int, sb *, sb *));
+static int dosubstr PARAMS ((int, sb *, sb *));
+static void process_assigns PARAMS ((int, sb *, sb *));
+static int get_and_process PARAMS ((int, sb *, sb *));
+static void process_file PARAMS ((void));
+static void free_old_entry PARAMS ((hash_entry *));
+static void do_assigna PARAMS ((int, sb *));
+static void do_assignc PARAMS ((int, sb *));
+static void do_reg PARAMS ((int, sb *));
+static int condass_lookup_name PARAMS ((sb *, int, sb *, int));
+static int whatcond PARAMS ((int, sb *, int *));
+static int istrue PARAMS ((int, sb *));
+static void do_aif PARAMS ((int, sb *));
+static void do_aelse PARAMS ((void));
+static void do_aendi PARAMS ((void));
+static int condass_on PARAMS ((void));
+static void do_if PARAMS ((int, sb *, int));
+static int get_mri_string PARAMS ((int, sb *, sb *, int));
+static void do_ifc PARAMS ((int, sb *, int));
+static void do_aendr PARAMS ((void));
+static void do_awhile PARAMS ((int, sb *));
+static void do_aendw PARAMS ((void));
+static void do_exitm PARAMS ((void));
+static void do_arepeat PARAMS ((int, sb *));
+static void do_endm PARAMS ((void));
+static void do_irp PARAMS ((int, sb *, int));
+static void do_local PARAMS ((int, sb *));
+static void do_macro PARAMS ((int, sb *));
+static int macro_op PARAMS ((int, sb *));
+static int getstring PARAMS ((int, sb *, sb *));
+static void do_sdata PARAMS ((int, sb *, int));
+static void do_sdatab PARAMS ((int, sb *));
+static int new_file PARAMS ((const char *));
+static void do_include PARAMS ((int, sb *));
+static void include_pop PARAMS ((void));
+static int get PARAMS ((void));
+static int linecount PARAMS ((void));
+static int include_next_index PARAMS ((void));
+static void chartype_init PARAMS ((void));
+static int process_pseudo_op PARAMS ((int, sb *, sb *));
+static void add_keyword PARAMS ((const char *, int));
+static void process_init PARAMS ((void));
+static void do_define PARAMS ((const char *));
+static void show_usage PARAMS ((FILE *, int));
+static void show_help PARAMS ((void));
+
+#define FATAL(x)				\
+  do						\
+    {						\
+      include_print_where_line (stderr);	\
+      fprintf x;				\
+      fatals++;					\
+      quit ();					\
+    }						\
+  while (0)
+
+#define ERROR(x)				\
+  do						\
+    {						\
+      include_print_where_line (stderr);	\
+      fprintf x;				\
+      errors++;					\
+    }						\
+  while (0)
+
+#define WARNING(x)				\
+  do						\
+    {						\
+      include_print_where_line (stderr);	\
+      fprintf x;				\
+      warnings++;				\
+    }						\
+  while (0)
+
+/* Exit the program and return the right ERROR code.  */
+
+static void
+quit ()
+{
+  int exitcode;
+  if (fatals + errors)
+    exitcode = 1;
+  else
+    exitcode = 0;
+
+  if (stats)
+    {
+      int i;
+      for (i = 0; i < sb_max_power_two; i++)
+	{
+	  fprintf (stderr, "strings size %8d : %d\n",
+		   1 << i, string_count[i]);
+	}
+    }
+  exit (exitcode);
+}
+
+/* Hash table maintenance.  */
+
+/* Build a new hash table with size buckets
+   and fill in the info at ptr.  */
+
+static void
+hash_new_table (size, ptr)
+     int size;
+     hash_table *ptr;
+{
+  int i;
+  ptr->size = size;
+  ptr->table = (hash_entry **) xmalloc (size * (sizeof (hash_entry *)));
+  /* Fill with null-pointer, not zero-bit-pattern.  */
+  for (i = 0; i < size; i++)
+    ptr->table[i] = 0;
+}
+
+/* Calculate and return the hash value of the sb at key.  */
+
+static int
+hash (key)
+     sb *key;
+{
+  int k = 0x1234;
+  int i;
+  char *p = key->ptr;
+  for (i = 0; i < key->len; i++)
+    {
+      k ^= (k << 2) ^ *p;
+      p++;
+    }
+  return k & 0xf0fff;
+}
+
+/* Look up key in hash_table tab.  If present, then return it,
+   otherwise build a new one and fill it with hash_integer.  */
+
+static hash_entry *
+hash_create (tab, key)
+     hash_table *tab;
+     sb *key;
+{
+  int k = hash (key) % tab->size;
+  hash_entry *p;
+  hash_entry **table = tab->table;
+
+  p = table[k];
+
+  while (1)
+    {
+      if (!p)
+	{
+	  hash_entry *n = (hash_entry *) xmalloc (sizeof (hash_entry));
+	  n->next = table[k];
+	  sb_new (&n->key);
+	  sb_add_sb (&n->key, key);
+	  table[k] = n;
+	  n->type = hash_integer;
+	  return n;
+	}
+      if (strncmp (table[k]->key.ptr, key->ptr, key->len) == 0)
+	{
+	  return p;
+	}
+      p = p->next;
+    }
+}
+
+/* Add sb name with key into hash_table tab.
+   If replacing old value and again, then ERROR.  */
+
+static void
+hash_add_to_string_table (tab, key, name, again)
+     hash_table *tab;
+     sb *key;
+     sb *name;
+     int again;
+{
+  hash_entry *ptr = hash_create (tab, key);
+  if (ptr->type == hash_integer)
+    {
+      sb_new (&ptr->value.s);
+    }
+  if (ptr->value.s.len)
+    {
+      if (!again)
+	ERROR ((stderr, _("redefinition not allowed\n")));
+    }
+
+  ptr->type = hash_string;
+  sb_reset (&ptr->value.s);
+
+  sb_add_sb (&ptr->value.s, name);
+}
+
+/* Add integer name to hash_table tab with sb key.  */
+
+static void
+hash_add_to_int_table (tab, key, name)
+     hash_table *tab;
+     sb *key;
+     int name;
+{
+  hash_entry *ptr = hash_create (tab, key);
+  ptr->value.i = name;
+}
+
+/* Look up sb key in hash_table tab.
+   If found, return hash_entry result, else 0.  */
+
+static hash_entry *
+hash_lookup (tab, key)
+     hash_table *tab;
+     sb *key;
+{
+  int k = hash (key) % tab->size;
+  hash_entry **table = tab->table;
+  hash_entry *p = table[k];
+  while (p)
+    {
+      if (p->key.len == key->len
+	  && strncmp (p->key.ptr, key->ptr, key->len) == 0)
+	return p;
+      p = p->next;
+    }
+  return 0;
+}
+
+/* expressions
+
+   are handled in a really simple recursive decent way. each bit of
+   the machine takes an index into an sb and a pointer to an exp_t,
+   modifies the *exp_t and returns the index of the first character
+   past the part of the expression parsed.
+
+ expression precedence:
+  ( )
+ unary + - ~
+  * /
+  + -
+  &
+  | ~
+*/
+
+/* Make sure that the exp_t at term is constant.
+   If not the give the op ERROR.  */
+
+static void
+checkconst (op, term)
+     int op;
+     exp_t *term;
+{
+  if (term->add_symbol.len
+      || term->sub_symbol.len)
+    {
+      ERROR ((stderr, _("the %c operator cannot take non-absolute arguments.\n"), op));
+    }
+}
+
+/* Chew the flonum from the string starting at idx.  Adjust idx to
+   point to the next character after the flonum.  */
+
+static int
+chew_flonum (idx, string, out)
+     int idx;
+     sb *string;
+     sb *out;
+{
+  sb buf;
+  regex_t reg;
+  regmatch_t match;
+
+  /* Duplicate and null terminate `string'.  */
+  sb_new (&buf);
+  sb_add_sb (&buf, string);
+  sb_add_char (&buf, '\0');
+
+  if (regcomp (&reg, "([0-9]*\\.[0-9]+([eE][+-]?[0-9]+)?)", REG_EXTENDED) != 0)
+    return idx;
+  if (regexec (&reg, &buf.ptr[idx], 1, &match, 0) != 0)
+    return idx;
+
+  /* Copy the match to the output.  */
+  assert (match.rm_eo >= match.rm_so);
+  sb_add_buffer (out, &buf.ptr[idx], match.rm_eo - match.rm_so);
+
+  sb_kill (&buf);
+  regfree (&reg);
+  idx += match.rm_eo;
+  return idx;
+}
+
+static int
+is_flonum (idx, string)
+     int idx;
+     sb *string;
+{
+  sb buf;
+  regex_t reg;
+  int rc;
+
+  /* Duplicate and null terminate `string'.  */
+  sb_new (&buf);
+  sb_add_sb (&buf, string);
+  sb_add_char (&buf, '\0');
+
+  if (regcomp (&reg, "^[0-9]*\\.[0-9]+([eE][+-]?[0-9]+)?", REG_EXTENDED) != 0)
+    return 0;
+
+  rc = regexec (&reg, &buf.ptr[idx], 0, NULL, 0);
+  sb_kill (&buf);
+  regfree (&reg);
+  return (rc == 0);
+}
+
+/* Turn the number in string at idx into a number of base, fill in
+   ptr, and return the index of the first character not in the number.  */
+
+static int
+sb_strtol (idx, string, base, ptr)
+     int idx;
+     sb *string;
+     int base;
+     int *ptr;
+{
+  int value = 0;
+  idx = sb_skip_white (idx, string);
+
+  while (idx < string->len)
+    {
+      int ch = string->ptr[idx];
+      int dig = 0;
+      if (ISDIGIT (ch))
+	dig = ch - '0';
+      else if (ch >= 'a' && ch <= 'f')
+	dig = ch - 'a' + 10;
+      else if (ch >= 'A' && ch <= 'F')
+	dig = ch - 'A' + 10;
+      else
+	break;
+
+      if (dig >= base)
+	break;
+
+      value = value * base + dig;
+      idx++;
+    }
+  *ptr = value;
+  return idx;
+}
+
+static int
+level_0 (idx, string, lhs)
+     int idx;
+     sb *string;
+     exp_t *lhs;
+{
+  lhs->add_symbol.len = 0;
+  lhs->add_symbol.name = 0;
+
+  lhs->sub_symbol.len = 0;
+  lhs->sub_symbol.name = 0;
+
+  idx = sb_skip_white (idx, string);
+
+  lhs->value = 0;
+
+  if (ISDIGIT (string->ptr[idx]))
+    {
+      idx = sb_strtol (idx, string, 10, &lhs->value);
+    }
+  else if (ISFIRSTCHAR (string->ptr[idx]))
+    {
+      int len = 0;
+      lhs->add_symbol.name = string->ptr + idx;
+      while (idx < string->len && ISNEXTCHAR (string->ptr[idx]))
+	{
+	  idx++;
+	  len++;
+	}
+      lhs->add_symbol.len = len;
+    }
+  else if (string->ptr[idx] == '"')
+    {
+      sb acc;
+      sb_new (&acc);
+      ERROR ((stderr, _("string where expression expected.\n")));
+      idx = getstring (idx, string, &acc);
+      sb_kill (&acc);
+    }
+  else
+    {
+      ERROR ((stderr, _("can't find primary in expression.\n")));
+      idx++;
+    }
+  return sb_skip_white (idx, string);
+}
+
+static int
+level_1 (idx, string, lhs)
+     int idx;
+     sb *string;
+     exp_t *lhs;
+{
+  idx = sb_skip_white (idx, string);
+
+  switch (string->ptr[idx])
+    {
+    case '+':
+      idx = level_1 (idx + 1, string, lhs);
+      break;
+    case '~':
+      idx = level_1 (idx + 1, string, lhs);
+      checkconst ('~', lhs);
+      lhs->value = ~lhs->value;
+      break;
+    case '-':
+      {
+	symbol t;
+	idx = level_1 (idx + 1, string, lhs);
+	lhs->value = -lhs->value;
+	t = lhs->add_symbol;
+	lhs->add_symbol = lhs->sub_symbol;
+	lhs->sub_symbol = t;
+	break;
+      }
+    case '(':
+      idx++;
+      idx = level_5 (sb_skip_white (idx, string), string, lhs);
+      if (string->ptr[idx] != ')')
+	ERROR ((stderr, _("misplaced closing parens.\n")));
+      else
+	idx++;
+      break;
+    default:
+      idx = level_0 (idx, string, lhs);
+      break;
+    }
+  return sb_skip_white (idx, string);
+}
+
+static int
+level_2 (idx, string, lhs)
+     int idx;
+     sb *string;
+     exp_t *lhs;
+{
+  exp_t rhs;
+
+  idx = level_1 (idx, string, lhs);
+
+  while (idx < string->len && (string->ptr[idx] == '*'
+			       || string->ptr[idx] == '/'))
+    {
+      char op = string->ptr[idx++];
+      idx = level_1 (idx, string, &rhs);
+      switch (op)
+	{
+	case '*':
+	  checkconst ('*', lhs);
+	  checkconst ('*', &rhs);
+	  lhs->value *= rhs.value;
+	  break;
+	case '/':
+	  checkconst ('/', lhs);
+	  checkconst ('/', &rhs);
+	  if (rhs.value == 0)
+	    ERROR ((stderr, _("attempt to divide by zero.\n")));
+	  else
+	    lhs->value /= rhs.value;
+	  break;
+	}
+    }
+  return sb_skip_white (idx, string);
+}
+
+static int
+level_3 (idx, string, lhs)
+     int idx;
+     sb *string;
+     exp_t *lhs;
+{
+  exp_t rhs;
+
+  idx = level_2 (idx, string, lhs);
+
+  while (idx < string->len
+	 && (string->ptr[idx] == '+'
+	     || string->ptr[idx] == '-'))
+    {
+      char op = string->ptr[idx++];
+      idx = level_2 (idx, string, &rhs);
+      switch (op)
+	{
+	case '+':
+	  lhs->value += rhs.value;
+	  if (lhs->add_symbol.name && rhs.add_symbol.name)
+	    {
+	      ERROR ((stderr, _("can't add two relocatable expressions\n")));
+	    }
+	  /* Change nn+symbol to symbol + nn.  */
+	  if (rhs.add_symbol.name)
+	    {
+	      lhs->add_symbol = rhs.add_symbol;
+	    }
+	  break;
+	case '-':
+	  lhs->value -= rhs.value;
+	  lhs->sub_symbol = rhs.add_symbol;
+	  break;
+	}
+    }
+  return sb_skip_white (idx, string);
+}
+
+static int
+level_4 (idx, string, lhs)
+     int idx;
+     sb *string;
+     exp_t *lhs;
+{
+  exp_t rhs;
+
+  idx = level_3 (idx, string, lhs);
+
+  while (idx < string->len &&
+	 string->ptr[idx] == '&')
+    {
+      char op = string->ptr[idx++];
+      idx = level_3 (idx, string, &rhs);
+      switch (op)
+	{
+	case '&':
+	  checkconst ('&', lhs);
+	  checkconst ('&', &rhs);
+	  lhs->value &= rhs.value;
+	  break;
+	}
+    }
+  return sb_skip_white (idx, string);
+}
+
+static int
+level_5 (idx, string, lhs)
+     int idx;
+     sb *string;
+     exp_t *lhs;
+{
+  exp_t rhs;
+
+  idx = level_4 (idx, string, lhs);
+
+  while (idx < string->len
+	 && (string->ptr[idx] == '|' || string->ptr[idx] == '~'))
+    {
+      char op = string->ptr[idx++];
+      idx = level_4 (idx, string, &rhs);
+      switch (op)
+	{
+	case '|':
+	  checkconst ('|', lhs);
+	  checkconst ('|', &rhs);
+	  lhs->value |= rhs.value;
+	  break;
+	case '~':
+	  checkconst ('~', lhs);
+	  checkconst ('~', &rhs);
+	  lhs->value ^= rhs.value;
+	  break;
+	}
+    }
+  return sb_skip_white (idx, string);
+}
+
+/* Parse the expression at offset idx into string, fill up res with
+   the result.  Return the index of the first char past the
+   expression.  */
+
+static int
+exp_parse (idx, string, res)
+     int idx;
+     sb *string;
+     exp_t *res;
+{
+  return level_5 (sb_skip_white (idx, string), string, res);
+}
+
+/* Turn the expression at exp into text and glue it onto the end of
+   string.  */
+
+static void
+exp_string (exp, string)
+     exp_t *exp;
+     sb *string;
+{
+  int np = 0;
+  int ad = 0;
+  sb_reset (string);
+
+  if (exp->add_symbol.len)
+    {
+      sb_add_buffer (string, exp->add_symbol.name, exp->add_symbol.len);
+      np = 1;
+      ad = 1;
+    }
+  if (exp->value)
+    {
+      char buf[20];
+      if (np)
+	sb_add_char (string, '+');
+      sprintf (buf, "%d", exp->value);
+      sb_add_string (string, buf);
+      np = 1;
+      ad = 1;
+    }
+  if (exp->sub_symbol.len)
+    {
+      sb_add_char (string, '-');
+      sb_add_buffer (string, exp->add_symbol.name, exp->add_symbol.len);
+      np = 0;
+      ad = 1;
+    }
+
+  if (!ad)
+    sb_add_char (string, '0');
+}
+
+/* Parse the expression at offset idx into sb in.  Return the value in
+   val.  If the expression is not constant, give ERROR emsg.  Return
+   the index of the first character past the end of the expression.  */
+
+static int
+exp_get_abs (emsg, idx, in, val)
+     const char *emsg;
+     int idx;
+     sb *in;
+     int *val;
+{
+  exp_t res;
+  idx = exp_parse (idx, in, &res);
+  if (res.add_symbol.len || res.sub_symbol.len)
+    ERROR ((stderr, "%s", emsg));
+  *val = res.value;
+  return idx;
+}
+
+/* Current label parsed from line.  */
+sb label;
+
+/* Hash table for all assigned variables.  */
+hash_table assign_hash_table;
+
+/* Hash table for keyword.  */
+hash_table keyword_hash_table;
+
+/* Hash table for eq variables.  */
+hash_table vars;
+
+#define in_comment ';'
+
+#if 0
+static void
+strip_comments (out)
+     sb *out;
+{
+  char *s = out->ptr;
+  int i = 0;
+  for (i = 0; i < out->len; i++)
+    {
+      if (ISCOMMENTCHAR (s[i]))
+	{
+	  out->len = i;
+	  return;
+	}
+    }
+}
+#endif
+
+/* Push back character ch so that it can be read again.  */
+
+static void
+unget (ch)
+     int ch;
+{
+  if (ch == '\n')
+    {
+      sp->linecount--;
+    }
+  if (sp->pushback_index)
+    sp->pushback_index--;
+  else
+    sb_add_char (&sp->pushback, ch);
+}
+
+/* Push the sb ptr onto the include stack, with the given name, type
+   and index.  */
+
+static void
+include_buf (name, ptr, type, index)
+     sb *name;
+     sb *ptr;
+     include_type type;
+     int index;
+{
+  sp++;
+  if (sp - include_stack >= MAX_INCLUDES)
+    FATAL ((stderr, _("unreasonable nesting.\n")));
+  sb_new (&sp->name);
+  sb_add_sb (&sp->name, name);
+  sp->handle = 0;
+  sp->linecount = 1;
+  sp->pushback_index = 0;
+  sp->type = type;
+  sp->index = index;
+  sb_new (&sp->pushback);
+  sb_add_sb (&sp->pushback, ptr);
+}
+
+/* Used in ERROR messages, print info on where the include stack is
+   onto file.  */
+
+static void
+include_print_where_line (file)
+     FILE *file;
+{
+  struct include_stack *p = include_stack + 1;
+
+  while (p <= sp)
+    {
+      fprintf (file, "%s:%d ", sb_name (&p->name), p->linecount - 1);
+      p++;
+    }
+}
+
+/* Used in listings, print the line number onto file.  */
+
+static void
+include_print_line (file)
+     FILE *file;
+{
+  int n;
+  struct include_stack *p = include_stack + 1;
+
+  n = fprintf (file, "%4d", p->linecount);
+  p++;
+  while (p <= sp)
+    {
+      n += fprintf (file, ".%d", p->linecount);
+      p++;
+    }
+  while (n < 8 * 3)
+    {
+      fprintf (file, " ");
+      n++;
+    }
+}
+
+/* Read a line from the top of the include stack into sb in.  */
+
+static int
+get_line (in)
+     sb *in;
+{
+  int online = 0;
+  int more = 1;
+
+  if (copysource)
+    {
+      putc (comment_char, outfile);
+      if (print_line_number)
+	include_print_line (outfile);
+    }
+
+  while (1)
+    {
+      int ch = get ();
+
+      while (ch == '\r')
+	ch = get ();
+
+      if (ch == EOF)
+	{
+	  if (online)
+	    {
+	      WARNING ((stderr, _("End of file not at start of line.\n")));
+	      if (copysource)
+		putc ('\n', outfile);
+	      ch = '\n';
+	    }
+	  else
+	    more = 0;
+	  break;
+	}
+
+      if (copysource)
+	{
+	  putc (ch, outfile);
+	}
+
+      if (ch == '\n')
+	{
+	  ch = get ();
+	  online = 0;
+	  if (ch == '+')
+	    {
+	      /* Continued line.  */
+	      if (copysource)
+		{
+		  putc (comment_char, outfile);
+		  putc ('+', outfile);
+		}
+	      ch = get ();
+	    }
+	  else
+	    {
+	      if (ch != EOF)
+		unget (ch);
+	      break;
+	    }
+	}
+      else
+	{
+	  sb_add_char (in, ch);
+	}
+      online++;
+    }
+
+  return more;
+}
+
+/* Find a label from sb in and put it in out.  */
+
+static int
+grab_label (in, out)
+     sb *in;
+     sb *out;
+{
+  int i = 0;
+  sb_reset (out);
+  if (ISFIRSTCHAR (in->ptr[i]) || in->ptr[i] == '\\')
+    {
+      sb_add_char (out, in->ptr[i]);
+      i++;
+      while ((ISNEXTCHAR (in->ptr[i])
+	      || in->ptr[i] == '\\'
+	      || in->ptr[i] == '&')
+	     && i < in->len)
+	{
+	  sb_add_char (out, in->ptr[i]);
+	  i++;
+	}
+    }
+  return i;
+}
+
+/* Find all strange base stuff and turn into decimal.  Also
+   find all the other numbers and convert them from the default radix.  */
+
+static void
+change_base (idx, in, out)
+     int idx;
+     sb *in;
+     sb *out;
+{
+  char buffer[20];
+
+  while (idx < in->len)
+    {
+      if (in->ptr[idx] == '\\'
+	  && idx + 1 < in->len
+	  && in->ptr[idx + 1] == '(')
+	{
+	  idx += 2;
+	  while (idx < in->len
+		 && in->ptr[idx] != ')')
+	    {
+	      sb_add_char (out, in->ptr[idx]);
+	      idx++;
+	    }
+	  if (idx < in->len)
+	    idx++;
+	}
+      else if (idx < in->len - 1 && in->ptr[idx + 1] == '\'' && ! mri)
+	{
+	  int base;
+	  int value;
+	  switch (in->ptr[idx])
+	    {
+	    case 'b':
+	    case 'B':
+	      base = 2;
+	      break;
+	    case 'q':
+	    case 'Q':
+	      base = 8;
+	      break;
+	    case 'h':
+	    case 'H':
+	      base = 16;
+	      break;
+	    case 'd':
+	    case 'D':
+	      base = 10;
+	      break;
+	    default:
+	      ERROR ((stderr, _("Illegal base character %c.\n"), in->ptr[idx]));
+	      base = 10;
+	      break;
+	    }
+
+	  idx = sb_strtol (idx + 2, in, base, &value);
+	  sprintf (buffer, "%d", value);
+	  sb_add_string (out, buffer);
+	}
+      else if (ISFIRSTCHAR (in->ptr[idx]))
+	{
+	  /* Copy entire names through quickly.  */
+	  sb_add_char (out, in->ptr[idx]);
+	  idx++;
+	  while (idx < in->len && ISNEXTCHAR (in->ptr[idx]))
+	    {
+	      sb_add_char (out, in->ptr[idx]);
+	      idx++;
+	    }
+	}
+      else if (is_flonum (idx, in))
+	{
+	  idx = chew_flonum (idx, in, out);
+	}
+      else if (ISDIGIT (in->ptr[idx]))
+	{
+	  int value;
+	  /* All numbers must start with a digit, let's chew it and
+	     spit out decimal.  */
+	  idx = sb_strtol (idx, in, radix, &value);
+	  sprintf (buffer, "%d", value);
+	  sb_add_string (out, buffer);
+
+	  /* Skip all undigsested letters.  */
+	  while (idx < in->len && ISNEXTCHAR (in->ptr[idx]))
+	    {
+	      sb_add_char (out, in->ptr[idx]);
+	      idx++;
+	    }
+	}
+      else if (in->ptr[idx] == '"' || in->ptr[idx] == '\'')
+	{
+	  char tchar = in->ptr[idx];
+	  /* Copy entire names through quickly.  */
+	  sb_add_char (out, in->ptr[idx]);
+	  idx++;
+	  while (idx < in->len && in->ptr[idx] != tchar)
+	    {
+	      sb_add_char (out, in->ptr[idx]);
+	      idx++;
+	    }
+	}
+      else
+	{
+	  /* Nothing special, just pass it through.  */
+	  sb_add_char (out, in->ptr[idx]);
+	  idx++;
+	}
+    }
+
+}
+
+/* .end  */
+
+static void
+do_end (in)
+     sb *in;
+{
+  had_end = 1;
+  if (mri)
+    fprintf (outfile, "%s\n", sb_name (in));
+}
+
+/* .assign  */
+
+static void
+do_assign (again, idx, in)
+     int again;
+     int idx;
+     sb *in;
+{
+  /* Stick label in symbol table with following value.  */
+  exp_t e;
+  sb acc;
+
+  sb_new (&acc);
+  idx = exp_parse (idx, in, &e);
+  exp_string (&e, &acc);
+  hash_add_to_string_table (&assign_hash_table, &label, &acc, again);
+  sb_kill (&acc);
+}
+
+/* .radix [b|q|d|h]  */
+
+static void
+do_radix (ptr)
+     sb *ptr;
+{
+  int idx = sb_skip_white (0, ptr);
+  switch (ptr->ptr[idx])
+    {
+    case 'B':
+    case 'b':
+      radix = 2;
+      break;
+    case 'q':
+    case 'Q':
+      radix = 8;
+      break;
+    case 'd':
+    case 'D':
+      radix = 10;
+      break;
+    case 'h':
+    case 'H':
+      radix = 16;
+      break;
+    default:
+      ERROR ((stderr, _("radix is %c must be one of b, q, d or h"), radix));
+    }
+}
+
+/* Parse off a .b, .w or .l.  */
+
+static int
+get_opsize (idx, in, size)
+     int idx;
+     sb *in;
+     int *size;
+{
+  *size = 4;
+  if (in->ptr[idx] == '.')
+    {
+      idx++;
+    }
+  switch (in->ptr[idx])
+    {
+    case 'b':
+    case 'B':
+      *size = 1;
+      break;
+    case 'w':
+    case 'W':
+      *size = 2;
+      break;
+    case 'l':
+    case 'L':
+      *size = 4;
+      break;
+    case ' ':
+    case '\t':
+      break;
+    default:
+      ERROR ((stderr, _("size must be one of b, w or l, is %c.\n"), in->ptr[idx]));
+      break;
+    }
+  idx++;
+
+  return idx;
+}
+
+static int
+eol (idx, line)
+     int idx;
+     sb *line;
+{
+  idx = sb_skip_white (idx, line);
+  if (idx < line->len
+      && ISCOMMENTCHAR(line->ptr[idx]))
+    return 1;
+  if (idx >= line->len)
+    return 1;
+  return 0;
+}
+
+/* .data [.b|.w|.l] <data>*
+    or d[bwl] <data>*  */
+
+static void
+do_data (idx, in, size)
+     int idx;
+     sb *in;
+     int size;
+{
+  int opsize = 4;
+  char *opname = ".yikes!";
+  sb acc;
+  sb_new (&acc);
+
+  if (!size)
+    {
+      idx = get_opsize (idx, in, &opsize);
+    }
+  else
+    {
+      opsize = size;
+    }
+  switch (opsize)
+    {
+    case 4:
+      opname = ".long";
+      break;
+    case 2:
+      opname = ".short";
+      break;
+    case 1:
+      opname = ".byte";
+      break;
+    }
+
+  fprintf (outfile, "%s\t", opname);
+
+  idx = sb_skip_white (idx, in);
+
+  if (alternate
+      && idx < in->len
+      && in->ptr[idx] == '"')
+    {
+      int i;
+      idx = getstring (idx, in, &acc);
+      for (i = 0; i < acc.len; i++)
+	{
+	  if (i)
+	    fprintf (outfile, ",");
+	  fprintf (outfile, "%d", acc.ptr[i]);
+	}
+    }
+  else
+    {
+      while (!eol (idx, in))
+	{
+	  exp_t e;
+	  idx = exp_parse (idx, in, &e);
+	  exp_string (&e, &acc);
+	  sb_add_char (&acc, 0);
+	  fprintf (outfile, "%s", acc.ptr);
+	  if (idx < in->len && in->ptr[idx] == ',')
+	    {
+	      fprintf (outfile, ",");
+	      idx++;
+	    }
+	}
+    }
+  sb_kill (&acc);
+  sb_print_at (outfile, idx, in);
+  fprintf (outfile, "\n");
+}
+
+/* .datab [.b|.w|.l] <repeat>,<fill>  */
+
+static void
+do_datab (idx, in)
+     int idx;
+     sb *in;
+{
+  int opsize;
+  int repeat;
+  int fill;
+
+  idx = get_opsize (idx, in, &opsize);
+
+  idx = exp_get_abs (_("datab repeat must be constant.\n"), idx, in, &repeat);
+  idx = sb_skip_comma (idx, in);
+  idx = exp_get_abs (_("datab data must be absolute.\n"), idx, in, &fill);
+
+  fprintf (outfile, ".fill\t%d,%d,%d\n", repeat, opsize, fill);
+}
+
+/* .align <size>  */
+
+static void
+do_align (idx, in)
+     int idx;
+     sb *in;
+{
+  int al, have_fill, fill;
+
+  idx = exp_get_abs (_("align needs absolute expression.\n"), idx, in, &al);
+  idx = sb_skip_white (idx, in);
+  have_fill = 0;
+  fill = 0;
+  if (! eol (idx, in))
+    {
+      idx = sb_skip_comma (idx, in);
+      idx = exp_get_abs (_(".align needs absolute fill value.\n"), idx, in,
+			 &fill);
+      have_fill = 1;
+    }
+
+  fprintf (outfile, ".align	%d", al);
+  if (have_fill)
+    fprintf (outfile, ",%d", fill);
+  fprintf (outfile, "\n");
+}
+
+/* .res[.b|.w|.l] <size>  */
+
+static void
+do_res (idx, in, type)
+     int idx;
+     sb *in;
+     int type;
+{
+  int size = 4;
+  int count = 0;
+
+  idx = get_opsize (idx, in, &size);
+  while (!eol (idx, in))
+    {
+      idx = sb_skip_white (idx, in);
+      if (in->ptr[idx] == ',')
+	idx++;
+      idx = exp_get_abs (_("res needs absolute expression for fill count.\n"), idx, in, &count);
+
+      if (type == 'c' || type == 'z')
+	count++;
+
+      fprintf (outfile, ".space	%d\n", count * size);
+    }
+}
+
+/* .export  */
+
+static void
+do_export (in)
+     sb *in;
+{
+  fprintf (outfile, ".global	%s\n", sb_name (in));
+}
+
+/* .print [list] [nolist]  */
+
+static void
+do_print (idx, in)
+     int idx;
+     sb *in;
+{
+  idx = sb_skip_white (idx, in);
+  while (idx < in->len)
+    {
+      if (strncasecmp (in->ptr + idx, "LIST", 4) == 0)
+	{
+	  fprintf (outfile, ".list\n");
+	  idx += 4;
+	}
+      else if (strncasecmp (in->ptr + idx, "NOLIST", 6) == 0)
+	{
+	  fprintf (outfile, ".nolist\n");
+	  idx += 6;
+	}
+      idx++;
+    }
+}
+
+/* .head  */
+
+static void
+do_heading (idx, in)
+     int idx;
+     sb *in;
+{
+  sb head;
+  sb_new (&head);
+  idx = getstring (idx, in, &head);
+  fprintf (outfile, ".title	\"%s\"\n", sb_name (&head));
+  sb_kill (&head);
+}
+
+/* .page  */
+
+static void
+do_page ()
+{
+  fprintf (outfile, ".eject\n");
+}
+
+/* .form [lin=<value>] [col=<value>]  */
+
+static void
+do_form (idx, in)
+     int idx;
+     sb *in;
+{
+  int lines = 60;
+  int columns = 132;
+  idx = sb_skip_white (idx, in);
+
+  while (idx < in->len)
+    {
+
+      if (strncasecmp (in->ptr + idx, "LIN=", 4) == 0)
+	{
+	  idx += 4;
+	  idx = exp_get_abs (_("form LIN= needs absolute expresssion.\n"), idx, in, &lines);
+	}
+
+      if (strncasecmp (in->ptr + idx, _("COL="), 4) == 0)
+	{
+	  idx += 4;
+	  idx = exp_get_abs (_("form COL= needs absolute expresssion.\n"), idx, in, &columns);
+	}
+
+      idx++;
+    }
+  fprintf (outfile, ".psize %d,%d\n", lines, columns);
+
+}
+
+/* Fetch string from the input stream,
+   rules:
+    'Bxyx<whitespace>  	-> return 'Bxyza
+    %<char>		-> return string of decimal value of x
+    "<string>"		-> return string
+    xyx<whitespace>     -> return xyz
+*/
+
+static int
+get_any_string (idx, in, out, expand, pretend_quoted)
+     int idx;
+     sb *in;
+     sb *out;
+     int expand;
+     int pretend_quoted;
+{
+  sb_reset (out);
+  idx = sb_skip_white (idx, in);
+
+  if (idx < in->len)
+    {
+      if (in->len > 2 && in->ptr[idx + 1] == '\'' && ISBASE (in->ptr[idx]))
+	{
+	  while (!ISSEP (in->ptr[idx]))
+	    sb_add_char (out, in->ptr[idx++]);
+	}
+      else if (in->ptr[idx] == '%'
+	       && alternate
+	       && expand)
+	{
+	  int val;
+	  char buf[20];
+	  /* Turns the next expression into a string.  */
+	  /* xgettext: no-c-format */
+	  idx = exp_get_abs (_("% operator needs absolute expression"),
+			     idx + 1,
+			     in,
+			     &val);
+	  sprintf (buf, "%d", val);
+	  sb_add_string (out, buf);
+	}
+      else if (in->ptr[idx] == '"'
+	       || in->ptr[idx] == '<'
+	       || (alternate && in->ptr[idx] == '\''))
+	{
+	  if (alternate && expand)
+	    {
+	      /* Keep the quotes.  */
+	      sb_add_char (out, '\"');
+
+	      idx = getstring (idx, in, out);
+	      sb_add_char (out, '\"');
+
+	    }
+	  else
+	    {
+	      idx = getstring (idx, in, out);
+	    }
+	}
+      else
+	{
+	  while (idx < in->len
+		 && (in->ptr[idx] == '"'
+		     || in->ptr[idx] == '\''
+		     || pretend_quoted
+		     || !ISSEP (in->ptr[idx])))
+	    {
+	      if (in->ptr[idx] == '"'
+		  || in->ptr[idx] == '\'')
+		{
+		  char tchar = in->ptr[idx];
+		  sb_add_char (out, in->ptr[idx++]);
+		  while (idx < in->len
+			 && in->ptr[idx] != tchar)
+		    sb_add_char (out, in->ptr[idx++]);
+		  if (idx == in->len)
+		    return idx;
+		}
+	      sb_add_char (out, in->ptr[idx++]);
+	    }
+	}
+    }
+
+  return idx;
+}
+
+/* Skip along sb in starting at idx, suck off whitespace a ( and more
+   whitespace.  Return the idx of the next char.  */
+
+static int
+skip_openp (idx, in)
+     int idx;
+     sb *in;
+{
+  idx = sb_skip_white (idx, in);
+  if (in->ptr[idx] != '(')
+    ERROR ((stderr, _("misplaced ( .\n")));
+  idx = sb_skip_white (idx + 1, in);
+  return idx;
+}
+
+/* Skip along sb in starting at idx, suck off whitespace a ) and more
+   whitespace.  Return the idx of the next char.  */
+
+static int
+skip_closep (idx, in)
+     int idx;
+     sb *in;
+{
+  idx = sb_skip_white (idx, in);
+  if (in->ptr[idx] != ')')
+    ERROR ((stderr, _("misplaced ).\n")));
+  idx = sb_skip_white (idx + 1, in);
+  return idx;
+}
+
+/* .len  */
+
+static int
+dolen (idx, in, out)
+     int idx;
+     sb *in;
+     sb *out;
+{
+
+  sb stringout;
+  char buffer[10];
+
+  sb_new (&stringout);
+  idx = skip_openp (idx, in);
+  idx = get_and_process (idx, in, &stringout);
+  idx = skip_closep (idx, in);
+  sprintf (buffer, "%d", stringout.len);
+  sb_add_string (out, buffer);
+
+  sb_kill (&stringout);
+  return idx;
+}
+
+/* .instr  */
+
+static int
+doinstr (idx, in, out)
+     int idx;
+     sb *in;
+     sb *out;
+{
+  sb string;
+  sb search;
+  int i;
+  int start;
+  int res;
+  char buffer[10];
+
+  sb_new (&string);
+  sb_new (&search);
+  idx = skip_openp (idx, in);
+  idx = get_and_process (idx, in, &string);
+  idx = sb_skip_comma (idx, in);
+  idx = get_and_process (idx, in, &search);
+  idx = sb_skip_comma (idx, in);
+  if (ISDIGIT (in->ptr[idx]))
+    {
+      idx = exp_get_abs (_(".instr needs absolute expresson.\n"), idx, in, &start);
+    }
+  else
+    {
+      start = 0;
+    }
+  idx = skip_closep (idx, in);
+  res = -1;
+  for (i = start; i < string.len; i++)
+    {
+      if (strncmp (string.ptr + i, search.ptr, search.len) == 0)
+	{
+	  res = i;
+	  break;
+	}
+    }
+  sprintf (buffer, "%d", res);
+  sb_add_string (out, buffer);
+  sb_kill (&string);
+  sb_kill (&search);
+  return idx;
+}
+
+static int
+dosubstr (idx, in, out)
+     int idx;
+     sb *in;
+     sb *out;
+{
+  sb string;
+  int pos;
+  int len;
+  sb_new (&string);
+
+  idx = skip_openp (idx, in);
+  idx = get_and_process (idx, in, &string);
+  idx = sb_skip_comma (idx, in);
+  idx = exp_get_abs (_("need absolute position.\n"), idx, in, &pos);
+  idx = sb_skip_comma (idx, in);
+  idx = exp_get_abs (_("need absolute length.\n"), idx, in, &len);
+  idx = skip_closep (idx, in);
+
+  if (len < 0 || pos < 0 ||
+      pos > string.len
+      || pos + len > string.len)
+    {
+      sb_add_string (out, " ");
+    }
+  else
+    {
+      sb_add_char (out, '"');
+      while (len > 0)
+	{
+	  sb_add_char (out, string.ptr[pos++]);
+	  len--;
+	}
+      sb_add_char (out, '"');
+    }
+  sb_kill (&string);
+  return idx;
+}
+
+/* Scan line, change tokens in the hash table to their replacements.  */
+
+static void
+process_assigns (idx, in, buf)
+     int idx;
+     sb *in;
+     sb *buf;
+{
+  while (idx < in->len)
+    {
+      hash_entry *ptr;
+      if (in->ptr[idx] == '\\'
+	  && idx + 1 < in->len
+	  && in->ptr[idx + 1] == '(')
+	{
+	  do
+	    {
+	      sb_add_char (buf, in->ptr[idx]);
+	      idx++;
+	    }
+	  while (idx < in->len && in->ptr[idx - 1] != ')');
+	}
+      else if (in->ptr[idx] == '\\'
+	  && idx + 1 < in->len
+	  && in->ptr[idx + 1] == '&')
+	{
+	  idx = condass_lookup_name (in, idx + 2, buf, 1);
+	}
+      else if (in->ptr[idx] == '\\'
+	       && idx + 1 < in->len
+	       && in->ptr[idx + 1] == '$')
+	{
+	  idx = condass_lookup_name (in, idx + 2, buf, 0);
+	}
+      else if (idx + 3 < in->len
+	       && in->ptr[idx] == '.'
+	       && TOUPPER (in->ptr[idx + 1]) == 'L'
+	       && TOUPPER (in->ptr[idx + 2]) == 'E'
+	       && TOUPPER (in->ptr[idx + 3]) == 'N')
+	idx = dolen (idx + 4, in, buf);
+      else if (idx + 6 < in->len
+	       && in->ptr[idx] == '.'
+	       && TOUPPER (in->ptr[idx + 1]) == 'I'
+	       && TOUPPER (in->ptr[idx + 2]) == 'N'
+	       && TOUPPER (in->ptr[idx + 3]) == 'S'
+	       && TOUPPER (in->ptr[idx + 4]) == 'T'
+	       && TOUPPER (in->ptr[idx + 5]) == 'R')
+	idx = doinstr (idx + 6, in, buf);
+      else if (idx + 7 < in->len
+	       && in->ptr[idx] == '.'
+	       && TOUPPER (in->ptr[idx + 1]) == 'S'
+	       && TOUPPER (in->ptr[idx + 2]) == 'U'
+	       && TOUPPER (in->ptr[idx + 3]) == 'B'
+	       && TOUPPER (in->ptr[idx + 4]) == 'S'
+	       && TOUPPER (in->ptr[idx + 5]) == 'T'
+	       && TOUPPER (in->ptr[idx + 6]) == 'R')
+	idx = dosubstr (idx + 7, in, buf);
+      else if (ISFIRSTCHAR (in->ptr[idx]))
+	{
+	  /* May be a simple name subsitution, see if we have a word.  */
+	  sb acc;
+	  int cur = idx + 1;
+	  while (cur < in->len
+		 && (ISNEXTCHAR (in->ptr[cur])))
+	    cur++;
+
+	  sb_new (&acc);
+	  sb_add_buffer (&acc, in->ptr + idx, cur - idx);
+	  ptr = hash_lookup (&assign_hash_table, &acc);
+	  if (ptr)
+	    {
+	      /* Found a definition for it.  */
+	      sb_add_sb (buf, &ptr->value.s);
+	    }
+	  else
+	    {
+	      /* No definition, just copy the word.  */
+	      sb_add_sb (buf, &acc);
+	    }
+	  sb_kill (&acc);
+	  idx = cur;
+	}
+      else
+	{
+	  sb_add_char (buf, in->ptr[idx++]);
+	}
+    }
+}
+
+static int
+get_and_process (idx, in, out)
+     int idx;
+     sb *in;
+     sb *out;
+{
+  sb t;
+  sb_new (&t);
+  idx = get_any_string (idx, in, &t, 1, 0);
+  process_assigns (0, &t, out);
+  sb_kill (&t);
+  return idx;
+}
+
+static void
+process_file ()
+{
+  sb line;
+  sb t1, t2;
+  sb acc;
+  sb label_in;
+  int more;
+
+  sb_new (&line);
+  sb_new (&t1);
+  sb_new (&t2);
+  sb_new (&acc);
+  sb_new (&label_in);
+  sb_reset (&line);
+  more = get_line (&line);
+  while (more)
+    {
+      /* Find any label and pseudo op that we're intested in.  */
+      int l;
+      if (line.len == 0)
+	{
+	  if (condass_on ())
+	    fprintf (outfile, "\n");
+	}
+      else if (mri
+	       && (line.ptr[0] == '*'
+		   || line.ptr[0] == '!'))
+	{
+	  /* MRI line comment.  */
+	  fprintf (outfile, "%s", sb_name (&line));
+	}
+      else
+	{
+	  l = grab_label (&line, &label_in);
+	  sb_reset (&label);
+
+	  if (line.ptr[l] == ':')
+	    l++;
+	  while (ISWHITE (line.ptr[l]) && l < line.len)
+	    l++;
+
+	  if (label_in.len)
+	    {
+	      int do_assigns;
+
+	      /* Munge the label, unless this is EQU or ASSIGN.  */
+	      do_assigns = 1;
+	      if (l < line.len
+		  && (line.ptr[l] == '.' || alternate || mri))
+		{
+		  int lx = l;
+
+		  if (line.ptr[lx] == '.')
+		    ++lx;
+		  if (lx + 3 <= line.len
+		      && strncasecmp ("EQU", line.ptr + lx, 3) == 0
+		      && (lx + 3 == line.len
+			  || ! ISFIRSTCHAR (line.ptr[lx + 3])))
+		    do_assigns = 0;
+		  else if (lx + 6 <= line.len
+			   && strncasecmp ("ASSIGN", line.ptr + lx, 6) == 0
+			   && (lx + 6 == line.len
+			       || ! ISFIRSTCHAR (line.ptr[lx + 6])))
+		    do_assigns = 0;
+		}
+
+	      if (do_assigns)
+		process_assigns (0, &label_in, &label);
+	      else
+		sb_add_sb (&label, &label_in);
+	    }
+
+	  if (l < line.len)
+	    {
+	      if (process_pseudo_op (l, &line, &acc))
+		{
+
+		}
+	      else if (condass_on ())
+		{
+		  if (macro_op (l, &line))
+		    {
+
+		    }
+		  else
+		    {
+		      {
+			if (label.len)
+			  {
+			    fprintf (outfile, "%s:\t", sb_name (&label));
+			  }
+			else
+			  fprintf (outfile, "\t");
+			sb_reset (&t1);
+			process_assigns (l, &line, &t1);
+			sb_reset (&t2);
+			change_base (0, &t1, &t2);
+			fprintf (outfile, "%s\n", sb_name (&t2));
+		      }
+		    }
+		}
+	    }
+	  else
+	    {
+	      /* Only a label on this line.  */
+	      if (label.len && condass_on ())
+		{
+		  fprintf (outfile, "%s:\n", sb_name (&label));
+		}
+	    }
+	}
+
+      if (had_end)
+	break;
+      sb_reset (&line);
+      more = get_line (&line);
+    }
+
+  if (!had_end && !mri)
+    WARNING ((stderr, _("END missing from end of file.\n")));
+}
+
+static void
+free_old_entry (ptr)
+     hash_entry *ptr;
+{
+  if (ptr)
+    {
+      if (ptr->type == hash_string)
+	sb_kill (&ptr->value.s);
+    }
+}
+
+/* name: .ASSIGNA <value>  */
+
+static void
+do_assigna (idx, in)
+     int idx;
+     sb *in;
+{
+  sb tmp;
+  int val;
+  sb_new (&tmp);
+
+  process_assigns (idx, in, &tmp);
+  idx = exp_get_abs (_(".ASSIGNA needs constant expression argument.\n"), 0, &tmp, &val);
+
+  if (!label.len)
+    {
+      ERROR ((stderr, _(".ASSIGNA without label.\n")));
+    }
+  else
+    {
+      hash_entry *ptr = hash_create (&vars, &label);
+      free_old_entry (ptr);
+      ptr->type = hash_integer;
+      ptr->value.i = val;
+    }
+  sb_kill (&tmp);
+}
+
+/* name: .ASSIGNC <string>  */
+
+static void
+do_assignc (idx, in)
+     int idx;
+     sb *in;
+{
+  sb acc;
+  sb_new (&acc);
+  idx = getstring (idx, in, &acc);
+
+  if (!label.len)
+    {
+      ERROR ((stderr, _(".ASSIGNS without label.\n")));
+    }
+  else
+    {
+      hash_entry *ptr = hash_create (&vars, &label);
+      free_old_entry (ptr);
+      ptr->type = hash_string;
+      sb_new (&ptr->value.s);
+      sb_add_sb (&ptr->value.s, &acc);
+    }
+  sb_kill (&acc);
+}
+
+/* name: .REG (reg)  */
+
+static void
+do_reg (idx, in)
+     int idx;
+     sb *in;
+{
+  /* Remove reg stuff from inside parens.  */
+  sb what;
+  if (!mri)
+    idx = skip_openp (idx, in);
+  else
+    idx = sb_skip_white (idx, in);
+  sb_new (&what);
+  while (idx < in->len
+	 && (mri
+	     ? ! eol (idx, in)
+	     : in->ptr[idx] != ')'))
+    {
+      sb_add_char (&what, in->ptr[idx]);
+      idx++;
+    }
+  hash_add_to_string_table (&assign_hash_table, &label, &what, 1);
+  sb_kill (&what);
+}
+
+static int
+condass_lookup_name (inbuf, idx, out, warn)
+     sb *inbuf;
+     int idx;
+     sb *out;
+     int warn;
+{
+  hash_entry *ptr;
+  sb condass_acc;
+  sb_new (&condass_acc);
+
+  while (idx < inbuf->len
+	 && ISNEXTCHAR (inbuf->ptr[idx]))
+    {
+      sb_add_char (&condass_acc, inbuf->ptr[idx++]);
+    }
+
+  if (inbuf->ptr[idx] == '\'')
+    idx++;
+  ptr = hash_lookup (&vars, &condass_acc);
+
+  if (!ptr)
+    {
+      if (warn)
+	{
+	  WARNING ((stderr, _("Can't find preprocessor variable %s.\n"), sb_name (&condass_acc)));
+	}
+      else
+	{
+	  sb_add_string (out, "0");
+	}
+    }
+  else
+    {
+      if (ptr->type == hash_integer)
+	{
+	  char buffer[30];
+	  sprintf (buffer, "%d", ptr->value.i);
+	  sb_add_string (out, buffer);
+	}
+      else
+	{
+	  sb_add_sb (out, &ptr->value.s);
+	}
+    }
+  sb_kill (&condass_acc);
+  return idx;
+}
+
+#define EQ 1
+#define NE 2
+#define GE 3
+#define LT 4
+#define LE 5
+#define GT 6
+#define NEVER 7
+
+static int
+whatcond (idx, in, val)
+     int idx;
+     sb *in;
+     int *val;
+{
+  int cond;
+
+  idx = sb_skip_white (idx, in);
+  cond = NEVER;
+  if (idx + 1 < in->len)
+    {
+      char *p;
+      char a, b;
+
+      p = in->ptr + idx;
+      a = TOUPPER (p[0]);
+      b = TOUPPER (p[1]);
+      if (a == 'E' && b == 'Q')
+	cond = EQ;
+      else if (a == 'N' && b == 'E')
+	cond = NE;
+      else if (a == 'L' && b == 'T')
+	cond = LT;
+      else if (a == 'L' && b == 'E')
+	cond = LE;
+      else if (a == 'G' && b == 'T')
+	cond = GT;
+      else if (a == 'G' && b == 'E')
+	cond = GE;
+    }
+  if (cond == NEVER)
+    {
+      ERROR ((stderr, _("Comparison operator must be one of EQ, NE, LT, LE, GT or GE.\n")));
+      cond = NEVER;
+    }
+  idx = sb_skip_white (idx + 2, in);
+  *val = cond;
+  return idx;
+}
+
+static int
+istrue (idx, in)
+     int idx;
+     sb *in;
+{
+  int res;
+  sb acc_a;
+  sb cond;
+  sb acc_b;
+  sb_new (&acc_a);
+  sb_new (&cond);
+  sb_new (&acc_b);
+  idx = sb_skip_white (idx, in);
+
+  if (in->ptr[idx] == '"')
+    {
+      int cond;
+      int same;
+      /* This is a string comparision.  */
+      idx = getstring (idx, in, &acc_a);
+      idx = whatcond (idx, in, &cond);
+      idx = getstring (idx, in, &acc_b);
+      same = acc_a.len == acc_b.len
+	&& (strncmp (acc_a.ptr, acc_b.ptr, acc_a.len) == 0);
+
+      if (cond != EQ && cond != NE)
+	{
+	  ERROR ((stderr, _("Comparison operator for strings must be EQ or NE\n")));
+	  res = 0;
+	}
+      else
+	res = (cond != EQ) ^ same;
+    }
+  else
+    /* This is a numeric expression.  */
+    {
+      int vala;
+      int valb;
+      int cond;
+      idx = exp_get_abs (_("Conditional operator must have absolute operands.\n"), idx, in, &vala);
+      idx = whatcond (idx, in, &cond);
+      idx = sb_skip_white (idx, in);
+      if (in->ptr[idx] == '"')
+	{
+	  WARNING ((stderr, _("String compared against expression.\n")));
+	  res = 0;
+	}
+      else
+	{
+	  idx = exp_get_abs (_("Conditional operator must have absolute operands.\n"), idx, in, &valb);
+	  switch (cond)
+	    {
+	    default:
+	      res = 42;
+	      break;
+	    case EQ:
+	      res = vala == valb;
+	      break;
+	    case NE:
+	      res = vala != valb;
+	      break;
+	    case LT:
+	      res = vala < valb;
+	      break;
+	    case LE:
+	      res = vala <= valb;
+	      break;
+	    case GT:
+	      res = vala > valb;
+	      break;
+	    case GE:
+	      res = vala >= valb;
+	      break;
+	    case NEVER:
+	      res = 0;
+	      break;
+	    }
+	}
+    }
+
+  sb_kill (&acc_a);
+  sb_kill (&cond);
+  sb_kill (&acc_b);
+  return res;
+}
+
+/* .AIF  */
+
+static void
+do_aif (idx, in)
+     int idx;
+     sb *in;
+{
+  if (ifi >= IFNESTING)
+    {
+      FATAL ((stderr, _("AIF nesting unreasonable.\n")));
+    }
+  ifi++;
+  ifstack[ifi].on = ifstack[ifi - 1].on ? istrue (idx, in) : 0;
+  ifstack[ifi].hadelse = 0;
+}
+
+/* .AELSE  */
+
+static void
+do_aelse ()
+{
+  ifstack[ifi].on = ifstack[ifi - 1].on ? !ifstack[ifi].on : 0;
+  if (ifstack[ifi].hadelse)
+    {
+      ERROR ((stderr, _("Multiple AELSEs in AIF.\n")));
+    }
+  ifstack[ifi].hadelse = 1;
+}
+
+/* .AENDI  */
+
+static void
+do_aendi ()
+{
+  if (ifi != 0)
+    {
+      ifi--;
+    }
+  else
+    {
+      ERROR ((stderr, _("AENDI without AIF.\n")));
+    }
+}
+
+static int
+condass_on ()
+{
+  return ifstack[ifi].on;
+}
+
+/* MRI IFEQ, IFNE, IFLT, IFLE, IFGE, IFGT.  */
+
+static void
+do_if (idx, in, cond)
+     int idx;
+     sb *in;
+     int cond;
+{
+  int val;
+  int res;
+
+  if (ifi >= IFNESTING)
+    {
+      FATAL ((stderr, _("IF nesting unreasonable.\n")));
+    }
+
+  idx = exp_get_abs (_("Conditional operator must have absolute operands.\n"),
+		     idx, in, &val);
+  switch (cond)
+    {
+    default:
+    case EQ: res = val == 0; break;
+    case NE: res = val != 0; break;
+    case LT: res = val <  0; break;
+    case LE: res = val <= 0; break;
+    case GE: res = val >= 0; break;
+    case GT: res = val >  0; break;
+    }
+
+  ifi++;
+  ifstack[ifi].on = ifstack[ifi - 1].on ? res : 0;
+  ifstack[ifi].hadelse = 0;
+}
+
+/* Get a string for the MRI IFC or IFNC pseudo-ops.  */
+
+static int
+get_mri_string (idx, in, val, terminator)
+     int idx;
+     sb *in;
+     sb *val;
+     int terminator;
+{
+  idx = sb_skip_white (idx, in);
+
+  if (idx < in->len
+      && in->ptr[idx] == '\'')
+    {
+      sb_add_char (val, '\'');
+      for (++idx; idx < in->len; ++idx)
+	{
+	  sb_add_char (val, in->ptr[idx]);
+	  if (in->ptr[idx] == '\'')
+	    {
+	      ++idx;
+	      if (idx >= in->len
+		  || in->ptr[idx] != '\'')
+		break;
+	    }
+	}
+      idx = sb_skip_white (idx, in);
+    }
+  else
+    {
+      int i;
+
+      while (idx < in->len
+	     && in->ptr[idx] != terminator)
+	{
+	  sb_add_char (val, in->ptr[idx]);
+	  ++idx;
+	}
+      i = val->len - 1;
+      while (i >= 0 && ISWHITE (val->ptr[i]))
+	--i;
+      val->len = i + 1;
+    }
+
+  return idx;
+}
+
+/* MRI IFC, IFNC  */
+
+static void
+do_ifc (idx, in, ifnc)
+     int idx;
+     sb *in;
+     int ifnc;
+{
+  sb first;
+  sb second;
+  int res;
+
+  if (ifi >= IFNESTING)
+    {
+      FATAL ((stderr, _("IF nesting unreasonable.\n")));
+    }
+
+  sb_new (&first);
+  sb_new (&second);
+
+  idx = get_mri_string (idx, in, &first, ',');
+
+  if (idx >= in->len || in->ptr[idx] != ',')
+    {
+      ERROR ((stderr, _("Bad format for IF or IFNC.\n")));
+      return;
+    }
+
+  idx = get_mri_string (idx + 1, in, &second, ';');
+
+  res = (first.len == second.len
+	 && strncmp (first.ptr, second.ptr, first.len) == 0);
+  res ^= ifnc;
+
+  ifi++;
+  ifstack[ifi].on = ifstack[ifi - 1].on ? res : 0;
+  ifstack[ifi].hadelse = 0;
+}
+
+/* .ENDR  */
+
+static void
+do_aendr ()
+{
+  if (!mri)
+    ERROR ((stderr, _("AENDR without a AREPEAT.\n")));
+  else
+    ERROR ((stderr, _("ENDR without a REPT.\n")));
+}
+
+/* .AWHILE  */
+
+static void
+do_awhile (idx, in)
+     int idx;
+     sb *in;
+{
+  int line = linecount ();
+  sb exp;
+  sb sub;
+  int doit;
+
+  sb_new (&sub);
+  sb_new (&exp);
+
+  process_assigns (idx, in, &exp);
+  doit = istrue (0, &exp);
+
+  if (! buffer_and_nest ("AWHILE", "AENDW", &sub, get_line))
+    FATAL ((stderr, _("AWHILE without a AENDW at %d.\n"), line - 1));
+
+  /* Turn
+     	.AWHILE exp
+	     foo
+	.AENDW
+     into
+        foo
+	.AWHILE exp
+	foo
+	.ENDW
+  */
+
+  if (doit)
+    {
+      int index = include_next_index ();
+
+      sb copy;
+      sb_new (&copy);
+      sb_add_sb (&copy, &sub);
+      sb_add_sb (&copy, in);
+      sb_add_string (&copy, "\n");
+      sb_add_sb (&copy, &sub);
+      sb_add_string (&copy, "\t.AENDW\n");
+      /* Push another WHILE.  */
+      include_buf (&exp, &copy, include_while, index);
+      sb_kill (&copy);
+    }
+  sb_kill (&exp);
+  sb_kill (&sub);
+}
+
+/* .AENDW  */
+
+static void
+do_aendw ()
+{
+  ERROR ((stderr, _("AENDW without a AENDW.\n")));
+}
+
+/* .EXITM
+
+   Pop things off the include stack until the type and index changes.  */
+
+static void
+do_exitm ()
+{
+  include_type type = sp->type;
+  if (type == include_repeat
+      || type == include_while
+      || type == include_macro)
+    {
+      int index = sp->index;
+      include_pop ();
+      while (sp->index == index
+	     && sp->type == type)
+	{
+	  include_pop ();
+	}
+    }
+}
+
+/* .AREPEAT  */
+
+static void
+do_arepeat (idx, in)
+     int idx;
+     sb *in;
+{
+  int line = linecount ();
+  sb exp;			/* Buffer with expression in it.  */
+  sb copy;			/* Expanded repeat block.  */
+  sb sub;			/* Contents of AREPEAT.  */
+  int rc;
+  int ret;
+  char buffer[30];
+
+  sb_new (&exp);
+  sb_new (&copy);
+  sb_new (&sub);
+  process_assigns (idx, in, &exp);
+  idx = exp_get_abs (_("AREPEAT must have absolute operand.\n"), 0, &exp, &rc);
+  if (!mri)
+    ret = buffer_and_nest ("AREPEAT", "AENDR", &sub, get_line);
+  else
+    ret = buffer_and_nest ("REPT", "ENDR", &sub, get_line);
+  if (! ret)
+    FATAL ((stderr, _("AREPEAT without a AENDR at %d.\n"), line - 1));
+  if (rc > 0)
+    {
+      /* Push back the text following the repeat, and another repeat block
+	 so
+	 .AREPEAT 20
+	 foo
+	 .AENDR
+	 gets turned into
+	 foo
+	 .AREPEAT 19
+	 foo
+	 .AENDR
+      */
+      int index = include_next_index ();
+      sb_add_sb (&copy, &sub);
+      if (rc > 1)
+	{
+	  if (!mri)
+	    sprintf (buffer, "\t.AREPEAT	%d\n", rc - 1);
+	  else
+	    sprintf (buffer, "\tREPT	%d\n", rc - 1);
+	  sb_add_string (&copy, buffer);
+	  sb_add_sb (&copy, &sub);
+	  if (!mri)
+	    sb_add_string (&copy, "	.AENDR\n");
+	  else
+	    sb_add_string (&copy, "	ENDR\n");
+	}
+
+      include_buf (&exp, &copy, include_repeat, index);
+    }
+  sb_kill (&exp);
+  sb_kill (&sub);
+  sb_kill (&copy);
+}
+
+/* .ENDM  */
+
+static void
+do_endm ()
+{
+  ERROR ((stderr, _(".ENDM without a matching .MACRO.\n")));
+}
+
+/* MRI IRP pseudo-op.  */
+
+static void
+do_irp (idx, in, irpc)
+     int idx;
+     sb *in;
+     int irpc;
+{
+  const char *err;
+  sb out;
+
+  sb_new (&out);
+
+  err = expand_irp (irpc, idx, in, &out, get_line, comment_char);
+  if (err != NULL)
+    ERROR ((stderr, "%s\n", err));
+
+  fprintf (outfile, "%s", sb_terminate (&out));
+
+  sb_kill (&out);
+}
+
+/* Macro processing.  */
+
+/* Parse off LOCAL n1, n2,... Invent a label name for it.  */
+
+static void
+do_local (idx, line)
+     int idx ATTRIBUTE_UNUSED;
+     sb *line ATTRIBUTE_UNUSED;
+{
+  ERROR ((stderr, _("LOCAL outside of MACRO")));
+}
+
+static void
+do_macro (idx, in)
+     int idx;
+     sb *in;
+{
+  const char *err;
+  int line = linecount ();
+
+  err = define_macro (idx, in, &label, get_line, (const char **) NULL);
+  if (err != NULL)
+    ERROR ((stderr, _("macro at line %d: %s\n"), line - 1, err));
+}
+
+static int
+macro_op (idx, in)
+     int idx;
+     sb *in;
+{
+  const char *err;
+  sb out;
+  sb name;
+
+  if (! macro_defined)
+    return 0;
+
+  sb_terminate (in);
+  if (! check_macro (in->ptr + idx, &out, comment_char, &err, NULL))
+    return 0;
+
+  if (err != NULL)
+    ERROR ((stderr, "%s\n", err));
+
+  sb_new (&name);
+  sb_add_string (&name, _("macro expansion"));
+
+  include_buf (&name, &out, include_macro, include_next_index ());
+
+  sb_kill (&name);
+  sb_kill (&out);
+
+  return 1;
+}
+
+/* String handling.  */
+
+static int
+getstring (idx, in, acc)
+     int idx;
+     sb *in;
+     sb *acc;
+{
+  idx = sb_skip_white (idx, in);
+
+  while (idx < in->len
+	 && (in->ptr[idx] == '"'
+	     || in->ptr[idx] == '<'
+	     || (in->ptr[idx] == '\'' && alternate)))
+    {
+      if (in->ptr[idx] == '<')
+	{
+	  if (alternate || mri)
+	    {
+	      int nest = 0;
+	      idx++;
+	      while ((in->ptr[idx] != '>' || nest)
+		     && idx < in->len)
+		{
+		  if (in->ptr[idx] == '!')
+		    {
+		      idx++;
+		      sb_add_char (acc, in->ptr[idx++]);
+		    }
+		  else
+		    {
+		      if (in->ptr[idx] == '>')
+			nest--;
+		      if (in->ptr[idx] == '<')
+			nest++;
+		      sb_add_char (acc, in->ptr[idx++]);
+		    }
+		}
+	      idx++;
+	    }
+	  else
+	    {
+	      int code;
+	      idx++;
+	      idx = exp_get_abs (_("Character code in string must be absolute expression.\n"),
+				 idx, in, &code);
+	      sb_add_char (acc, code);
+
+	      if (in->ptr[idx] != '>')
+		ERROR ((stderr, _("Missing > for character code.\n")));
+	      idx++;
+	    }
+	}
+      else if (in->ptr[idx] == '"' || in->ptr[idx] == '\'')
+	{
+	  char tchar = in->ptr[idx];
+	  idx++;
+	  while (idx < in->len)
+	    {
+	      if (alternate && in->ptr[idx] == '!')
+		{
+		  idx++;
+		  sb_add_char (acc, in->ptr[idx++]);
+		}
+	      else
+		{
+		  if (in->ptr[idx] == tchar)
+		    {
+		      idx++;
+		      if (idx >= in->len || in->ptr[idx] != tchar)
+			break;
+		    }
+		  sb_add_char (acc, in->ptr[idx]);
+		  idx++;
+		}
+	    }
+	}
+    }
+
+  return idx;
+}
+
+/* .SDATA[C|Z] <string>  */
+
+static void
+do_sdata (idx, in, type)
+     int idx;
+     sb *in;
+     int type;
+{
+  int nc = 0;
+  int pidx = -1;
+  sb acc;
+  sb_new (&acc);
+  fprintf (outfile, ".byte\t");
+
+  while (!eol (idx, in))
+    {
+      int i;
+      sb_reset (&acc);
+      idx = sb_skip_white (idx, in);
+      while (!eol (idx, in))
+	{
+	  pidx = idx = get_any_string (idx, in, &acc, 0, 1);
+	  if (type == 'c')
+	    {
+	      if (acc.len > 255)
+		{
+		  ERROR ((stderr, _("string for SDATAC longer than 255 characters (%d).\n"), acc.len));
+		}
+	      fprintf (outfile, "%d", acc.len);
+	      nc = 1;
+	    }
+
+	  for (i = 0; i < acc.len; i++)
+	    {
+	      if (nc)
+		{
+		  fprintf (outfile, ",");
+		}
+	      fprintf (outfile, "%d", acc.ptr[i]);
+	      nc = 1;
+	    }
+
+	  if (type == 'z')
+	    {
+	      if (nc)
+		fprintf (outfile, ",");
+	      fprintf (outfile, "0");
+	    }
+	  idx = sb_skip_comma (idx, in);
+	  if (idx == pidx)
+	    break;
+	}
+      if (!alternate && in->ptr[idx] != ',' && idx != in->len)
+	{
+	  fprintf (outfile, "\n");
+	  ERROR ((stderr, _("illegal character in SDATA line (0x%x).\n"),
+		  in->ptr[idx]));
+	  break;
+	}
+      idx++;
+    }
+  sb_kill (&acc);
+  fprintf (outfile, "\n");
+}
+
+/* .SDATAB <count> <string>  */
+
+static void
+do_sdatab (idx, in)
+     int idx;
+     sb *in;
+{
+  int repeat;
+  int i;
+  sb acc;
+  sb_new (&acc);
+
+  idx = exp_get_abs (_("Must have absolute SDATAB repeat count.\n"), idx, in, &repeat);
+  if (repeat <= 0)
+    {
+      ERROR ((stderr, _("Must have positive SDATAB repeat count (%d).\n"), repeat));
+      repeat = 1;
+    }
+
+  idx = sb_skip_comma (idx, in);
+  idx = getstring (idx, in, &acc);
+
+  for (i = 0; i < repeat; i++)
+    {
+      if (i)
+	fprintf (outfile, "\t");
+      fprintf (outfile, ".byte\t");
+      sb_print (outfile, &acc);
+      fprintf (outfile, "\n");
+    }
+  sb_kill (&acc);
+
+}
+
+static int
+new_file (name)
+     const char *name;
+{
+  FILE *newone = fopen (name, "r");
+  if (!newone)
+    return 0;
+
+  if (isp == MAX_INCLUDES)
+    FATAL ((stderr, _("Unreasonable include depth (%ld).\n"), (long) isp));
+
+  sp++;
+  sp->handle = newone;
+
+  sb_new (&sp->name);
+  sb_add_string (&sp->name, name);
+
+  sp->linecount = 1;
+  sp->pushback_index = 0;
+  sp->type = include_file;
+  sp->index = 0;
+  sb_new (&sp->pushback);
+  return 1;
+}
+
+static void
+do_include (idx, in)
+     int idx;
+     sb *in;
+{
+  sb t;
+  sb cat;
+  include_path *includes;
+
+  sb_new (&t);
+  sb_new (&cat);
+
+  if (! mri)
+    idx = getstring (idx, in, &t);
+  else
+    {
+      idx = sb_skip_white (idx, in);
+      while (idx < in->len && ! ISWHITE (in->ptr[idx]))
+	{
+	  sb_add_char (&t, in->ptr[idx]);
+	  ++idx;
+	}
+    }
+
+  for (includes = paths_head; includes; includes = includes->next)
+    {
+      sb_reset (&cat);
+      sb_add_sb (&cat, &includes->path);
+      sb_add_char (&cat, '/');
+      sb_add_sb (&cat, &t);
+      if (new_file (sb_name (&cat)))
+	{
+	  break;
+	}
+    }
+  if (!includes)
+    {
+      if (! new_file (sb_name (&t)))
+	FATAL ((stderr, _("Can't open include file `%s'.\n"), sb_name (&t)));
+    }
+  sb_kill (&cat);
+  sb_kill (&t);
+}
+
+static void
+include_pop ()
+{
+  if (sp != include_stack)
+    {
+      if (sp->handle)
+	fclose (sp->handle);
+      sp--;
+    }
+}
+
+/* Get the next character from the include stack.  If there's anything
+   in the pushback buffer, take that first.  If we're at eof, pop from
+   the stack and try again.  Keep the linecount up to date.  */
+
+static int
+get ()
+{
+  int r;
+
+  if (sp->pushback.len != sp->pushback_index)
+    {
+      r = (char) (sp->pushback.ptr[sp->pushback_index++]);
+      /* When they've all gone, reset the pointer.  */
+      if (sp->pushback_index == sp->pushback.len)
+	{
+	  sp->pushback.len = 0;
+	  sp->pushback_index = 0;
+	}
+    }
+  else if (sp->handle)
+    {
+      r = getc (sp->handle);
+    }
+  else
+    r = EOF;
+
+  if (r == EOF && isp)
+    {
+      include_pop ();
+      r = get ();
+      while (r == EOF && isp)
+	{
+	  include_pop ();
+	  r = get ();
+	}
+      return r;
+    }
+  if (r == '\n')
+    {
+      sp->linecount++;
+    }
+
+  return r;
+}
+
+static int
+linecount ()
+{
+  return sp->linecount;
+}
+
+static int
+include_next_index ()
+{
+  static int index;
+  if (!unreasonable
+      && index > MAX_REASONABLE)
+    FATAL ((stderr, _("Unreasonable expansion (-u turns off check).\n")));
+  return ++index;
+}
+
+/* Initialize the chartype vector.  */
+
+static void
+chartype_init ()
+{
+  int x;
+  for (x = 0; x < 256; x++)
+    {
+      if (ISALPHA (x) || x == '_' || x == '$')
+	chartype[x] |= FIRSTBIT;
+
+      if (mri && x == '.')
+	chartype[x] |= FIRSTBIT;
+
+      if (ISDIGIT (x) || ISALPHA (x) || x == '_' || x == '$')
+	chartype[x] |= NEXTBIT;
+
+      if (x == ' ' || x == '\t' || x == ',' || x == '"' || x == ';'
+	  || x == '"' || x == '<' || x == '>' || x == ')' || x == '(')
+	chartype[x] |= SEPBIT;
+
+      if (x == 'b' || x == 'B'
+	  || x == 'q' || x == 'Q'
+	  || x == 'h' || x == 'H'
+	  || x == 'd' || x == 'D')
+	chartype [x] |= BASEBIT;
+
+      if (x == ' ' || x == '\t')
+	chartype[x] |= WHITEBIT;
+
+      if (x == comment_char)
+	chartype[x] |= COMMENTBIT;
+    }
+}
+
+/* What to do with all the keywords.  */
+#define PROCESS 	0x1000  /* Run substitution over the line.  */
+#define LAB		0x2000  /* Spit out the label.  */
+
+#define K_EQU 		(PROCESS|1)
+#define K_ASSIGN 	(PROCESS|2)
+#define K_REG 		(PROCESS|3)
+#define K_ORG 		(PROCESS|4)
+#define K_RADIX 	(PROCESS|5)
+#define K_DATA 		(LAB|PROCESS|6)
+#define K_DATAB 	(LAB|PROCESS|7)
+#define K_SDATA 	(LAB|PROCESS|8)
+#define K_SDATAB 	(LAB|PROCESS|9)
+#define K_SDATAC 	(LAB|PROCESS|10)
+#define K_SDATAZ	(LAB|PROCESS|11)
+#define K_RES 		(LAB|PROCESS|12)
+#define K_SRES 		(LAB|PROCESS|13)
+#define K_SRESC 	(LAB|PROCESS|14)
+#define K_SRESZ 	(LAB|PROCESS|15)
+#define K_EXPORT 	(LAB|PROCESS|16)
+#define K_GLOBAL 	(LAB|PROCESS|17)
+#define K_PRINT 	(LAB|PROCESS|19)
+#define K_FORM 		(LAB|PROCESS|20)
+#define K_HEADING	(LAB|PROCESS|21)
+#define K_PAGE		(LAB|PROCESS|22)
+#define K_IMPORT	(LAB|PROCESS|23)
+#define K_PROGRAM	(LAB|PROCESS|24)
+#define K_END		(PROCESS|25)
+#define K_INCLUDE	(PROCESS|26)
+#define K_IGNORED	(PROCESS|27)
+#define K_ASSIGNA	(PROCESS|28)
+#define K_ASSIGNC	(29)
+#define K_AIF		(PROCESS|30)
+#define K_AELSE		(PROCESS|31)
+#define K_AENDI		(PROCESS|32)
+#define K_AREPEAT	(PROCESS|33)
+#define K_AENDR		(PROCESS|34)
+#define K_AWHILE	(35)
+#define K_AENDW		(PROCESS|36)
+#define K_EXITM		(37)
+#define K_MACRO		(PROCESS|38)
+#define K_ENDM		(39)
+#define K_ALIGN		(PROCESS|LAB|40)
+#define K_ALTERNATE     (41)
+#define K_DB		(LAB|PROCESS|42)
+#define K_DW		(LAB|PROCESS|43)
+#define K_DL		(LAB|PROCESS|44)
+#define K_LOCAL		(45)
+#define K_IFEQ		(PROCESS|46)
+#define K_IFNE		(PROCESS|47)
+#define K_IFLT		(PROCESS|48)
+#define K_IFLE		(PROCESS|49)
+#define K_IFGE		(PROCESS|50)
+#define K_IFGT		(PROCESS|51)
+#define K_IFC		(PROCESS|52)
+#define K_IFNC		(PROCESS|53)
+#define K_IRP		(PROCESS|54)
+#define K_IRPC		(PROCESS|55)
+
+struct keyword {
+  char *name;
+  int code;
+  int extra;
+};
+
+static struct keyword kinfo[] = {
+  { "EQU", K_EQU, 0 },
+  { "ALTERNATE", K_ALTERNATE, 0 },
+  { "ASSIGN", K_ASSIGN, 0 },
+  { "REG", K_REG, 0 },
+  { "ORG", K_ORG, 0 },
+  { "RADIX", K_RADIX, 0 },
+  { "DATA", K_DATA, 0 },
+  { "DB", K_DB, 0 },
+  { "DW", K_DW, 0 },
+  { "DL", K_DL, 0 },
+  { "DATAB", K_DATAB, 0 },
+  { "SDATA", K_SDATA, 0 },
+  { "SDATAB", K_SDATAB, 0 },
+  { "SDATAZ", K_SDATAZ, 0 },
+  { "SDATAC", K_SDATAC, 0 },
+  { "RES", K_RES, 0 },
+  { "SRES", K_SRES, 0 },
+  { "SRESC", K_SRESC, 0 },
+  { "SRESZ", K_SRESZ, 0 },
+  { "EXPORT", K_EXPORT, 0 },
+  { "GLOBAL", K_GLOBAL, 0 },
+  { "PRINT", K_PRINT, 0 },
+  { "FORM", K_FORM, 0 },
+  { "HEADING", K_HEADING, 0 },
+  { "PAGE", K_PAGE, 0 },
+  { "PROGRAM", K_IGNORED, 0 },
+  { "END", K_END, 0 },
+  { "INCLUDE", K_INCLUDE, 0 },
+  { "ASSIGNA", K_ASSIGNA, 0 },
+  { "ASSIGNC", K_ASSIGNC, 0 },
+  { "AIF", K_AIF, 0 },
+  { "AELSE", K_AELSE, 0 },
+  { "AENDI", K_AENDI, 0 },
+  { "AREPEAT", K_AREPEAT, 0 },
+  { "AENDR", K_AENDR, 0 },
+  { "EXITM", K_EXITM, 0 },
+  { "MACRO", K_MACRO, 0 },
+  { "ENDM", K_ENDM, 0 },
+  { "AWHILE", K_AWHILE, 0 },
+  { "ALIGN", K_ALIGN, 0 },
+  { "AENDW", K_AENDW, 0 },
+  { "ALTERNATE", K_ALTERNATE, 0 },
+  { "LOCAL", K_LOCAL, 0 },
+  { NULL, 0, 0 }
+};
+
+/* Although the conditional operators are handled by gas, we need to
+   handle them here as well, in case they are used in a recursive
+   macro to end the recursion.  */
+
+static struct keyword mrikinfo[] = {
+  { "IFEQ", K_IFEQ, 0 },
+  { "IFNE", K_IFNE, 0 },
+  { "IFLT", K_IFLT, 0 },
+  { "IFLE", K_IFLE, 0 },
+  { "IFGE", K_IFGE, 0 },
+  { "IFGT", K_IFGT, 0 },
+  { "IFC", K_IFC, 0 },
+  { "IFNC", K_IFNC, 0 },
+  { "ELSEC", K_AELSE, 0 },
+  { "ENDC", K_AENDI, 0 },
+  { "MEXIT", K_EXITM, 0 },
+  { "REPT", K_AREPEAT, 0 },
+  { "IRP", K_IRP, 0 },
+  { "IRPC", K_IRPC, 0 },
+  { "ENDR", K_AENDR, 0 },
+  { NULL, 0, 0 }
+};
+
+/* Look for a pseudo op on the line. If one's there then call
+   its handler.  */
+
+static int
+process_pseudo_op (idx, line, acc)
+     int idx;
+     sb *line;
+     sb *acc;
+{
+  int oidx = idx;
+
+  if (line->ptr[idx] == '.' || alternate || mri)
+    {
+      /* Scan forward and find pseudo name.  */
+      char *in;
+      hash_entry *ptr;
+
+      char *s;
+      char *e;
+      if (line->ptr[idx] == '.')
+	idx++;
+      in = line->ptr + idx;
+      s = in;
+      e = s;
+      sb_reset (acc);
+
+      while (idx < line->len && *e && ISFIRSTCHAR (*e))
+	{
+	  sb_add_char (acc, *e);
+	  e++;
+	  idx++;
+	}
+
+      ptr = hash_lookup (&keyword_hash_table, acc);
+
+      if (!ptr)
+	{
+#if 0
+	  /* This one causes lots of pain when trying to preprocess
+	     ordinary code.  */
+	  WARNING ((stderr, _("Unrecognised pseudo op `%s'.\n"),
+		    sb_name (acc)));
+#endif
+	  return 0;
+	}
+      if (ptr->value.i & LAB)
+	{
+	  /* Output the label.  */
+	  if (label.len)
+	    {
+	      fprintf (outfile, "%s:\t", sb_name (&label));
+	    }
+	  else
+	    fprintf (outfile, "\t");
+	}
+
+      if (mri && ptr->value.i == K_END)
+	{
+	  sb t;
+
+	  sb_new (&t);
+	  sb_add_buffer (&t, line->ptr + oidx, idx - oidx);
+	  fprintf (outfile, "\t%s", sb_name (&t));
+	  sb_kill (&t);
+	}
+
+      if (ptr->value.i & PROCESS)
+	{
+	  /* Polish the rest of the line before handling the pseudo op.  */
+#if 0
+	  strip_comments (line);
+#endif
+	  sb_reset (acc);
+	  process_assigns (idx, line, acc);
+	  sb_reset (line);
+	  change_base (0, acc, line);
+	  idx = 0;
+	}
+      if (!condass_on ())
+	{
+	  switch (ptr->value.i)
+	    {
+	    case K_AIF:
+	      do_aif (idx, line);
+	      break;
+	    case K_AELSE:
+	      do_aelse ();
+	      break;
+	    case K_AENDI:
+	      do_aendi ();
+	      break;
+	    }
+	  return 1;
+	}
+      else
+	{
+	  switch (ptr->value.i)
+	    {
+	    case K_ALTERNATE:
+	      alternate = 1;
+	      macro_init (1, mri, 0, exp_get_abs);
+	      return 1;
+	    case K_AELSE:
+	      do_aelse ();
+	      return 1;
+	    case K_AENDI:
+	      do_aendi ();
+	      return 1;
+	    case K_ORG:
+	      ERROR ((stderr, _("ORG command not allowed.\n")));
+	      break;
+	    case K_RADIX:
+	      do_radix (line);
+	      return 1;
+	    case K_DB:
+	      do_data (idx, line, 1);
+	      return 1;
+	    case K_DW:
+	      do_data (idx, line, 2);
+	      return 1;
+	    case K_DL:
+	      do_data (idx, line, 4);
+	      return 1;
+	    case K_DATA:
+	      do_data (idx, line, 0);
+	      return 1;
+	    case K_DATAB:
+	      do_datab (idx, line);
+	      return 1;
+	    case K_SDATA:
+	      do_sdata (idx, line, 0);
+	      return 1;
+	    case K_SDATAB:
+	      do_sdatab (idx, line);
+	      return 1;
+	    case K_SDATAC:
+	      do_sdata (idx, line, 'c');
+	      return 1;
+	    case K_SDATAZ:
+	      do_sdata (idx, line, 'z');
+	      return 1;
+	    case K_ASSIGN:
+	      do_assign (0, 0, line);
+	      return 1;
+	    case K_AIF:
+	      do_aif (idx, line);
+	      return 1;
+	    case K_AREPEAT:
+	      do_arepeat (idx, line);
+	      return 1;
+	    case K_AENDW:
+	      do_aendw ();
+	      return 1;
+	    case K_AWHILE:
+	      do_awhile (idx, line);
+	      return 1;
+	    case K_AENDR:
+	      do_aendr ();
+	      return 1;
+	    case K_EQU:
+	      do_assign (1, idx, line);
+	      return 1;
+	    case K_ALIGN:
+	      do_align (idx, line);
+	      return 1;
+	    case K_RES:
+	      do_res (idx, line, 0);
+	      return 1;
+	    case K_SRES:
+	      do_res (idx, line, 's');
+	      return 1;
+	    case K_INCLUDE:
+	      do_include (idx, line);
+	      return 1;
+	    case K_LOCAL:
+	      do_local (idx, line);
+	      return 1;
+	    case K_MACRO:
+	      do_macro (idx, line);
+	      return 1;
+	    case K_ENDM:
+	      do_endm ();
+	      return 1;
+	    case K_SRESC:
+	      do_res (idx, line, 'c');
+	      return 1;
+	    case K_PRINT:
+	      do_print (idx, line);
+	      return 1;
+	    case K_FORM:
+	      do_form (idx, line);
+	      return 1;
+	    case K_HEADING:
+	      do_heading (idx, line);
+	      return 1;
+	    case K_PAGE:
+	      do_page ();
+	      return 1;
+	    case K_GLOBAL:
+	    case K_EXPORT:
+	      do_export (line);
+	      return 1;
+	    case K_IMPORT:
+	      return 1;
+	    case K_SRESZ:
+	      do_res (idx, line, 'z');
+	      return 1;
+	    case K_IGNORED:
+	      return 1;
+	    case K_END:
+	      do_end (line);
+	      return 1;
+	    case K_ASSIGNA:
+	      do_assigna (idx, line);
+	      return 1;
+	    case K_ASSIGNC:
+	      do_assignc (idx, line);
+	      return 1;
+	    case K_EXITM:
+	      do_exitm ();
+	      return 1;
+	    case K_REG:
+	      do_reg (idx, line);
+	      return 1;
+	    case K_IFEQ:
+	      do_if (idx, line, EQ);
+	      return 1;
+	    case K_IFNE:
+	      do_if (idx, line, NE);
+	      return 1;
+	    case K_IFLT:
+	      do_if (idx, line, LT);
+	      return 1;
+	    case K_IFLE:
+	      do_if (idx, line, LE);
+	      return 1;
+	    case K_IFGE:
+	      do_if (idx, line, GE);
+	      return 1;
+	    case K_IFGT:
+	      do_if (idx, line, GT);
+	      return 1;
+	    case K_IFC:
+	      do_ifc (idx, line, 0);
+	      return 1;
+	    case K_IFNC:
+	      do_ifc (idx, line, 1);
+	      return 1;
+	    case K_IRP:
+	      do_irp (idx, line, 0);
+	      return 1;
+	    case K_IRPC:
+	      do_irp (idx, line, 1);
+	      return 1;
+	    }
+	}
+    }
+  return 0;
+}
+
+/* Add a keyword to the hash table.  */
+
+static void
+add_keyword (name, code)
+     const char *name;
+     int code;
+{
+  sb label;
+  int j;
+
+  sb_new (&label);
+  sb_add_string (&label, name);
+
+  hash_add_to_int_table (&keyword_hash_table, &label, code);
+
+  sb_reset (&label);
+  for (j = 0; name[j]; j++)
+    sb_add_char (&label, name[j] - 'A' + 'a');
+  hash_add_to_int_table (&keyword_hash_table, &label, code);
+
+  sb_kill (&label);
+}
+
+/* Build the keyword hash table - put each keyword in the table twice,
+   once upper and once lower case.  */
+
+static void
+process_init ()
+{
+  int i;
+
+  for (i = 0; kinfo[i].name; i++)
+    add_keyword (kinfo[i].name, kinfo[i].code);
+
+  if (mri)
+    {
+      for (i = 0; mrikinfo[i].name; i++)
+	add_keyword (mrikinfo[i].name, mrikinfo[i].code);
+    }
+}
+
+static void
+do_define (string)
+     const char *string;
+{
+  sb label;
+  int res = 1;
+  hash_entry *ptr;
+  sb_new (&label);
+
+  while (*string)
+    {
+      if (*string == '=')
+	{
+	  sb value;
+	  sb_new (&value);
+	  string++;
+	  while (*string)
+	    {
+	      sb_add_char (&value, *string);
+	      string++;
+	    }
+	  exp_get_abs (_("Invalid expression on command line.\n"),
+		       0, &value, &res);
+	  sb_kill (&value);
+	  break;
+	}
+      sb_add_char (&label, *string);
+
+      string++;
+    }
+
+  ptr = hash_create (&vars, &label);
+  free_old_entry (ptr);
+  ptr->type = hash_integer;
+  ptr->value.i = res;
+  sb_kill (&label);
+}
+
+char *program_name;
+
+/* The list of long options.  */
+static struct option long_options[] =
+{
+  { "alternate", no_argument, 0, 'a' },
+  { "include", required_argument, 0, 'I' },
+  { "commentchar", required_argument, 0, 'c' },
+  { "copysource", no_argument, 0, 's' },
+  { "debug", no_argument, 0, 'd' },
+  { "help", no_argument, 0, 'h' },
+  { "mri", no_argument, 0, 'M' },
+  { "output", required_argument, 0, 'o' },
+  { "print", no_argument, 0, 'p' },
+  { "unreasonable", no_argument, 0, 'u' },
+  { "version", no_argument, 0, 'v' },
+  { "define", required_argument, 0, 'd' },
+  { NULL, no_argument, 0, 0 }
+};
+
+/* Show a usage message and exit.  */
+static void
+show_usage (file, status)
+     FILE *file;
+     int status;
+{
+  fprintf (file, _("\
+Usage: %s \n\
+  [-a]      [--alternate]         enter alternate macro mode\n\
+  [-c char] [--commentchar char]  change the comment character from !\n\
+  [-d]      [--debug]             print some debugging info\n\
+  [-h]      [--help]              print this message\n\
+  [-M]      [--mri]               enter MRI compatibility mode\n\
+  [-o out]  [--output out]        set the output file\n\
+  [-p]      [--print]             print line numbers\n"), program_name);
+  fprintf (file, _("\
+  [-s]      [--copysource]        copy source through as comments \n\
+  [-u]      [--unreasonable]      allow unreasonable nesting\n\
+  [-v]      [--version]           print the program version\n\
+  [-Dname=value]                  create preprocessor variable called name, with value\n\
+  [-Ipath]                        add to include path list\n\
+  [in-file]\n"));
+  if (status == 0)
+    printf (_("Report bugs to %s\n"), REPORT_BUGS_TO);
+  exit (status);
+}
+
+/* Display a help message and exit.  */
+
+static void
+show_help ()
+{
+  printf (_("%s: Gnu Assembler Macro Preprocessor\n"), program_name);
+  show_usage (stdout, 0);
+}
+
+int main PARAMS ((int, char **));
+
+int
+main (argc, argv)
+     int argc;
+     char **argv;
+{
+  int opt;
+  char *out_name = 0;
+  sp = include_stack;
+
+  ifstack[0].on = 1;
+  ifi = 0;
+
+#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
+  setlocale (LC_MESSAGES, "");
+#endif
+#if defined (HAVE_SETLOCALE)
+  setlocale (LC_CTYPE, "");
+#endif
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+
+  program_name = argv[0];
+  xmalloc_set_program_name (program_name);
+
+  hash_new_table (101, &keyword_hash_table);
+  hash_new_table (101, &assign_hash_table);
+  hash_new_table (101, &vars);
+
+  sb_new (&label);
+
+  while ((opt = getopt_long (argc, argv, "I:sdhavc:upo:D:M", long_options,
+			     (int *) NULL))
+	 != EOF)
+    {
+      switch (opt)
+	{
+	case 'o':
+	  out_name = optarg;
+	  break;
+	case 'u':
+	  unreasonable = 1;
+	  break;
+	case 'I':
+	  {
+	    include_path *p = (include_path *) xmalloc (sizeof (include_path));
+	    p->next = NULL;
+	    sb_new (&p->path);
+	    sb_add_string (&p->path, optarg);
+	    if (paths_tail)
+	      paths_tail->next = p;
+	    else
+	      paths_head = p;
+	    paths_tail = p;
+	  }
+	  break;
+	case 'p':
+	  print_line_number = 1;
+	  break;
+	case 'c':
+	  comment_char = optarg[0];
+	  break;
+	case 'a':
+	  alternate = 1;
+	  break;
+	case 's':
+	  copysource = 1;
+	  break;
+	case 'd':
+	  stats = 1;
+	  break;
+	case 'D':
+	  do_define (optarg);
+	  break;
+	case 'M':
+	  mri = 1;
+	  comment_char = ';';
+	  break;
+	case 'h':
+	  show_help ();
+	  /* NOTREACHED  */
+	case 'v':
+	  /* This output is intended to follow the GNU standards document.  */
+	  printf (_("GNU assembler pre-processor %s\n"), program_version);
+	  printf (_("Copyright 1996 Free Software Foundation, Inc.\n"));
+	  printf (_("\
+This program is free software; you may redistribute it under the terms of\n\
+the GNU General Public License.  This program has absolutely no warranty.\n"));
+	  exit (0);
+	  /* NOTREACHED  */
+	case 0:
+	  break;
+	default:
+	  show_usage (stderr, 1);
+	  /* NOTREACHED  */
+	}
+    }
+
+  process_init ();
+
+  macro_init (alternate, mri, 0, exp_get_abs);
+
+  if (out_name)
+    {
+      outfile = fopen (out_name, "w");
+      if (!outfile)
+	{
+	  fprintf (stderr, _("%s: Can't open output file `%s'.\n"),
+		   program_name, out_name);
+	  exit (1);
+	}
+    }
+  else
+    {
+      outfile = stdout;
+    }
+
+  chartype_init ();
+  if (!outfile)
+    outfile = stdout;
+
+  /* Process all the input files.  */
+
+  while (optind < argc)
+    {
+      if (new_file (argv[optind]))
+	{
+	  process_file ();
+	}
+      else
+	{
+	  fprintf (stderr, _("%s: Can't open input file `%s'.\n"),
+		   program_name, argv[optind]);
+	  exit (1);
+	}
+      optind++;
+    }
+
+  quit ();
+  return 0;
+}
+
+/* This function is used because an abort in some of the other files
+   may be compiled into as_abort because they include as.h.  */
+
+void
+as_abort (file, line, fn)
+     const char *file, *fn;
+     int line;
+{
+  fprintf (stderr, _("Internal error, aborting at %s line %d"), file, line);
+  if (fn)
+    fprintf (stderr, " in %s", fn);
+  fprintf (stderr, _("\nPlease report this bug.\n"));
+  exit (1);
+}
diff -urp --unidirectional-new-file binutils-2.15/gas/itbl-parse.y binutils-freebsd/gas/itbl-parse.y
--- binutils-2.15/gas/itbl-parse.y	2003-10-27 07:45:17.000000000 -0500
+++ binutils-freebsd/gas/itbl-parse.y	2002-12-02 04:05:14.000000000 -0500
@@ -152,7 +152,7 @@ Here is the grammar for the coprocessor 
 	    char -> any printable character
 	    ltr -> ['a'..'z'|'A'..'Z'] 
 	    dec -> ['0'..'9']*	    	    	    	    	     ; value in decimal
-	    hex -> '0x'['0'..'9' | 'a'..'f' | 'A'..'F']*	; value in hexadecimal 
+	    hex -> '0x'['0'..'9' | 'a'..'f' | 'A'..'F']*	; value in hexidecimal 
 
 
 Examples
@@ -239,7 +239,7 @@ was deleted from the original format suc
 
 ----
 FIXME! should really change lexical analyzer 
-to recognize 'dreg' etc. in context sensitive way.
+to recognize 'dreg' etc. in context sensative way.
 Currently function names or mnemonics may be incorrectly parsed as keywords
 
 FIXME! hex is ambiguous with any digit
diff -urp --unidirectional-new-file binutils-2.15/gprof/po/Make-in binutils-freebsd/gprof/po/Make-in
--- binutils-2.15/gprof/po/Make-in	2003-07-19 03:31:15.000000000 -0400
+++ binutils-freebsd/gprof/po/Make-in	2002-12-02 04:05:44.000000000 -0500
@@ -72,7 +70,9 @@ INSTOBJEXT = @INSTOBJEXT@
 
 .po.gmo:
 	file=$(srcdir)/`echo $* | sed 's,.*/,,'`.gmo \
-	  && rm -f $$file && $(GMSGFMT) -o $$file $<
+	  && test -w $$file \
+	  && (rm -f $$file && $(GMSGFMT) -o $$file $< ) \
+	  || echo "$$file is not writable"
 
 .po.cat:
 	sed -f ../intl/po2msg.sed < $< > $*.msg \
diff -urp --unidirectional-new-file binutils-2.15/gprof/po/gprof.pot binutils-freebsd/gprof/po/gprof.pot
--- binutils-2.15/gprof/po/gprof.pot	2003-07-11 01:10:20.000000000 -0400
+++ binutils-freebsd/gprof/po/gprof.pot	2002-12-02 04:05:44.000000000 -0500
@@ -7,7 +7,7 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
-"POT-Creation-Date: 2003-07-11 13:58+0930\n"
+"POT-Creation-Date: 2002-10-30 10:08-0500\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -244,96 +244,97 @@ msgstr ""
 msgid "%s: file `%s' has no symbols\n"
 msgstr ""
 
-#: corefile.c:758
+#: corefile.c:748
 #, c-format
 msgid "%s: somebody miscounted: ltab.len=%d instead of %ld\n"
 msgstr ""
 
-#: gmon_io.c:82
+#: gmon_io.c:96 gmon_io.c:159 gmon_io.c:219 gmon_io.c:251 gmon_io.c:422
+#: gmon_io.c:449 gmon_io.c:646 gmon_io.c:671
 #, c-format
-msgid "%s: address size has unexpected value of %u\n"
+msgid "%s: bits per address has unexpected value of %u\n"
 msgstr ""
 
-#: gmon_io.c:345 gmon_io.c:440
+#: gmon_io.c:288 gmon_io.c:383
 #, c-format
 msgid "%s: file too short to be a gmon file\n"
 msgstr ""
 
-#: gmon_io.c:355 gmon_io.c:483
+#: gmon_io.c:298 gmon_io.c:432
 #, c-format
 msgid "%s: file `%s' has bad magic cookie\n"
 msgstr ""
 
-#: gmon_io.c:366
+#: gmon_io.c:309
 #, c-format
 msgid "%s: file `%s' has unsupported version %d\n"
 msgstr ""
 
-#: gmon_io.c:396
+#: gmon_io.c:339
 #, c-format
 msgid "%s: %s: found bad tag %d (file corrupted?)\n"
 msgstr ""
 
-#: gmon_io.c:462
+#: gmon_io.c:405
 #, c-format
 msgid "%s: profiling rate incompatible with first gmon file\n"
 msgstr ""
 
-#: gmon_io.c:510
+#: gmon_io.c:465
 #, c-format
 msgid "%s: incompatible with first gmon file\n"
 msgstr ""
 
-#: gmon_io.c:538
+#: gmon_io.c:493
 #, c-format
 msgid "%s: file '%s' does not appear to be in gmon.out format\n"
 msgstr ""
 
-#: gmon_io.c:559
+#: gmon_io.c:514
 #, c-format
 msgid "%s: unexpected EOF after reading %d/%d bins\n"
 msgstr ""
 
-#: gmon_io.c:592
+#: gmon_io.c:547
 msgid "time is in ticks, not seconds\n"
 msgstr ""
 
-#: gmon_io.c:598 gmon_io.c:775
+#: gmon_io.c:553 gmon_io.c:742
 #, c-format
 msgid "%s: don't know how to deal with file format %d\n"
 msgstr ""
 
-#: gmon_io.c:605
+#: gmon_io.c:560
 #, c-format
 msgid "File `%s' (version %d) contains:\n"
 msgstr ""
 
-#: gmon_io.c:608
+#: gmon_io.c:563
 #, c-format
 msgid "\t%d histogram record\n"
 msgstr ""
 
-#: gmon_io.c:609
+#: gmon_io.c:564
 #, c-format
 msgid "\t%d histogram records\n"
 msgstr ""
 
-#: gmon_io.c:611
+#: gmon_io.c:566
 #, c-format
 msgid "\t%d call-graph record\n"
 msgstr ""
 
-#: gmon_io.c:612
+#: gmon_io.c:567
 #, c-format
 msgid "\t%d call-graph records\n"
 msgstr ""
 
-#: gmon_io.c:614
+#: gmon_io.c:569
 #, c-format
 msgid "\t%d basic-block count record\n"
 msgstr ""
 
-#: gmon_io.c:615
+#: gmon_io.c:570
 #, c-format
 msgid "\t%d basic-block count records\n"
 msgstr ""
diff -urp --unidirectional-new-file binutils-2.15/include/callback.h binutils-freebsd/include/callback.h
--- binutils-2.15/include/callback.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/include/callback.h	1998-09-06 18:57:31.000000000 -0400
@@ -0,0 +1,270 @@
+/* Remote target system call callback support.
+   Copyright 1997 Free Software Foundation, Inc.
+   Contributed by Cygnus Solutions.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This interface isn't intended to be specific to any particular kind
+   of remote (hardware, simulator, whatever).  As such, support for it
+   (e.g. sim/common/callback.c) should *not* live in the simulator source
+   tree, nor should it live in the gdb source tree.  */
+
+/* There are various ways to handle system calls:
+
+   1) Have a simulator intercept the appropriate trap instruction and
+   directly perform the system call on behalf of the target program.
+   This is the typical way of handling system calls for embedded targets.
+   [Handling system calls for embedded targets isn't that much of an
+   oxymoron as running compiler testsuites make use of the capability.]
+
+   This method of system call handling is done when STATE_ENVIRONMENT
+   is ENVIRONMENT_USER.
+
+   2) Have a simulator emulate the hardware as much as possible.
+   If the program running on the real hardware communicates with some sort
+   of target manager, one would want to be able to run this program on the
+   simulator as well.
+
+   This method of system call handling is done when STATE_ENVIRONMENT
+   is ENVIRONMENT_OPERATING.
+*/
+
+#ifndef CALLBACK_H
+#define CALLBACK_H
+
+/* ??? The reason why we check for va_start here should be documented.  */
+
+#ifndef va_start
+#include <ansidecl.h>
+#ifdef ANSI_PROTOTYPES
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+#endif
+
+/* Mapping of host/target values.  */
+/* ??? For debugging purposes, one might want to add a string of the
+   name of the symbol.  */
+
+typedef struct {
+  int host_val;
+  int target_val;
+} CB_TARGET_DEFS_MAP;
+
+#define MAX_CALLBACK_FDS 10
+
+/* Forward decl for stat/fstat.  */
+struct stat;
+
+typedef struct host_callback_struct host_callback;
+
+struct host_callback_struct 
+{
+  int (*close) PARAMS ((host_callback *,int));
+  int (*get_errno) PARAMS ((host_callback *));
+  int (*isatty) PARAMS ((host_callback *, int));
+  int (*lseek) PARAMS ((host_callback *, int, long , int));
+  int (*open) PARAMS ((host_callback *, const char*, int mode));
+  int (*read) PARAMS ((host_callback *,int,  char *, int));
+  int (*read_stdin) PARAMS (( host_callback *, char *, int));
+  int (*rename) PARAMS ((host_callback *, const char *, const char *));
+  int (*system) PARAMS ((host_callback *, const char *));
+  long (*time) PARAMS ((host_callback *, long *));
+  int (*unlink) PARAMS ((host_callback *, const char *));
+  int (*write) PARAMS ((host_callback *,int, const char *, int));
+  int (*write_stdout) PARAMS ((host_callback *, const char *, int));
+  void (*flush_stdout) PARAMS ((host_callback *));
+  int (*write_stderr) PARAMS ((host_callback *, const char *, int));
+  void (*flush_stderr) PARAMS ((host_callback *));
+  int (*stat) PARAMS ((host_callback *, const char *, struct stat *));
+  int (*fstat) PARAMS ((host_callback *, int, struct stat *));
+
+  /* When present, call to the client to give it the oportunity to
+     poll any io devices for a request to quit (indicated by a nonzero
+     return value). */
+  int (*poll_quit) PARAMS ((host_callback *));
+
+  /* Used when the target has gone away, so we can close open
+     handles and free memory etc etc.  */
+  int (*shutdown) PARAMS ((host_callback *));
+  int (*init)     PARAMS ((host_callback *));
+
+  /* depreciated, use vprintf_filtered - Talk to the user on a console.  */
+  void (*printf_filtered) PARAMS ((host_callback *, const char *, ...));
+
+  /* Talk to the user on a console.  */
+  void (*vprintf_filtered) PARAMS ((host_callback *, const char *, va_list));
+
+  /* Same as vprintf_filtered but to stderr.  */
+  void (*evprintf_filtered) PARAMS ((host_callback *, const char *, va_list));
+
+  /* Print an error message and "exit".
+     In the case of gdb "exiting" means doing a longjmp back to the main
+     command loop.  */
+  void (*error) PARAMS ((host_callback *, const char *, ...));
+
+  int last_errno;		/* host format */
+
+  int fdmap[MAX_CALLBACK_FDS];
+  char fdopen[MAX_CALLBACK_FDS];
+  char alwaysopen[MAX_CALLBACK_FDS];
+
+  /* System call numbers.  */
+  CB_TARGET_DEFS_MAP *syscall_map;
+  /* Errno values.  */
+  CB_TARGET_DEFS_MAP *errno_map;
+  /* Flags to the open system call.  */
+  CB_TARGET_DEFS_MAP *open_map;
+  /* Signal numbers.  */
+  CB_TARGET_DEFS_MAP *signal_map;
+  /* Layout of `stat' struct.
+     The format is a series of "name,length" pairs separated by colons.
+     Empty space is indicated with a `name' of "space".
+     All padding must be explicitly mentioned.
+     Lengths are in bytes.  If this needs to be extended to bits,
+     use "name.bits".
+     Example: "st_dev,4:st_ino,4:st_mode,4:..."  */
+  const char *stat_map;
+
+  /* Marker for those wanting to do sanity checks.
+     This should remain the last member of this struct to help catch
+     miscompilation errors. */
+#define HOST_CALLBACK_MAGIC 4705 /* teds constant */
+  int magic;
+};
+
+extern host_callback default_callback;
+
+/* Canonical versions of system call numbers.
+   It's not intended to willy-nilly throw every system call ever heard
+   of in here.  Only include those that have an important use.
+   ??? One can certainly start a discussion over the ones that are currently
+   here, but that will always be true.  */
+
+/* These are used by the ANSI C support of libc.  */
+#define	CB_SYS_exit	1
+#define	CB_SYS_open	2
+#define	CB_SYS_close	3
+#define	CB_SYS_read	4
+#define	CB_SYS_write	5
+#define	CB_SYS_lseek	6
+#define	CB_SYS_unlink	7
+#define	CB_SYS_getpid	8
+#define	CB_SYS_kill	9
+#define CB_SYS_fstat    10
+/*#define CB_SYS_sbrk	11 - not currently a system call, but reserved.  */
+
+/* ARGV support.  */
+#define CB_SYS_argvlen	12
+#define CB_SYS_argv	13
+
+/* These are extras added for one reason or another.  */
+#define CB_SYS_chdir	14
+#define CB_SYS_stat	15
+#define CB_SYS_chmod 	16
+#define CB_SYS_utime 	17
+#define CB_SYS_time 	18
+
+/* Struct use to pass and return information necessary to perform a
+   system call.  */
+/* FIXME: Need to consider target word size.  */
+
+typedef struct cb_syscall {
+  /* The target's value of what system call to perform.  */
+  int func;
+  /* The arguments to the syscall.  */
+  long arg1, arg2, arg3, arg4;
+
+  /* The result.  */
+  long result;
+  /* Some system calls have two results.  */
+  long result2;
+  /* The target's errno value, or 0 if success.
+     This is converted to the target's value with host_to_target_errno.  */
+  int errcode;
+
+  /* Working space to be used by memory read/write callbacks.  */
+  PTR p1;
+  PTR p2;
+  long x1,x2;
+
+  /* Callbacks for reading/writing memory (e.g. for read/write syscalls).
+     ??? long or unsigned long might be better to use for the `count'
+     argument here.  We mimic sim_{read,write} for now.  Be careful to
+     test any changes with -Wall -Werror, mixed signed comparisons
+     will get you.  */
+  int (*read_mem) PARAMS ((host_callback * /*cb*/, struct cb_syscall * /*sc*/,
+			   unsigned long /*taddr*/, char * /*buf*/,
+			   int /*bytes*/));
+  int (*write_mem) PARAMS ((host_callback * /*cb*/, struct cb_syscall * /*sc*/,
+			    unsigned long /*taddr*/, const char * /*buf*/,
+			    int /*bytes*/));
+
+  /* For sanity checking, should be last entry.  */
+  int magic;
+} CB_SYSCALL;
+
+/* Magic number sanity checker.  */
+#define CB_SYSCALL_MAGIC 0x12344321
+
+/* Macro to initialize CB_SYSCALL.  Called first, before filling in
+   any fields.  */
+#define CB_SYSCALL_INIT(sc) \
+do { \
+  memset ((sc), 0, sizeof (*(sc))); \
+  (sc)->magic = CB_SYSCALL_MAGIC; \
+} while (0)
+
+/* Return codes for various interface routines.  */
+
+typedef enum {
+  CB_RC_OK = 0,
+  /* generic error */
+  CB_RC_ERR,
+  /* either file not found or no read access */
+  CB_RC_ACCESS,
+  CB_RC_NO_MEM
+} CB_RC;
+
+/* Read in target values for system call numbers, errno values, signals.  */
+CB_RC cb_read_target_syscall_maps PARAMS ((host_callback *, const char *));
+
+/* Translate target to host syscall function numbers.  */
+int cb_target_to_host_syscall PARAMS ((host_callback *, int));
+
+/* Translate host to target errno value.  */
+int cb_host_to_target_errno PARAMS ((host_callback *, int));
+
+/* Translate target to host open flags.  */
+int cb_target_to_host_open PARAMS ((host_callback *, int));
+
+/* Translate target signal number to host.  */
+int cb_target_to_host_signal PARAMS ((host_callback *, int));
+
+/* Translate host signal number to target.  */
+int cb_host_to_target_signal PARAMS ((host_callback *, int));
+
+/* Translate host stat struct to target.
+   If stat struct ptr is NULL, just compute target stat struct size.
+   Result is size of target stat struct or 0 if error.  */
+int cb_host_to_target_stat PARAMS ((host_callback *, const struct stat *, PTR));
+
+/* Perform a system call.  */
+CB_RC cb_syscall PARAMS ((host_callback *, CB_SYSCALL *));
+
+#endif
diff -urp --unidirectional-new-file binutils-2.15/include/remote-sim.h binutils-freebsd/include/remote-sim.h
--- binutils-2.15/include/remote-sim.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/include/remote-sim.h	2001-06-26 12:57:15.000000000 -0400
@@ -0,0 +1,354 @@
+/* This file defines the interface between the simulator and gdb.
+   Copyright 1993, 1994, 1996, 1997, 1998, 2000
+   Free Software Foundation, Inc.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#if !defined (REMOTE_SIM_H)
+#define REMOTE_SIM_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* This file is used when building stand-alone simulators, so isolate this
+   file from gdb.  */
+
+/* Pick up CORE_ADDR_TYPE if defined (from gdb), otherwise use same value as
+   gdb does (unsigned int - from defs.h).  */
+
+#ifndef CORE_ADDR_TYPE
+typedef unsigned int SIM_ADDR;
+#else
+typedef CORE_ADDR_TYPE SIM_ADDR;
+#endif
+
+
+/* Semi-opaque type used as result of sim_open and passed back to all
+   other routines.  "desc" is short for "descriptor".
+   It is up to each simulator to define `sim_state'.  */
+
+typedef struct sim_state *SIM_DESC;
+
+
+/* Values for `kind' arg to sim_open.  */
+
+typedef enum {
+  SIM_OPEN_STANDALONE, /* simulator used standalone (run.c) */
+  SIM_OPEN_DEBUG       /* simulator used by debugger (gdb) */
+} SIM_OPEN_KIND;
+
+
+/* Return codes from various functions.  */
+
+typedef enum {
+  SIM_RC_FAIL = 0,
+  SIM_RC_OK = 1,
+  SIM_RC_UNKNOWN_BREAKPOINT = 2,
+  SIM_RC_INSUFFICIENT_RESOURCES = 3,
+  SIM_RC_DUPLICATE_BREAKPOINT = 4
+} SIM_RC;
+
+
+/* The bfd struct, as an opaque type.  */
+
+struct _bfd;
+
+
+/* Main simulator entry points.  */
+
+
+/* Create a fully initialized simulator instance.
+
+   (This function is called when the simulator is selected from the
+   gdb command line.)
+
+   KIND specifies how the simulator shall be used.  Currently there
+   are only two kinds: stand-alone and debug.
+
+   CALLBACK specifies a standard host callback (defined in callback.h).
+
+   ABFD, when non NULL, designates a target program.  The program is
+   not loaded.
+
+   ARGV is a standard ARGV pointer such as that passed from the
+   command line.  The syntax of the argument list is is assumed to be
+   ``SIM-PROG { SIM-OPTION } [ TARGET-PROGRAM { TARGET-OPTION } ]''.
+   The trailing TARGET-PROGRAM and args are only valid for a
+   stand-alone simulator.
+
+   On success, the result is a non NULL descriptor that shall be
+   passed to the other sim_foo functions.  While the simulator
+   configuration can be parameterized by (in decreasing precedence)
+   ARGV's SIM-OPTION, ARGV's TARGET-PROGRAM and the ABFD argument, the
+   successful creation of the simulator shall not dependent on the
+   presence of any of these arguments/options.
+
+   Hardware simulator: The created simulator shall be sufficiently
+   initialized to handle, with out restrictions any client requests
+   (including memory reads/writes, register fetch/stores and a
+   resume).
+
+   Process simulator: that process is not created until a call to
+   sim_create_inferior.  FIXME: What should the state of the simulator
+   be? */
+
+SIM_DESC sim_open PARAMS ((SIM_OPEN_KIND kind, struct host_callback_struct *callback, struct _bfd *abfd, char **argv));
+
+
+/* Destory a simulator instance.
+
+   QUITTING is non-zero if we cannot hang on errors.
+
+   This may involve freeing target memory and closing any open files
+   and mmap'd areas.  You cannot assume sim_kill has already been
+   called. */
+
+void sim_close PARAMS ((SIM_DESC sd, int quitting));
+
+
+/* Load program PROG into the simulators memory.
+
+   If ABFD is non-NULL, the bfd for the file has already been opened.
+   The result is a return code indicating success.
+
+   Hardware simulator: Normally, each program section is written into
+   memory according to that sections LMA using physical (direct)
+   addressing.  The exception being systems, such as PPC/CHRP, which
+   support more complicated program loaders.  A call to this function
+   should not effect the state of the processor registers.  Multiple
+   calls to this function are permitted and have an accumulative
+   effect.
+
+   Process simulator: Calls to this function may be ignored.
+
+   FIXME: Most hardware simulators load the image at the VMA using
+   virtual addressing.
+
+   FIXME: For some hardware targets, before a loaded program can be
+   executed, it requires the manipulation of VM registers and tables.
+   Such manipulation should probably (?) occure in
+   sim_create_inferior. */
+
+SIM_RC sim_load PARAMS ((SIM_DESC sd, char *prog, struct _bfd *abfd, int from_tty));
+
+
+/* Prepare to run the simulated program.
+
+   ABFD, if not NULL, provides initial processor state information.
+   ARGV and ENV, if non NULL, are NULL terminated lists of pointers.
+
+   Hardware simulator: This function shall initialize the processor
+   registers to a known value.  The program counter and possibly stack
+   pointer shall be set using information obtained from ABFD (or
+   hardware reset defaults).  ARGV and ENV, dependant on the target
+   ABI, may be written to memory.
+
+   Process simulator: After a call to this function, a new process
+   instance shall exist. The TEXT, DATA, BSS and stack regions shall
+   all be initialized, ARGV and ENV shall be written to process
+   address space (according to the applicable ABI) and the program
+   counter and stack pointer set accordingly. */
+
+SIM_RC sim_create_inferior PARAMS ((SIM_DESC sd, struct _bfd *abfd, char **argv, char **env));
+
+
+/* Fetch LENGTH bytes of the simulated program's memory.  Start fetch
+   at virtual address MEM and store in BUF.  Result is number of bytes
+   read, or zero if error.  */
+
+int sim_read PARAMS ((SIM_DESC sd, SIM_ADDR mem, unsigned char *buf, int length));
+
+
+/* Store LENGTH bytes from BUF into the simulated program's
+   memory. Store bytes starting at virtual address MEM. Result is
+   number of bytes write, or zero if error.  */
+
+int sim_write PARAMS ((SIM_DESC sd, SIM_ADDR mem, unsigned char *buf, int length));
+
+
+/* Fetch register REGNO storing its raw (target endian) value in the
+   LENGTH byte buffer BUF.  Return the actual size of the register or
+   zero if REGNO is not applicable.
+
+   Legacy implementations ignore LENGTH and always return -1.
+
+   If LENGTH does not match the size of REGNO no data is transfered
+   (the actual register size is still returned). */
+
+int sim_fetch_register PARAMS ((SIM_DESC sd, int regno, unsigned char *buf, int length));
+
+
+/* Store register REGNO from the raw (target endian) value in BUF.
+   Return the actual size of the register or zero if REGNO is not
+   applicable.
+
+   Legacy implementations ignore LENGTH and always return -1.
+
+   If LENGTH does not match the size of REGNO no data is transfered
+   (the actual register size is still returned). */
+
+int sim_store_register PARAMS ((SIM_DESC sd, int regno, unsigned char *buf, int length));
+
+
+/* Print whatever statistics the simulator has collected.
+
+   VERBOSE is currently unused and must always be zero.  */
+
+void sim_info PARAMS ((SIM_DESC sd, int verbose));
+
+
+/* Run (or resume) the simulated program.
+
+   STEP, when non-zero indicates that only a single simulator cycle
+   should be emulated.
+
+   SIGGNAL, if non-zero is a (HOST) SIGRC value indicating the type of
+   event (hardware interrupt, signal) to be delivered to the simulated
+   program.
+
+   Hardware simulator: If the SIGRC value returned by
+   sim_stop_reason() is passed back to the simulator via SIGGNAL then
+   the hardware simulator shall correctly deliver the hardware event
+   indicated by that signal.  If a value of zero is passed in then the
+   simulation will continue as if there were no outstanding signal.
+   The effect of any other SIGGNAL value is is implementation
+   dependant.
+
+   Process simulator: If SIGRC is non-zero then the corresponding
+   signal is delivered to the simulated program and execution is then
+   continued.  A zero SIGRC value indicates that the program should
+   continue as normal. */
+
+void sim_resume PARAMS ((SIM_DESC sd, int step, int siggnal));
+
+
+/* Asynchronous request to stop the simulation.
+   A nonzero return indicates that the simulator is able to handle
+   the request */
+
+int sim_stop PARAMS ((SIM_DESC sd));
+
+
+/* Fetch the REASON why the program stopped.
+
+   SIM_EXITED: The program has terminated. SIGRC indicates the target
+   dependant exit status.
+
+   SIM_STOPPED: The program has stopped.  SIGRC uses the host's signal
+   numbering as a way of identifying the reaon: program interrupted by
+   user via a sim_stop request (SIGINT); a breakpoint instruction
+   (SIGTRAP); a completed single step (SIGTRAP); an internal error
+   condition (SIGABRT); an illegal instruction (SIGILL); Access to an
+   undefined memory region (SIGSEGV); Mis-aligned memory access
+   (SIGBUS).  For some signals information in addition to the signal
+   number may be retained by the simulator (e.g. offending address),
+   that information is not directly accessable via this interface.
+
+   SIM_SIGNALLED: The program has been terminated by a signal. The
+   simulator has encountered target code that causes the the program
+   to exit with signal SIGRC.
+
+   SIM_RUNNING, SIM_POLLING: The return of one of these values
+   indicates a problem internal to the simulator. */
+
+enum sim_stop { sim_running, sim_polling, sim_exited, sim_stopped, sim_signalled };
+
+void sim_stop_reason PARAMS ((SIM_DESC sd, enum sim_stop *reason, int *sigrc));
+
+
+/* Passthru for other commands that the simulator might support.
+   Simulators should be prepared to deal with any combination of NULL
+   or empty CMD. */
+
+void sim_do_command PARAMS ((SIM_DESC sd, char *cmd));
+
+/* Call these functions to set and clear breakpoints at ADDR. */
+
+SIM_RC sim_set_breakpoint PARAMS ((SIM_DESC sd, SIM_ADDR addr));
+SIM_RC sim_clear_breakpoint PARAMS ((SIM_DESC sd, SIM_ADDR addr));
+SIM_RC sim_clear_all_breakpoints PARAMS ((SIM_DESC sd));
+
+/* These functions are used to enable and disable breakpoints. */
+
+SIM_RC sim_enable_breakpoint PARAMS ((SIM_DESC sd, SIM_ADDR addr));
+SIM_RC sim_disable_breakpoint PARAMS ((SIM_DESC sd, SIM_ADDR addr));
+SIM_RC sim_enable_all_breakpoints PARAMS ((SIM_DESC sd));
+SIM_RC sim_disable_all_breakpoints PARAMS ((SIM_DESC sd));
+
+
+/* Provide simulator with a default (global) host_callback_struct.
+   THIS PROCEDURE IS DEPRECIATED.
+   GDB and NRUN do not use this interface.
+   This procedure does not take a SIM_DESC argument as it is
+   used before sim_open. */
+
+void sim_set_callbacks PARAMS ((struct host_callback_struct *));
+
+
+/* Set the size of the simulator memory array.
+   THIS PROCEDURE IS DEPRECIATED.
+   GDB and NRUN do not use this interface.
+   This procedure does not take a SIM_DESC argument as it is
+   used before sim_open. */
+
+void sim_size PARAMS ((int i));
+
+
+/* Single-step simulator with tracing enabled.
+   THIS PROCEDURE IS DEPRECIATED.
+   THIS PROCEDURE IS EVEN MORE DEPRECATED THAN SIM_SET_TRACE
+   GDB and NRUN do not use this interface.
+   This procedure returns: ``0'' indicating that the simulator should
+   be continued using sim_trace() calls; ``1'' indicating that the
+   simulation has finished. */
+
+int sim_trace PARAMS ((SIM_DESC sd));
+
+
+/* Enable tracing.
+   THIS PROCEDURE IS DEPRECIATED.
+   GDB and NRUN do not use this interface.
+   This procedure returns: ``0'' indicating that the simulator should
+   be continued using sim_trace() calls; ``1'' indicating that the
+   simulation has finished. */
+
+void sim_set_trace PARAMS ((void));
+
+
+/* Configure the size of the profile buffer.
+   THIS PROCEDURE IS DEPRECIATED.
+   GDB and NRUN do not use this interface.
+   This procedure does not take a SIM_DESC argument as it is
+   used before sim_open. */
+
+void sim_set_profile_size PARAMS ((int n));
+
+
+/* Kill the running program.
+   THIS PROCEDURE IS DEPRECIATED.
+   GDB and NRUN do not use this interface.
+   This procedure will be replaced as part of the introduction of
+   multi-cpu simulators. */
+
+void sim_kill PARAMS ((SIM_DESC sd));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !defined (REMOTE_SIM_H) */
diff -urp --unidirectional-new-file binutils-2.15/ld/Makefile.in binutils-freebsd/ld/Makefile.in
--- binutils-2.15/ld/Makefile.in	2004-05-17 15:36:15.000000000 -0400
+++ binutils-freebsd/ld/Makefile.in	2004-06-16 02:03:34.000000000 -0400
@@ -11,6 +11,9 @@
 # PARTICULAR PURPOSE.
 
 
+# $FreeBSD: src/contrib/binutils/ld/Makefile.in,v 1.15 2004/06/16 06:03:34 obrien Exp $
+
+
 SHELL = @SHELL@
 
 srcdir = @srcdir@
@@ -331,6 +334,7 @@ ALL_EMULATIONS = \
 	ei386beos.o \
 	ei386bsd.o \
 	ei386coff.o \
+	ei386freebsd.o \
 	ei386go32.o \
 	ei386linux.o \
 	ei386lynx.o \
@@ -1660,6 +1664,9 @@ ei386bsd.c: $(srcdir)/emulparams/i386bsd
 ei386coff.c: $(srcdir)/emulparams/i386coff.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} i386coff "$(tdir_i386coff)"
+ei386freebsd.c: $(srcdir)/emulparams/i386freebsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386freebsd "$(tdir_i386freebsd)"
 ei386go32.c: $(srcdir)/emulparams/i386go32.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386go32.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} i386go32 "$(tdir_i386go32)"
diff -urp --unidirectional-new-file binutils-2.15/ld/emulparams/i386freebsd.sh binutils-freebsd/ld/emulparams/i386freebsd.sh
--- binutils-2.15/ld/emulparams/i386freebsd.sh	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/ld/emulparams/i386freebsd.sh	1998-03-01 18:26:32.000000000 -0500
@@ -0,0 +1,6 @@
+SCRIPT_NAME=aout
+TEXT_START_ADDR=0x1020
+OUTPUT_FORMAT="a.out-i386-freebsd"
+TARGET_PAGE_SIZE=0x1000
+ARCH=i386
+EXECUTABLE_SYMBOLS='__DYNAMIC = 0;'
diff -urp --unidirectional-new-file binutils-2.15/ld/emultempl/elf32.em binutils-freebsd/ld/emultempl/elf32.em
--- binutils-2.15/ld/emultempl/elf32.em	2004-05-17 15:36:17.000000000 -0400
+++ binutils-freebsd/ld/emultempl/elf32.em	2004-06-16 02:09:06.000000000 -0400
@@ -1,3 +1,6 @@
+# $FreeBSD: src/contrib/binutils/ld/emultempl/elf32.em,v 1.14 2004/06/16 06:09:06 obrien Exp $
+
+
 # This shell script emits a C file. -*- C -*-
 # It does some substitutions.
 # This file is now misnamed, because it supports both 32 bit and 64 bit
@@ -463,6 +466,68 @@ gld${EMULATION_NAME}_add_sysroot (const 
 
 EOF
   case ${target} in
+    *-*-freebsd*)
+      cat >>e${EMULATION_NAME}.c <<EOF
+/*
+ * Read the system search path the FreeBSD way rather than like Linux.
+ */
+#include <elf-hints.h>
+
+static bfd_boolean
+gld${EMULATION_NAME}_check_ld_elf_hints (const char *name, int force)
+{
+  static bfd_boolean initialized;
+  static char *ld_elf_hints;
+
+  if (! initialized)
+    {
+      FILE *f;
+      char *tmppath;
+
+      tmppath = concat (ld_sysroot, _PATH_ELF_HINTS, NULL);
+      f = fopen (tmppath, FOPEN_RB);
+      free (tmppath);
+      if (f != NULL)
+	{
+	  struct elfhints_hdr hdr;
+
+	  if (fread(&hdr, 1, sizeof(hdr), f) == sizeof(hdr) &&
+	      hdr.magic == ELFHINTS_MAGIC &&
+	      hdr.version == 1)
+	    {
+	      if (fseek(f, hdr.strtab + hdr.dirlist, SEEK_SET) != -1)
+		{
+		  char *b;
+
+		  b = (char *) xmalloc (hdr.dirlistlen + 1);
+		  if (fread(b, 1, hdr.dirlistlen + 1, f) !=
+		      hdr.dirlistlen + 1)
+		    {
+		      free(b);
+		      b = NULL;
+		    }
+		  else
+		    {
+		      ld_elf_hints = gld${EMULATION_NAME}_add_sysroot (b);
+		      free (b);
+		    }
+		}
+	    }
+	  fclose (f);
+	}
+
+      initialized = TRUE;
+    }
+
+  if (ld_elf_hints == NULL)
+    return FALSE;
+
+  return gld${EMULATION_NAME}_search_needed (ld_elf_hints, name, force);
+}
+EOF
+    # FreeBSD
+    ;;
+
     *-*-linux-gnu*)
       cat >>e${EMULATION_NAME}.c <<EOF
 /* For a native linker, check the file /etc/ld.so.conf for directories
@@ -738,6 +803,14 @@ cat >>e${EMULATION_NAME}.c <<EOF
 EOF
 if [ "x${USE_LIBPATH}" = xyes ] ; then
   case ${target} in
+    *-*-freebsd*)
+      cat >>e${EMULATION_NAME}.c <<EOF
+	  if (gld${EMULATION_NAME}_check_ld_elf_hints (l->name, force))
+	    break;
+EOF
+    # FreeBSD
+    ;;
+
     *-*-linux-gnu*)
       cat >>e${EMULATION_NAME}.c <<EOF
 	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
diff -urp --unidirectional-new-file binutils-2.15/ld/po/POTFILES.in binutils-freebsd/ld/po/POTFILES.in
--- binutils-2.15/ld/po/POTFILES.in	2003-07-17 10:22:41.000000000 -0400
+++ binutils-freebsd/ld/po/POTFILES.in	2001-06-26 12:57:43.000000000 -0400
@@ -1,6 +1,7 @@
 deffile.h
 emultempl/armcoff.em
 emultempl/pe.em
+ld.h
 ldcref.c
 ldctor.c
 ldctor.h
@@ -10,7 +11,6 @@ ldexp.c
 ldexp.h
 ldfile.c
 ldfile.h
-ld.h
 ldlang.c
 ldlang.h
 ldlex.h
diff -urp --unidirectional-new-file binutils-2.15/ld/po/ld.pot binutils-freebsd/ld/po/ld.pot
--- binutils-2.15/ld/po/ld.pot	2003-07-11 01:10:21.000000000 -0400
+++ binutils-freebsd/ld/po/ld.pot	2002-12-02 04:05:58.000000000 -0500
@@ -7,7 +7,7 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
-"POT-Creation-Date: 2003-07-11 13:58+0930\n"
+"POT-Creation-Date: 2002-10-30 10:08-0500\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -15,210 +15,195 @@ msgstr ""
 "Content-Type: text/plain; charset=CHARSET\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: emultempl/armcoff.em:72
+#: emultempl/armcoff.em:71
 msgid "  --support-old-code   Support interworking with old code\n"
 msgstr ""
 
-#: emultempl/armcoff.em:73
+#: emultempl/armcoff.em:72
 msgid "  --thumb-entry=<sym>  Set the entry point to be Thumb symbol <sym>\n"
 msgstr ""
 
-#: emultempl/armcoff.em:121
+#: emultempl/armcoff.em:141
 #, c-format
 msgid "Errors encountered processing file %s"
 msgstr ""
 
-#: emultempl/armcoff.em:188 emultempl/pe.em:1396
+#: emultempl/armcoff.em:207 emultempl/pe.em:1422
 msgid "%P: warning: '--thumb-entry %s' is overriding '-e %s'\n"
 msgstr ""
 
-#: emultempl/armcoff.em:193 emultempl/pe.em:1401
+#: emultempl/armcoff.em:212 emultempl/pe.em:1427
 msgid "%P: warning: connot find thumb start symbol %s\n"
 msgstr ""
 
-#: emultempl/pe.em:300
+#: emultempl/pe.em:317
 msgid ""
 "  --base_file <basefile>             Generate a base file for relocatable "
 "DLLs\n"
 msgstr ""
 
-#: emultempl/pe.em:301
+#: emultempl/pe.em:318
 msgid ""
 "  --dll                              Set image base to the default for DLLs\n"
 msgstr ""
 
-#: emultempl/pe.em:302
+#: emultempl/pe.em:319
 msgid "  --file-alignment <size>            Set file alignment\n"
 msgstr ""
 
-#: emultempl/pe.em:303
+#: emultempl/pe.em:320
 msgid "  --heap <size>                      Set initial size of the heap\n"
 msgstr ""
 
-#: emultempl/pe.em:304
+#: emultempl/pe.em:321
 msgid ""
 "  --image-base <address>             Set start address of the executable\n"
 msgstr ""
 
-#: emultempl/pe.em:305
+#: emultempl/pe.em:322
 msgid ""
 "  --major-image-version <number>     Set version number of the executable\n"
 msgstr ""
 
-#: emultempl/pe.em:306
+#: emultempl/pe.em:323
 msgid "  --major-os-version <number>        Set minimum required OS version\n"
 msgstr ""
 
-#: emultempl/pe.em:307
+#: emultempl/pe.em:324
 msgid ""
 "  --major-subsystem-version <number> Set minimum required OS subsystem "
 "version\n"
 msgstr ""
 
-#: emultempl/pe.em:308
+#: emultempl/pe.em:325
 msgid ""
 "  --minor-image-version <number>     Set revision number of the executable\n"
 msgstr ""
 
-#: emultempl/pe.em:309
+#: emultempl/pe.em:326
 msgid "  --minor-os-version <number>        Set minimum required OS revision\n"
 msgstr ""
 
-#: emultempl/pe.em:310
+#: emultempl/pe.em:327
 msgid ""
 "  --minor-subsystem-version <number> Set minimum required OS subsystem "
 "revision\n"
 msgstr ""
 
-#: emultempl/pe.em:311
+#: emultempl/pe.em:328
 msgid "  --section-alignment <size>         Set section alignment\n"
 msgstr ""
 
-#: emultempl/pe.em:312
+#: emultempl/pe.em:329
 msgid "  --stack <size>                     Set size of the initial stack\n"
 msgstr ""
 
-#: emultempl/pe.em:313
+#: emultempl/pe.em:330
 msgid ""
 "  --subsystem <name>[:<version>]     Set required OS subsystem [& version]\n"
 msgstr ""
 
-#: emultempl/pe.em:314
+#: emultempl/pe.em:331
 msgid ""
 "  --support-old-code                 Support interworking with old code\n"
 msgstr ""
 
-#: emultempl/pe.em:315
+#: emultempl/pe.em:332
 msgid ""
 "  --thumb-entry=<symbol>             Set the entry point to be Thumb "
 "<symbol>\n"
 msgstr ""
 
-#: emultempl/pe.em:317
+#: emultempl/pe.em:334
 msgid ""
 "  --add-stdcall-alias                Export symbols with and without @nn\n"
 msgstr ""
 
-#: emultempl/pe.em:318
+#: emultempl/pe.em:335
 msgid "  --disable-stdcall-fixup            Don't link _sym to _sym@nn\n"
 msgstr ""
 
-#: emultempl/pe.em:319
+#: emultempl/pe.em:336
 msgid ""
 "  --enable-stdcall-fixup             Link _sym to _sym@nn without warnings\n"
 msgstr ""
 
-#: emultempl/pe.em:320
+#: emultempl/pe.em:337
 msgid ""
 "  --exclude-symbols sym,sym,...      Exclude symbols from automatic export\n"
 msgstr ""
 
-#: emultempl/pe.em:321
+#: emultempl/pe.em:338
 msgid ""
 "  --exclude-libs lib,lib,...         Exclude libraries from automatic "
 "export\n"
 msgstr ""
 
-#: emultempl/pe.em:322
+#: emultempl/pe.em:339
 msgid ""
 "  --export-all-symbols               Automatically export all globals to "
 "DLL\n"
 msgstr ""
 
-#: emultempl/pe.em:323
+#: emultempl/pe.em:340
 msgid "  --kill-at                          Remove @nn from exported symbols\n"
 msgstr ""
 
-#: emultempl/pe.em:324
+#: emultempl/pe.em:341
 msgid "  --out-implib <file>                Generate import library\n"
 msgstr ""
 
-#: emultempl/pe.em:325
+#: emultempl/pe.em:342
 msgid ""
 "  --output-def <file>                Generate a .DEF file for the built DLL\n"
 msgstr ""
 
-#: emultempl/pe.em:326
+#: emultempl/pe.em:343
 msgid "  --warn-duplicate-exports           Warn about duplicate exports.\n"
 msgstr ""
 
-#: emultempl/pe.em:327
+#: emultempl/pe.em:344
 msgid ""
 "  --compat-implib                    Create backward compatible import "
 "libs;\n"
 "                                       create __imp_<SYMBOL> as well.\n"
 msgstr ""
 
-#: emultempl/pe.em:329
+#: emultempl/pe.em:346
 msgid ""
 "  --enable-auto-image-base           Automatically choose image base for "
 "DLLs\n"
 "                                       unless user specifies one\n"
 msgstr ""
 
-#: emultempl/pe.em:331
+#: emultempl/pe.em:348
 msgid ""
 "  --disable-auto-image-base          Do not auto-choose image base. "
 "(default)\n"
 msgstr ""
 
-#: emultempl/pe.em:332
+#: emultempl/pe.em:349
 msgid ""
 "  --dll-search-prefix=<string>       When linking dynamically to a dll "
-"without\n"
-"                                       an importlib, use <string><basename>."
-"dll\n"
+"without an\n"
+"                                       importlib, use <string><basename>."
+"dll \n"
 "                                       in preference to lib<basename>.dll \n"
 msgstr ""
 
-#: emultempl/pe.em:335
+#: emultempl/pe.em:352
 msgid ""
-"  --enable-auto-import               Do sophistcated linking of _sym to\n"
+"  --enable-auto-import               Do sophistcated linking of _sym to \n"
 "                                       __imp_sym for DATA references\n"
 msgstr ""
 
-#: emultempl/pe.em:337
+#: emultempl/pe.em:354
 msgid ""
 "  --disable-auto-import              Do not auto-import DATA items from "
 "DLLs\n"
 msgstr ""
 
-#: emultempl/pe.em:338
-msgid ""
-"  --enable-runtime-pseudo-reloc      Work around auto-import limitations by\n"
-"                                       adding pseudo-relocations resolved "
-"at\n"
-"                                       runtime.\n"
-msgstr ""
-
-#: emultempl/pe.em:341
-msgid ""
-"  --disable-runtime-pseudo-reloc     Do not add runtime pseudo-relocations "
-"for\n"
-"                                       auto-imported DATA.\n"
-msgstr ""
-
-#: emultempl/pe.em:343
+#: emultempl/pe.em:355
 msgid ""
 "  --enable-extra-pe-debug            Enable verbose debug output when "
 "building\n"
@@ -226,113 +211,119 @@ msgid ""
 "import)\n"
 msgstr ""
 
-#: emultempl/pe.em:412
+#: emultempl/pe.em:424
 msgid "%P: warning: bad version number in -subsystem option\n"
 msgstr ""
 
-#: emultempl/pe.em:448
+#: emultempl/pe.em:460
 msgid "%P%F: invalid subsystem type %s\n"
 msgstr ""
 
-#: emultempl/pe.em:460
+#: emultempl/pe.em:475
 msgid "%P%F: invalid hex number for PE parameter '%s'\n"
 msgstr ""
 
-#: emultempl/pe.em:477
+#: emultempl/pe.em:493
 msgid "%P%F: strange hex info for PE parameter '%s'\n"
 msgstr ""
 
-#: emultempl/pe.em:494
+#: emultempl/pe.em:532
 #, c-format
 msgid "%s: Can't open base file %s\n"
 msgstr ""
 
-#: emultempl/pe.em:707
+#: emultempl/pe.em:738
 msgid "%P: warning, file alignment > section alignment.\n"
 msgstr ""
 
-#: emultempl/pe.em:794 emultempl/pe.em:821
+#: emultempl/pe.em:822 emultempl/pe.em:848
 #, c-format
 msgid "Warning: resolving %s by linking to %s\n"
 msgstr ""
 
-#: emultempl/pe.em:799 emultempl/pe.em:826
+#: emultempl/pe.em:827 emultempl/pe.em:853
 msgid "Use --enable-stdcall-fixup to disable these warnings\n"
 msgstr ""
 
-#: emultempl/pe.em:800 emultempl/pe.em:827
+#: emultempl/pe.em:828 emultempl/pe.em:854
 msgid "Use --disable-stdcall-fixup to disable these fixups\n"
 msgstr ""
 
-#: emultempl/pe.em:846
+#: emultempl/pe.em:879
 #, c-format
 msgid "%C: Cannot get section contents - auto-import exception\n"
 msgstr ""
 
-#: emultempl/pe.em:883
+#: emultempl/pe.em:887
+msgid ""
+"%C: variable '%T' can't be auto-imported. Please read the documentation for "
+"ld's --enable-auto-import for details.\n"
+msgstr ""
+
+#: emultempl/pe.em:916
 #, c-format
 msgid "Info: resolving %s by linking to %s (auto-import)\n"
 msgstr ""
 
-#: emultempl/pe.em:954
+#: emultempl/pe.em:997
 msgid "%F%P: PE operations on non PE file.\n"
 msgstr ""
 
-#: emultempl/pe.em:1188
+#: emultempl/pe.em:1226
 #, c-format
 msgid "Errors encountered processing file %s\n"
 msgstr ""
 
-#: emultempl/pe.em:1211
+#: emultempl/pe.em:1249
 #, c-format
 msgid "Errors encountered processing file %s for interworking"
 msgstr ""
 
-#: emultempl/pe.em:1273 ldlang.c:1904 ldlang.c:4397 ldlang.c:4428
-#: ldmain.c:1122
+#: emultempl/pe.em:1305 ldlang.c:2071 ldlang.c:4613 ldlang.c:4646
+#: ldmain.c:1062
 msgid "%P%F: bfd_link_hash_lookup failed: %E\n"
 msgstr ""
 
-#: ldcref.c:153
+#: ldcref.c:158
 msgid "%X%P: bfd_hash_table_init of cref table failed: %E\n"
 msgstr ""
 
-#: ldcref.c:159
+#: ldcref.c:164
 msgid "%X%P: cref_hash_lookup failed: %E\n"
 msgstr ""
 
-#: ldcref.c:225
+#: ldcref.c:235
 msgid ""
 "\n"
 "Cross Reference Table\n"
 "\n"
 msgstr ""
 
-#: ldcref.c:226
+#: ldcref.c:236
 msgid "Symbol"
 msgstr ""
 
-#: ldcref.c:234
+#: ldcref.c:244
 msgid "File\n"
 msgstr ""
 
-#: ldcref.c:238
+#: ldcref.c:248
 msgid "No symbols\n"
 msgstr ""
 
-#: ldcref.c:384
+#: ldcref.c:400
 msgid "%P: symbol `%T' missing from main hash table\n"
 msgstr ""
 
-#: ldcref.c:448
+#: ldcref.c:465
 msgid "%B%F: could not read symbols; %E\n"
 msgstr ""
 
-#: ldcref.c:452 ldmain.c:1187 ldmain.c:1191
+#: ldcref.c:469 ldmain.c:1128 ldmain.c:1132
 msgid "%B%F: could not read symbols: %E\n"
 msgstr ""
 
-#: ldcref.c:517 ldcref.c:524 ldmain.c:1234 ldmain.c:1241
+#: ldcref.c:537 ldcref.c:544 ldmain.c:1178 ldmain.c:1185
 msgid "%B%F: could not read relocs: %E\n"
 msgstr ""
 
@@ -340,377 +331,369 @@ msgstr ""
 #. in OUTSECNAME.  This reloc is from a section which is
 #. mapped into a section from which references to OUTSECNAME
 #. are prohibited.  We must report an error.
-#: ldcref.c:543
+#: ldcref.c:563
 msgid "%X%C: prohibited cross reference from %s to `%T' in %s\n"
 msgstr ""
 
-#: ldctor.c:84
+#: ldctor.c:88
 msgid "%P%X: Different relocs used in set %s\n"
 msgstr ""
 
-#: ldctor.c:102
+#: ldctor.c:106
 msgid "%P%X: Different object file formats composing set %s\n"
 msgstr ""
 
-#: ldctor.c:281 ldctor.c:295
+#: ldctor.c:288 ldctor.c:302
 msgid "%P%X: %s does not support reloc %s for set %s\n"
 msgstr ""
 
-#: ldctor.c:316
+#: ldctor.c:323
 msgid "%P%X: Unsupported size %d for set %s\n"
 msgstr ""
 
-#: ldctor.c:337
+#: ldctor.c:344
 msgid ""
 "\n"
 "Set                 Symbol\n"
 "\n"
 msgstr ""
 
-#: ldemul.c:247
+#: ldemul.c:225
 #, c-format
 msgid "%S SYSLIB ignored\n"
 msgstr ""
 
-#: ldemul.c:254
+#: ldemul.c:232
 #, c-format
 msgid "%S HLL ignored\n"
 msgstr ""
 
-#: ldemul.c:275
+#: ldemul.c:253
 msgid "%P: unrecognised emulation mode: %s\n"
 msgstr ""
 
-#: ldemul.c:276
+#: ldemul.c:254
 msgid "Supported emulations: "
 msgstr ""
 
-#: ldemul.c:320
+#: ldemul.c:298
 msgid "  no emulation specific options.\n"
 msgstr ""
 
-#: ldexp.c:148
+#: ldexp.c:184
 msgid "%F%P: %s uses undefined section %s\n"
 msgstr ""
 
-#: ldexp.c:150
+#: ldexp.c:186
 msgid "%F%P: %s forward reference of section %s\n"
 msgstr ""
 
-#: ldexp.c:355
+#: ldexp.c:400
 #, c-format
 msgid "%F%S %% by zero\n"
 msgstr ""
 
-#: ldexp.c:362
+#: ldexp.c:407
 #, c-format
 msgid "%F%S / by zero\n"
 msgstr ""
 
-#: ldexp.c:533
+#: ldexp.c:581
 #, c-format
 msgid "%X%S: unresolvable symbol `%s' referenced in expression\n"
 msgstr ""
 
-#: ldexp.c:553
+#: ldexp.c:601
 #, c-format
 msgid "%F%S: undefined symbol `%s' referenced in expression\n"
 msgstr ""
 
-#: ldexp.c:677
+#: ldexp.c:726
 #, c-format
 msgid "%F%S can not PROVIDE assignment to location counter\n"
 msgstr ""
 
-#: ldexp.c:687
+#: ldexp.c:736
 #, c-format
 msgid "%F%S invalid assignment to location counter\n"
 msgstr ""
 
-#: ldexp.c:691
+#: ldexp.c:740
 #, c-format
 msgid "%F%S assignment to location counter invalid outside of SECTION\n"
 msgstr ""
 
-#: ldexp.c:700
+#: ldexp.c:749
 msgid "%F%S cannot move location counter backwards (from %V to %V)\n"
 msgstr ""
 
-#: ldexp.c:727
+#: ldexp.c:776
 msgid "%P%F:%s: hash creation failed\n"
 msgstr ""
 
-#: ldexp.c:1003 ldexp.c:1035
+#: ldexp.c:1078 ldexp.c:1112
 #, c-format
 msgid "%F%S nonconstant expression for %s\n"
 msgstr ""
 
-#: ldexp.c:1089
+#: ldexp.c:1167
 #, c-format
 msgid "%F%S non constant expression for %s\n"
 msgstr ""
 
-#: ldfile.c:144
+#: ldfile.c:105
 #, c-format
 msgid "attempt to open %s failed\n"
 msgstr ""
 
-#: ldfile.c:146
+#: ldfile.c:107
 #, c-format
 msgid "attempt to open %s succeeded\n"
 msgstr ""
 
-#: ldfile.c:152
+#: ldfile.c:113
 msgid "%F%P: invalid BFD target `%s'\n"
 msgstr ""
 
-#: ldfile.c:258 ldfile.c:275
+#: ldfile.c:218 ldfile.c:234
 msgid "%P: skipping incompatible %s when searching for %s\n"
 msgstr ""
 
-#: ldfile.c:377
+#: ldfile.c:326
 msgid "%F%P: cannot open %s for %s: %E\n"
 msgstr ""
 
-#: ldfile.c:380
+#: ldfile.c:329
 msgid "%F%P: cannot open %s: %E\n"
 msgstr ""
 
-#: ldfile.c:410
-msgid "%F%P: cannot find %s inside %s\n"
-msgstr ""
-
-#: ldfile.c:413
+#: ldfile.c:359
 msgid "%F%P: cannot find %s\n"
 msgstr ""
 
-#: ldfile.c:430 ldfile.c:446
+#: ldfile.c:378 ldfile.c:394
 #, c-format
 msgid "cannot find script file %s\n"
 msgstr ""
 
-#: ldfile.c:432 ldfile.c:448
+#: ldfile.c:380 ldfile.c:396
 #, c-format
 msgid "opened script file %s\n"
 msgstr ""
 
-#: ldfile.c:492
+#: ldfile.c:445
 msgid "%P%F: cannot open linker script file %s: %E\n"
 msgstr ""
 
-#: ldfile.c:529
+#: ldfile.c:483
 msgid "%P%F: unknown architecture: %s\n"
 msgstr ""
 
-#: ldfile.c:543
+#: ldfile.c:499
 msgid "%P%F: target architecture respecified\n"
 msgstr ""
 
-#: ldfile.c:594
+#: ldfile.c:553
 msgid "%P%F: cannot represent machine `%s'\n"
 msgstr ""
 
-#: ldlang.c:640
+#: ldlang.c:784
 msgid ""
 "\n"
 "Memory Configuration\n"
 "\n"
 msgstr ""
 
-#: ldlang.c:642
+#: ldlang.c:786
 msgid "Name"
 msgstr ""
 
-#: ldlang.c:642
+#: ldlang.c:786
 msgid "Origin"
 msgstr ""
 
-#: ldlang.c:642
+#: ldlang.c:786
 msgid "Length"
 msgstr ""
 
-#: ldlang.c:642
+#: ldlang.c:786
 msgid "Attributes"
 msgstr ""
 
-#: ldlang.c:682
+#: ldlang.c:828
 msgid ""
 "\n"
 "Linker script and memory map\n"
 "\n"
 msgstr ""
 
-#: ldlang.c:698
+#: ldlang.c:845
 msgid "%P%F: Illegal use of `%s' section\n"
 msgstr ""
 
-#: ldlang.c:707
+#: ldlang.c:855
 msgid "%P%F: output format %s cannot represent section called %s\n"
 msgstr ""
 
-#: ldlang.c:867
+#: ldlang.c:1016
 msgid "%P: %B: warning: ignoring duplicate section `%s'\n"
 msgstr ""
 
-#: ldlang.c:870
+#: ldlang.c:1019
 msgid "%P: %B: warning: ignoring duplicate `%s' section symbol `%s'\n"
 msgstr ""
 
-#: ldlang.c:884
+#: ldlang.c:1033
 msgid "%P: %B: warning: duplicate section `%s' has different size\n"
 msgstr ""
 
-#: ldlang.c:936
+#: ldlang.c:1084
 msgid "%P%F: Failed to create hash table\n"
 msgstr ""
 
-#: ldlang.c:1351
+#: ldlang.c:1503
 msgid "%B: file not recognized: %E\n"
 msgstr ""
 
-#: ldlang.c:1352
+#: ldlang.c:1504
 msgid "%B: matching formats:"
 msgstr ""
 
-#: ldlang.c:1359
+#: ldlang.c:1511
 msgid "%F%B: file not recognized: %E\n"
 msgstr ""
 
-#: ldlang.c:1418
+#: ldlang.c:1567
 msgid "%F%B: member %B in archive is not an object\n"
 msgstr ""
 
-#: ldlang.c:1429 ldlang.c:1443
+#: ldlang.c:1578 ldlang.c:1592
 msgid "%F%B: could not read symbols: %E\n"
 msgstr ""
 
-#: ldlang.c:1698
+#: ldlang.c:1859
 msgid ""
 "%P: warning: could not find any targets that match endianness requirement\n"
 msgstr ""
 
-#: ldlang.c:1711
+#: ldlang.c:1872
 msgid "%P%F: target %s not found\n"
 msgstr ""
 
-#: ldlang.c:1713
+#: ldlang.c:1874
 msgid "%P%F: cannot open output file %s: %E\n"
 msgstr ""
 
-#: ldlang.c:1723
+#: ldlang.c:1884
 msgid "%P%F:%s: can not make object file: %E\n"
 msgstr ""
 
-#: ldlang.c:1727
+#: ldlang.c:1888
 msgid "%P%F:%s: can not set architecture: %E\n"
 msgstr ""
 
-#: ldlang.c:1731
+#: ldlang.c:1892
 msgid "%P%F: can not create link hash table: %E\n"
 msgstr ""
 
-#: ldlang.c:2069
+#: ldlang.c:2241
 msgid " load address 0x%V"
 msgstr ""
 
-#: ldlang.c:2204
+#: ldlang.c:2381
 msgid "%W (size before relaxing)\n"
 msgstr ""
 
-#: ldlang.c:2288
+#: ldlang.c:2468
 #, c-format
 msgid "Address of section %s set to "
 msgstr ""
 
-#: ldlang.c:2443
+#: ldlang.c:2629
 #, c-format
 msgid "Fail with %d\n"
 msgstr ""
 
-#: ldlang.c:2683
+#: ldlang.c:2874
 msgid "%X%P: section %s [%V -> %V] overlaps section %s [%V -> %V]\n"
 msgstr ""
 
-#: ldlang.c:2711
+#: ldlang.c:2903
 msgid "%X%P: address 0x%v of %B section %s is not within region %s\n"
 msgstr ""
 
-#: ldlang.c:2719
+#: ldlang.c:2911
 msgid "%X%P: region %s is full (%B section %s)\n"
 msgstr ""
 
-#: ldlang.c:2770
+#: ldlang.c:2961
 msgid "%P%X: Internal error on COFF shared library section %s\n"
 msgstr ""
 
-#: ldlang.c:2826
-msgid "%P%F: error: no memory region specified for loadable section `%s'\n"
-msgstr ""
-
-#: ldlang.c:2830
-msgid "%P: warning: no memory region specified for loadable section `%s'\n"
+#: ldlang.c:3005
+msgid "%P: warning: no memory region specified for section `%s'\n"
 msgstr ""
 
-#: ldlang.c:2846
+#: ldlang.c:3020
 msgid "%P: warning: changing start of section %s by %u bytes\n"
 msgstr ""
 
-#: ldlang.c:2859
+#: ldlang.c:3033
 #, c-format
 msgid "%F%S: non constant address expression for section %s\n"
 msgstr ""
 
-#: ldlang.c:3036
+#: ldlang.c:3208
 msgid "%P%F: can't relax section: %E\n"
 msgstr ""
 
-#: ldlang.c:3232
+#: ldlang.c:3403
 msgid "%F%P: invalid data statement\n"
 msgstr ""
 
-#: ldlang.c:3269
+#: ldlang.c:3440
 msgid "%F%P: invalid reloc statement\n"
 msgstr ""
 
-#: ldlang.c:3408
+#: ldlang.c:3579
 msgid "%P%F:%s: can't set start address\n"
 msgstr ""
 
-#: ldlang.c:3421 ldlang.c:3439
+#: ldlang.c:3592 ldlang.c:3610
 msgid "%P%F: can't set start address\n"
 msgstr ""
 
-#: ldlang.c:3433
+#: ldlang.c:3604
 msgid "%P: warning: cannot find entry symbol %s; defaulting to %V\n"
 msgstr ""
 
-#: ldlang.c:3444
+#: ldlang.c:3615
 msgid "%P: warning: cannot find entry symbol %s; not setting start address\n"
 msgstr ""
 
-#: ldlang.c:3488
+#: ldlang.c:3665
 msgid ""
 "%P%F: Relocatable linking with relocations from format %s (%B) to format %s "
 "(%B) is not supported\n"
 msgstr ""
 
-#: ldlang.c:3497
+#: ldlang.c:3674
 msgid ""
 "%P: warning: %s architecture of input file `%B' is incompatible with %s "
 "output\n"
 msgstr ""
 
-#: ldlang.c:3518
+#: ldlang.c:3695
 msgid "%E%X: failed to merge target specific data of file %B\n"
 msgstr ""
 
-#: ldlang.c:3604
+#: ldlang.c:3784
 msgid ""
 "\n"
 "Allocating common symbols\n"
 msgstr ""
 
-#: ldlang.c:3605
+#: ldlang.c:3785
 msgid ""
 "Common symbol       size              file\n"
 "\n"
@@ -719,888 +702,859 @@ msgstr ""
 #. This message happens when using the
 #. svr3.ifile linker script, so I have
 #. disabled it.
-#: ldlang.c:3681
+#: ldlang.c:3863
 msgid "%P: no [COMMON] command, defaulting to .bss\n"
 msgstr ""
 
-#: ldlang.c:3737
+#: ldlang.c:3922
 msgid "%P%F: invalid syntax in flags\n"
 msgstr ""
 
-#: ldlang.c:4325
+#: ldlang.c:4537
 msgid "%P%Fmultiple STARTUP files\n"
 msgstr ""
 
-#: ldlang.c:4368
+#: ldlang.c:4580
 msgid "%X%P:%S: section has both a load address and a load region\n"
 msgstr ""
 
-#: ldlang.c:4608
+#: ldlang.c:4830
 msgid "%F%P: bfd_record_phdr failed: %E\n"
 msgstr ""
 
-#: ldlang.c:4627
+#: ldlang.c:4849
 msgid "%X%P: section `%s' assigned to non-existent phdr `%s'\n"
 msgstr ""
 
-#: ldlang.c:4919
+#: ldlang.c:5150
 msgid "%X%P: unknown language `%s' in version information\n"
 msgstr ""
 
-#: ldlang.c:4969
+#: ldlang.c:5202
 msgid ""
 "%X%P: anonymous version tag cannot be combined with other version tags\n"
 msgstr ""
 
-#: ldlang.c:4977
+#: ldlang.c:5209
 msgid "%X%P: duplicate version tag `%s'\n"
 msgstr ""
 
-#: ldlang.c:4990 ldlang.c:5003
+#: ldlang.c:5222 ldlang.c:5235
 msgid "%X%P: duplicate expression `%s' in version information\n"
 msgstr ""
 
-#: ldlang.c:5043
+#: ldlang.c:5277
 msgid "%X%P: unable to find version dependency `%s'\n"
 msgstr ""
 
-#: ldlang.c:5065
+#: ldlang.c:5299
 msgid "%X%P: unable to read .exports section contents\n"
 msgstr ""
 
-#: ldmain.c:247
+#: ldmain.c:198
 msgid "%X%P: can't set BFD default target to `%s': %E\n"
 msgstr ""
 
-#: ldmain.c:349
+#: ldmain.c:291
 msgid "%P%F: -r and --mpc860c0 may not be used together\n"
 msgstr ""
 
-#: ldmain.c:351
+#: ldmain.c:293
 msgid "%P%F: --relax and -r may not be used together\n"
 msgstr ""
 
-#: ldmain.c:353
+#: ldmain.c:295
 msgid "%P%F: -r and -shared may not be used together\n"
 msgstr ""
 
-#: ldmain.c:359
+#: ldmain.c:301
 msgid "%P%F: -F may not be used without -shared\n"
 msgstr ""
 
-#: ldmain.c:361
+#: ldmain.c:303
 msgid "%P%F: -f may not be used without -shared\n"
 msgstr ""
 
-#: ldmain.c:403
+#: ldmain.c:342
 msgid "using external linker script:"
 msgstr ""
 
-#: ldmain.c:405
+#: ldmain.c:344
 msgid "using internal linker script:"
 msgstr ""
 
-#: ldmain.c:439
+#: ldmain.c:378
 msgid "%P%F: no input files\n"
 msgstr ""
 
-#: ldmain.c:443
+#: ldmain.c:383
 msgid "%P: mode %s\n"
 msgstr ""
 
-#: ldmain.c:459
+#: ldmain.c:400
 msgid "%P%F: cannot open map file %s: %E\n"
 msgstr ""
 
-#: ldmain.c:489
+#: ldmain.c:433
 msgid "%P: link errors found, deleting executable `%s'\n"
 msgstr ""
 
-#: ldmain.c:498
+#: ldmain.c:444
 msgid "%F%B: final close failed: %E\n"
 msgstr ""
 
-#: ldmain.c:524
+#: ldmain.c:468
 msgid "%X%P: unable to open for source of copy `%s'\n"
 msgstr ""
 
-#: ldmain.c:527
+#: ldmain.c:470
 msgid "%X%P: unable to open for destination of copy `%s'\n"
 msgstr ""
 
-#: ldmain.c:534
+#: ldmain.c:476
 msgid "%P: Error writing file `%s'\n"
 msgstr ""
 
-#: ldmain.c:539 pe-dll.c:1443
+#: ldmain.c:482 pe-dll.c:1465
 #, c-format
 msgid "%P: Error closing file `%s'\n"
 msgstr ""
 
-#: ldmain.c:555
+#: ldmain.c:499
 #, c-format
 msgid "%s: total time in link: %ld.%06ld\n"
 msgstr ""
 
-#: ldmain.c:558
+#: ldmain.c:502
 #, c-format
 msgid "%s: data size %ld\n"
 msgstr ""
 
-#: ldmain.c:596
+#: ldmain.c:543
 msgid "%P%F: missing argument to -m\n"
 msgstr ""
 
-#: ldmain.c:741 ldmain.c:759 ldmain.c:789
+#: ldmain.c:671 ldmain.c:692 ldmain.c:723
 msgid "%P%F: bfd_hash_table_init failed: %E\n"
 msgstr ""
 
-#: ldmain.c:745 ldmain.c:763
+#: ldmain.c:676 ldmain.c:695
 msgid "%P%F: bfd_hash_lookup failed: %E\n"
 msgstr ""
 
-#: ldmain.c:777
+#: ldmain.c:710
 msgid "%X%P: error: duplicate retain-symbols-file\n"
 msgstr ""
 
-#: ldmain.c:819
+#: ldmain.c:754
 msgid "%P%F: bfd_hash_lookup for insertion failed: %E\n"
 msgstr ""
 
-#: ldmain.c:824
+#: ldmain.c:759
 msgid "%P: `-retain-symbols-file' overrides `-s' and `-S'\n"
 msgstr ""
 
-#: ldmain.c:899
+#: ldmain.c:835
 msgid ""
 "Archive member included because of file (symbol)\n"
 "\n"
 msgstr ""
 
-#: ldmain.c:969
+#: ldmain.c:906
 msgid "%X%C: multiple definition of `%T'\n"
 msgstr ""
 
-#: ldmain.c:972
+#: ldmain.c:909
 msgid "%D: first defined here\n"
 msgstr ""
 
-#: ldmain.c:976
+#: ldmain.c:913
 msgid "%P: Disabling relaxation: it will not work with multiple definitions\n"
 msgstr ""
 
-#: ldmain.c:1006
+#: ldmain.c:944
 msgid "%B: warning: definition of `%T' overriding common\n"
 msgstr ""
 
-#: ldmain.c:1009
+#: ldmain.c:947
 msgid "%B: warning: common is here\n"
 msgstr ""
 
-#: ldmain.c:1016
+#: ldmain.c:954
 msgid "%B: warning: common of `%T' overridden by definition\n"
 msgstr ""
 
-#: ldmain.c:1019
+#: ldmain.c:957
 msgid "%B: warning: defined here\n"
 msgstr ""
 
-#: ldmain.c:1026
+#: ldmain.c:964
 msgid "%B: warning: common of `%T' overridden by larger common\n"
 msgstr ""
 
-#: ldmain.c:1029
+#: ldmain.c:967
 msgid "%B: warning: larger common is here\n"
 msgstr ""
 
-#: ldmain.c:1033
+#: ldmain.c:971
 msgid "%B: warning: common of `%T' overriding smaller common\n"
 msgstr ""
 
-#: ldmain.c:1036
+#: ldmain.c:974
 msgid "%B: warning: smaller common is here\n"
 msgstr ""
 
-#: ldmain.c:1040
+#: ldmain.c:978
 msgid "%B: warning: multiple common of `%T'\n"
 msgstr ""
 
-#: ldmain.c:1042
+#: ldmain.c:980
 msgid "%B: warning: previous common is here\n"
 msgstr ""
 
-#: ldmain.c:1062 ldmain.c:1100
+#: ldmain.c:1001 ldmain.c:1040
 msgid "%P: warning: global constructor %s used\n"
 msgstr ""
 
-#: ldmain.c:1110
+#: ldmain.c:1050
 msgid "%P%F: BFD backend error: BFD_RELOC_CTOR unsupported\n"
 msgstr ""
 
-#: ldmain.c:1287 ldmisc.c:533
+#: ldmain.c:1234
 msgid "%F%P: bfd_hash_table_init failed: %E\n"
 msgstr ""
 
-#: ldmain.c:1294 ldmisc.c:540
+#: ldmain.c:1241
 msgid "%F%P: bfd_hash_lookup failed: %E\n"
 msgstr ""
 
-#: ldmain.c:1314
+#: ldmain.c:1261
 msgid "%C: undefined reference to `%T'\n"
 msgstr ""
 
-#: ldmain.c:1320
+#: ldmain.c:1267
 msgid "%D: more undefined references to `%T' follow\n"
 msgstr ""
 
-#: ldmain.c:1327
+#: ldmain.c:1274
 msgid "%B: undefined reference to `%T'\n"
 msgstr ""
 
-#: ldmain.c:1333
+#: ldmain.c:1280
 msgid "%B: more undefined references to `%T' follow\n"
 msgstr ""
 
-#: ldmain.c:1364 ldmain.c:1392 ldmain.c:1410
+#: ldmain.c:1300 ldmain.c:1321 ldmain.c:1340
 msgid "%P%X: generated"
 msgstr ""
 
-#: ldmain.c:1371
-msgid " additional relocation overflows omitted from the output\n"
-msgstr ""
-
-#: ldmain.c:1375
+#: ldmain.c:1303
 msgid " relocation truncated to fit: %s %T"
 msgstr ""
 
-#: ldmain.c:1395
+#: ldmain.c:1324
 #, c-format
 msgid "dangerous relocation: %s\n"
 msgstr ""
 
-#: ldmain.c:1413
+#: ldmain.c:1343
 msgid " reloc refers to symbol `%T' which is not being output\n"
 msgstr ""
 
-#: ldmisc.c:147
+#: ldmisc.c:157
 msgid "no symbol"
 msgstr ""
 
-#: ldmisc.c:211
+#: ldmisc.c:221
 #, c-format
 msgid "built in linker script:%u"
 msgstr ""
 
-#: ldmisc.c:260 ldmisc.c:264
+#: ldmisc.c:271 ldmisc.c:275
 msgid "%B%F: could not read symbols\n"
 msgstr ""
 
-#: ldmisc.c:291
-msgid ": In function `%T':\n"
+#. We use abfd->filename in this initial line,
+#. in case filename is a .h file or something
+#. similarly unhelpful.
+#: ldmisc.c:311
+msgid "%B: In function `%T':\n"
 msgstr ""
 
-#: ldmisc.c:438
+#: ldmisc.c:463
 msgid "%F%P: internal error %s %d\n"
 msgstr ""
 
-#: ldmisc.c:484
+#: ldmisc.c:513
 msgid "%P: internal error: aborting at %s line %d in %s\n"
 msgstr ""
 
-#: ldmisc.c:487
+#: ldmisc.c:516
 msgid "%P: internal error: aborting at %s line %d\n"
 msgstr ""
 
-#: ldmisc.c:489
+#: ldmisc.c:518
 msgid "%P%F: please report this bug\n"
 msgstr ""
 
 #. Output for noisy == 2 is intended to follow the GNU standards.
-#: ldver.c:39
+#: ldver.c:38
 #, c-format
 msgid "GNU ld version %s\n"
 msgstr ""
 
-#: ldver.c:43
+#: ldver.c:42
 msgid "Copyright 2002 Free Software Foundation, Inc.\n"
 msgstr ""
 
-#: ldver.c:44
+#: ldver.c:43
 msgid ""
 "This program is free software; you may redistribute it under the terms of\n"
 "the GNU General Public License.  This program has absolutely no warranty.\n"
 msgstr ""
 
-#: ldver.c:53
+#: ldver.c:52
 msgid "  Supported emulations:\n"
 msgstr ""
 
-#: ldwrite.c:54 ldwrite.c:190
+#: ldwrite.c:59 ldwrite.c:195
 msgid "%P%F: bfd_new_link_order failed\n"
 msgstr ""
 
-#: ldwrite.c:310
+#: ldwrite.c:325
 msgid "%F%P: clone section failed: %E\n"
 msgstr ""
 
-#: ldwrite.c:348
+#: ldwrite.c:364
 #, c-format
 msgid "%8x something else\n"
 msgstr ""
 
-#: ldwrite.c:525
+#: ldwrite.c:547
 msgid "%F%P: final link failed: %E\n"
 msgstr ""
 
-#: lexsup.c:179 lexsup.c:284
+#: lexsup.c:173 lexsup.c:268
 msgid "KEYWORD"
 msgstr ""
 
-#: lexsup.c:179
+#: lexsup.c:173
 msgid "Shared library control for HP/UX compatibility"
 msgstr ""
 
-#: lexsup.c:182
+#: lexsup.c:176
 msgid "ARCH"
 msgstr ""
 
-#: lexsup.c:182
+#: lexsup.c:176
 msgid "Set architecture"
 msgstr ""
 
-#: lexsup.c:184 lexsup.c:357
+#: lexsup.c:178 lexsup.c:339
 msgid "TARGET"
 msgstr ""
 
-#: lexsup.c:184
+#: lexsup.c:178
 msgid "Specify target for following input files"
 msgstr ""
 
-#: lexsup.c:186 lexsup.c:229 lexsup.c:241 lexsup.c:254 lexsup.c:329
-#: lexsup.c:364 lexsup.c:408
+#: lexsup.c:180 lexsup.c:221 lexsup.c:233 lexsup.c:242 lexsup.c:313
+#: lexsup.c:346 lexsup.c:386
 msgid "FILE"
 msgstr ""
 
-#: lexsup.c:186
+#: lexsup.c:180
 msgid "Read MRI format linker script"
 msgstr ""
 
-#: lexsup.c:188
+#: lexsup.c:182
 msgid "Force common symbols to be defined"
 msgstr ""
 
-#: lexsup.c:192 lexsup.c:398 lexsup.c:400 lexsup.c:402
+#: lexsup.c:186 lexsup.c:376 lexsup.c:378 lexsup.c:380
 msgid "ADDRESS"
 msgstr ""
 
-#: lexsup.c:192
+#: lexsup.c:186
 msgid "Set start address"
 msgstr ""
 
-#: lexsup.c:194
+#: lexsup.c:188
 msgid "Export all dynamic symbols"
 msgstr ""
 
-#: lexsup.c:196
+#: lexsup.c:190
 msgid "Link big-endian objects"
 msgstr ""
 
-#: lexsup.c:198
+#: lexsup.c:192
 msgid "Link little-endian objects"
 msgstr ""
 
-#: lexsup.c:200 lexsup.c:203
+#: lexsup.c:194 lexsup.c:197
 msgid "SHLIB"
 msgstr ""
 
-#: lexsup.c:200
+#: lexsup.c:194
 msgid "Auxiliary filter for shared object symbol table"
 msgstr ""
 
-#: lexsup.c:203
+#: lexsup.c:197
 msgid "Filter for shared object symbol table"
 msgstr ""
 
-#: lexsup.c:205
+#: lexsup.c:199
 msgid "Ignored"
 msgstr ""
 
-#: lexsup.c:207
+#: lexsup.c:201
 msgid "SIZE"
 msgstr ""
 
-#: lexsup.c:207
+#: lexsup.c:201
 msgid "Small data size (if no size, same as --shared)"
 msgstr ""
 
-#: lexsup.c:210
+#: lexsup.c:204
 msgid "FILENAME"
 msgstr ""
 
-#: lexsup.c:210
+#: lexsup.c:204
 msgid "Set internal name of shared library"
 msgstr ""
 
-#: lexsup.c:212
+#: lexsup.c:206
 msgid "PROGRAM"
 msgstr ""
 
-#: lexsup.c:212
+#: lexsup.c:206
 msgid "Set PROGRAM as the dynamic linker to use"
 msgstr ""
 
-#: lexsup.c:214
+#: lexsup.c:208
 msgid "LIBNAME"
 msgstr ""
 
-#: lexsup.c:214
+#: lexsup.c:208
 msgid "Search for library LIBNAME"
 msgstr ""
 
-#: lexsup.c:216
+#: lexsup.c:210
 msgid "DIRECTORY"
 msgstr ""
 
-#: lexsup.c:216
+#: lexsup.c:210
 msgid "Add DIRECTORY to library search path"
 msgstr ""
 
-#: lexsup.c:218
+#: lexsup.c:212
 msgid "EMULATION"
 msgstr ""
 
-#: lexsup.c:218
+#: lexsup.c:212
 msgid "Set emulation"
 msgstr ""
 
-#: lexsup.c:220
+#: lexsup.c:214
 msgid "Print map file on standard output"
 msgstr ""
 
-#: lexsup.c:222
+#: lexsup.c:216
 msgid "Do not page align data"
 msgstr ""
 
-#: lexsup.c:224
+#: lexsup.c:218
 msgid "Do not page align data, do not make text readonly"
 msgstr ""
 
-#: lexsup.c:227
-msgid "Page align data, make text readonly"
-msgstr ""
-
-#: lexsup.c:229
+#: lexsup.c:221
 msgid "Set output file name"
 msgstr ""
 
-#: lexsup.c:231
+#: lexsup.c:223
 msgid "Optimize output file"
 msgstr ""
 
-#: lexsup.c:233
+#: lexsup.c:225
 msgid "Ignored for SVR4 compatibility"
 msgstr ""
 
-#: lexsup.c:237
-msgid "Generate relocatable output"
+#: lexsup.c:229
+msgid "Generate relocateable output"
 msgstr ""
 
-#: lexsup.c:241
+#: lexsup.c:233
 msgid "Just link symbols (if directory, same as --rpath)"
 msgstr ""
 
-#: lexsup.c:244
+#: lexsup.c:236
 msgid "Strip all symbols"
 msgstr ""
 
-#: lexsup.c:246
+#: lexsup.c:238
 msgid "Strip debugging symbols"
 msgstr ""
 
-#: lexsup.c:248
-msgid "Strip symbols in discarded sections"
-msgstr ""
-
-#: lexsup.c:250
-msgid "Do not strip symbols in discarded sections"
-msgstr ""
-
-#: lexsup.c:252
+#: lexsup.c:240
 msgid "Trace file opens"
 msgstr ""
 
-#: lexsup.c:254
+#: lexsup.c:242
 msgid "Read linker script"
 msgstr ""
 
-#: lexsup.c:256 lexsup.c:272 lexsup.c:315 lexsup.c:327 lexsup.c:392
-#: lexsup.c:411 lexsup.c:431
+#: lexsup.c:244 lexsup.c:260 lexsup.c:299 lexsup.c:311 lexsup.c:370
+#: lexsup.c:389 lexsup.c:409
 msgid "SYMBOL"
 msgstr ""
 
-#: lexsup.c:256
+#: lexsup.c:244
 msgid "Start with undefined reference to SYMBOL"
 msgstr ""
 
-#: lexsup.c:258
+#: lexsup.c:246
 msgid "[=SECTION]"
 msgstr ""
 
-#: lexsup.c:258
+#: lexsup.c:246
 msgid "Don't merge input [SECTION | orphan] sections"
 msgstr ""
 
-#: lexsup.c:260
+#: lexsup.c:248
 msgid "Build global constructor/destructor tables"
 msgstr ""
 
-#: lexsup.c:262
+#: lexsup.c:250
 msgid "Print version information"
 msgstr ""
 
-#: lexsup.c:264
+#: lexsup.c:252
 msgid "Print version and emulation information"
 msgstr ""
 
-#: lexsup.c:266
+#: lexsup.c:254
 msgid "Discard all local symbols"
 msgstr ""
 
-#: lexsup.c:268
+#: lexsup.c:256
 msgid "Discard temporary local symbols (default)"
 msgstr ""
 
-#: lexsup.c:270
+#: lexsup.c:258
 msgid "Don't discard any local symbols"
 msgstr ""
 
-#: lexsup.c:272
+#: lexsup.c:260
 msgid "Trace mentions of SYMBOL"
 msgstr ""
 
-#: lexsup.c:274 lexsup.c:366 lexsup.c:368
+#: lexsup.c:262 lexsup.c:348 lexsup.c:350
 msgid "PATH"
 msgstr ""
 
-#: lexsup.c:274
+#: lexsup.c:262
 msgid "Default search path for Solaris compatibility"
 msgstr ""
 
-#: lexsup.c:276
+#: lexsup.c:264
 msgid "Start a group"
 msgstr ""
 
-#: lexsup.c:278
+#: lexsup.c:266
 msgid "End a group"
 msgstr ""
 
-#: lexsup.c:280
-msgid "Accept input files whose architecture cannot be determined"
-msgstr ""
-
-#: lexsup.c:282
-msgid "Reject input files whose architecture is unknown"
-msgstr ""
-
-#: lexsup.c:284
+#: lexsup.c:268
 msgid "Ignored for SunOS compatibility"
 msgstr ""
 
-#: lexsup.c:286
+#: lexsup.c:270
 msgid "Link against shared libraries"
 msgstr ""
 
-#: lexsup.c:292
+#: lexsup.c:276
 msgid "Do not link against shared libraries"
 msgstr ""
 
-#: lexsup.c:300
+#: lexsup.c:284
 msgid "Bind global references locally"
 msgstr ""
 
-#: lexsup.c:302
+#: lexsup.c:286
 msgid "Check section addresses for overlaps (default)"
 msgstr ""
 
-#: lexsup.c:304
+#: lexsup.c:288
 msgid "Do not check section addresses for overlaps"
 msgstr ""
 
-#: lexsup.c:307
+#: lexsup.c:291
 msgid "Output cross reference table"
 msgstr ""
 
-#: lexsup.c:309
+#: lexsup.c:293
 msgid "SYMBOL=EXPRESSION"
 msgstr ""
 
-#: lexsup.c:309
+#: lexsup.c:293
 msgid "Define a symbol"
 msgstr ""
 
-#: lexsup.c:311
+#: lexsup.c:295
 msgid "[=STYLE]"
 msgstr ""
 
-#: lexsup.c:311
+#: lexsup.c:295
 msgid "Demangle symbol names [using STYLE]"
 msgstr ""
 
-#: lexsup.c:313
+#: lexsup.c:297
 msgid "Generate embedded relocs"
 msgstr ""
 
-#: lexsup.c:315
+#: lexsup.c:299
 msgid "Call SYMBOL at unload-time"
 msgstr ""
 
-#: lexsup.c:317
+#: lexsup.c:301
 msgid "Force generation of file with .exe suffix"
 msgstr ""
 
-#: lexsup.c:319
+#: lexsup.c:303
 msgid "Remove unused sections (on some targets)"
 msgstr ""
 
-#: lexsup.c:322
+#: lexsup.c:306
 msgid "Don't remove unused sections (default)"
 msgstr ""
 
-#: lexsup.c:325
+#: lexsup.c:309
 msgid "Print option help"
 msgstr ""
 
-#: lexsup.c:327
+#: lexsup.c:311
 msgid "Call SYMBOL at load-time"
 msgstr ""
 
-#: lexsup.c:329
+#: lexsup.c:313
 msgid "Write a map file"
 msgstr ""
 
-#: lexsup.c:331
+#: lexsup.c:315
 msgid "Do not define Common storage"
 msgstr ""
 
-#: lexsup.c:333
+#: lexsup.c:317
 msgid "Do not demangle symbol names"
 msgstr ""
 
-#: lexsup.c:335
+#: lexsup.c:319
 msgid "Use less memory and more disk I/O"
 msgstr ""
 
-#: lexsup.c:337
+#: lexsup.c:321
 msgid "Allow no undefined symbols"
 msgstr ""
 
-#: lexsup.c:339
-msgid "Allow undefined symbols in shared objects (the default)"
-msgstr ""
-
-#: lexsup.c:341
-msgid "Do not allow undefined symbols in shared objects"
+#: lexsup.c:323
+msgid "Allow undefined symbols in shared objects"
 msgstr ""
 
-#: lexsup.c:343
+#: lexsup.c:325
 msgid "Allow multiple definitions"
 msgstr ""
 
-#: lexsup.c:345
+#: lexsup.c:327
 msgid "Disallow undefined version"
 msgstr ""
 
-#: lexsup.c:347
+#: lexsup.c:329
 msgid "Don't warn about mismatched input files"
 msgstr ""
 
-#: lexsup.c:349
+#: lexsup.c:331
 msgid "Turn off --whole-archive"
 msgstr ""
 
-#: lexsup.c:351
+#: lexsup.c:333
 msgid "Create an output file even if errors occur"
 msgstr ""
 
-#: lexsup.c:355
+#: lexsup.c:337
 msgid ""
 "Only use library directories specified on\n"
 "\t\t\t\tthe command line"
 msgstr ""
 
-#: lexsup.c:357
+#: lexsup.c:339
 msgid "Specify target of output file"
 msgstr ""
 
-#: lexsup.c:359
+#: lexsup.c:341
 msgid "Ignored for Linux compatibility"
 msgstr ""
 
-#: lexsup.c:361
+#: lexsup.c:343
 msgid "Relax branches on certain targets"
 msgstr ""
 
-#: lexsup.c:364
+#: lexsup.c:346
 msgid "Keep only symbols listed in FILE"
 msgstr ""
 
-#: lexsup.c:366
+#: lexsup.c:348
 msgid "Set runtime shared library search path"
 msgstr ""
 
-#: lexsup.c:368
+#: lexsup.c:350
 msgid "Set link time shared library search path"
 msgstr ""
 
-#: lexsup.c:370
+#: lexsup.c:352
 msgid "Create a shared library"
 msgstr ""
 
-#: lexsup.c:374
-msgid "Create a position independent executable"
-msgstr ""
-
-#: lexsup.c:378
+#: lexsup.c:356
 msgid "Sort common symbols by size"
 msgstr ""
 
-#: lexsup.c:382
+#: lexsup.c:360
 msgid "COUNT"
 msgstr ""
 
-#: lexsup.c:382
+#: lexsup.c:360
 msgid "How many tags to reserve in .dynamic section"
 msgstr ""
 
-#: lexsup.c:384
+#: lexsup.c:362
 msgid "[=SIZE]"
 msgstr ""
 
-#: lexsup.c:384
+#: lexsup.c:362
 msgid "Split output sections every SIZE octets"
 msgstr ""
 
-#: lexsup.c:386
+#: lexsup.c:364
 msgid "[=COUNT]"
 msgstr ""
 
-#: lexsup.c:386
+#: lexsup.c:364
 msgid "Split output sections every COUNT relocs"
 msgstr ""
 
-#: lexsup.c:388
+#: lexsup.c:366
 msgid "Print memory usage statistics"
 msgstr ""
 
-#: lexsup.c:390
+#: lexsup.c:368
 msgid "Display target specific options"
 msgstr ""
 
-#: lexsup.c:392
+#: lexsup.c:370
 msgid "Do task level linking"
 msgstr ""
 
-#: lexsup.c:394
+#: lexsup.c:372
 msgid "Use same format as native linker"
 msgstr ""
 
-#: lexsup.c:396
+#: lexsup.c:374
 msgid "SECTION=ADDRESS"
 msgstr ""
 
-#: lexsup.c:396
+#: lexsup.c:374
 msgid "Set address of named section"
 msgstr ""
 
-#: lexsup.c:398
+#: lexsup.c:376
 msgid "Set address of .bss section"
 msgstr ""
 
-#: lexsup.c:400
+#: lexsup.c:378
 msgid "Set address of .data section"
 msgstr ""
 
-#: lexsup.c:402
+#: lexsup.c:380
 msgid "Set address of .text section"
 msgstr ""
 
-#: lexsup.c:404
+#: lexsup.c:382
 msgid "Output lots of information during link"
 msgstr ""
 
-#: lexsup.c:408
+#: lexsup.c:386
 msgid "Read version information script"
 msgstr ""
 
-#: lexsup.c:411
+#: lexsup.c:389
 msgid ""
 "Take export symbols list from .exports, using\n"
 "\t\t\t\tSYMBOL as the version."
 msgstr ""
 
-#: lexsup.c:414
+#: lexsup.c:392
 msgid "Warn about duplicate common symbols"
 msgstr ""
 
-#: lexsup.c:416
+#: lexsup.c:394
 msgid "Warn if global constructors/destructors are seen"
 msgstr ""
 
-#: lexsup.c:419
+#: lexsup.c:397
 msgid "Warn if the multiple GP values are used"
 msgstr ""
 
-#: lexsup.c:421
+#: lexsup.c:399
 msgid "Warn only once per undefined symbol"
 msgstr ""
 
-#: lexsup.c:423
+#: lexsup.c:401
 msgid "Warn if start of section changes due to alignment"
 msgstr ""
 
-#: lexsup.c:426
+#: lexsup.c:404
 msgid "Treat warnings as errors"
 msgstr ""
 
-#: lexsup.c:429
+#: lexsup.c:407
 msgid "Include all objects from following archives"
 msgstr ""
 
-#: lexsup.c:431
+#: lexsup.c:409
 msgid "Use wrapper functions for SYMBOL"
 msgstr ""
 
-#: lexsup.c:433
+#: lexsup.c:411
 msgid "[=WORDS]"
 msgstr ""
 
-#: lexsup.c:433
+#: lexsup.c:411
 msgid ""
 "Modify problematic branches in last WORDS (1-10,\n"
 "\t\t\t\tdefault 5) words of a page"
 msgstr ""
 
-#: lexsup.c:602
+#: lexsup.c:577
 msgid "%P: unrecognized option '%s'\n"
 msgstr ""
 
-#: lexsup.c:604
+#: lexsup.c:579
 msgid "%P%F: use the --help option for usage information\n"
 msgstr ""
 
-#: lexsup.c:622
+#: lexsup.c:598
 msgid "%P%F: unrecognized -a option `%s'\n"
 msgstr ""
 
-#: lexsup.c:635
+#: lexsup.c:611
 msgid "%P%F: unrecognized -assert option `%s'\n"
 msgstr ""
 
-#: lexsup.c:678
+#: lexsup.c:654
 msgid "%F%P: unknown demangling style `%s'"
 msgstr ""
 
-#: lexsup.c:737
+#: lexsup.c:714
 msgid "%P%F: invalid number `%s'\n"
 msgstr ""
 
@@ -1612,138 +1566,128 @@ msgstr ""
 #. an error message here.  We cannot just make this a warning,
 #. increment optind, and continue because getopt is too confused
 #. and will seg-fault the next time around.
-#: lexsup.c:849
+#: lexsup.c:818
 msgid "%P%F: bad -rpath option\n"
 msgstr ""
 
-#: lexsup.c:953
+#: lexsup.c:916
 msgid "%P%F: -shared not supported\n"
 msgstr ""
 
-#: lexsup.c:962
-msgid "%P%F: -pie not supported\n"
-msgstr ""
-
-#: lexsup.c:994
+#: lexsup.c:948
 msgid "%P%F: invalid argument to option \"--section-start\"\n"
 msgstr ""
 
-#: lexsup.c:1000
+#: lexsup.c:954
 msgid "%P%F: missing argument(s) to option \"--section-start\"\n"
 msgstr ""
 
-#: lexsup.c:1158
+#: lexsup.c:1103
 msgid "%P%F: may not nest groups (--help for usage)\n"
 msgstr ""
 
-#: lexsup.c:1165
+#: lexsup.c:1110
 msgid "%P%F: group ended before it began (--help for usage)\n"
 msgstr ""
 
-#: lexsup.c:1179
+#: lexsup.c:1124
 msgid "%P%F: invalid argument to option \"mpc860c0\"\n"
 msgstr ""
 
-#: lexsup.c:1234
+#: lexsup.c:1179
 msgid "%P%F: invalid hex number `%s'\n"
 msgstr ""
 
-#: lexsup.c:1246
+#: lexsup.c:1191
 #, c-format
 msgid "Usage: %s [options] file...\n"
 msgstr ""
 
-#: lexsup.c:1248
+#: lexsup.c:1193
 msgid "Options:\n"
 msgstr ""
 
 #. Note: Various tools (such as libtool) depend upon the
 #. format of the listings below - do not change them.
-#: lexsup.c:1331
+#: lexsup.c:1276
 #, c-format
 msgid "%s: supported targets:"
 msgstr ""
 
-#: lexsup.c:1339
+#: lexsup.c:1284
 #, c-format
 msgid "%s: supported emulations: "
 msgstr ""
 
-#: lexsup.c:1344
+#: lexsup.c:1289
 #, c-format
 msgid "%s: emulation specific options:\n"
 msgstr ""
 
-#: lexsup.c:1348
+#: lexsup.c:1293
 #, c-format
 msgid "Report bugs to %s\n"
 msgstr ""
 
-#: mri.c:307
+#: mri.c:334
 msgid "%P%F: unknown format type %s\n"
 msgstr ""
 
-#: pe-dll.c:301
+#: pe-dll.c:323
 #, c-format
 msgid "%XUnsupported PEI architecture: %s\n"
 msgstr ""
 
-#: pe-dll.c:650
+#: pe-dll.c:673
 #, c-format
 msgid "%XError, duplicate EXPORT with ordinals: %s (%d vs %d)\n"
 msgstr ""
 
-#: pe-dll.c:657
+#: pe-dll.c:680
 #, c-format
 msgid "Warning, duplicate EXPORT: %s\n"
 msgstr ""
 
-#: pe-dll.c:723
+#: pe-dll.c:744
 #, c-format
 msgid "%XCannot export %s: symbol not defined\n"
 msgstr ""
 
-#: pe-dll.c:729
+#: pe-dll.c:750
 #, c-format
 msgid "%XCannot export %s: symbol wrong type (%d vs %d)\n"
 msgstr ""
 
-#: pe-dll.c:736
+#: pe-dll.c:757
 #, c-format
 msgid "%XCannot export %s: symbol not found\n"
 msgstr ""
 
-#: pe-dll.c:848
+#: pe-dll.c:872
 #, c-format
 msgid "%XError, ordinal used twice: %d (%s vs %s)\n"
 msgstr ""
 
-#: pe-dll.c:1165
+#: pe-dll.c:1183
 #, c-format
 msgid "%XError: %d-bit reloc in dll\n"
 msgstr ""
 
-#: pe-dll.c:1296
+#: pe-dll.c:1318
 #, c-format
 msgid "%s: Can't open output def file %s\n"
 msgstr ""
 
-#: pe-dll.c:1439
+#: pe-dll.c:1461
 msgid "; no contents available\n"
 msgstr ""
 
-#: pe-dll.c:2203
-msgid ""
-"%C: variable '%T' can't be auto-imported. Please read the documentation for "
-"ld's --enable-auto-import for details.\n"
-msgstr ""
-
-#: pe-dll.c:2233
+#: pe-dll.c:2137
 #, c-format
 msgid "%XCan't open .lib file: %s\n"
 msgstr ""
 
-#: pe-dll.c:2238
+#: pe-dll.c:2142
 #, c-format
 msgid "Creating library file: %s\n"
 msgstr ""
diff -urp --unidirectional-new-file binutils-2.15/libiberty/configure.in binutils-freebsd/libiberty/configure.in
--- binutils-2.15/libiberty/configure.in	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/libiberty/configure.in	2002-10-11 02:01:03.000000000 -0400
@@ -0,0 +1,459 @@
+dnl Process this file with autoconf to produce a configure script
+
+AC_PREREQ(2.13)
+AC_INIT(pexecute.c)
+
+# This works around the fact that libtool configuration may change LD
+# for this particular configuration, but some shells, instead of
+# keeping the changes in LD private, export them just because LD is
+# exported.  We don't use libtool yet, but some day we might, so...
+ORIGINAL_LD_FOR_MULTILIBS=$LD
+
+dnl We use these options to decide which functions to include.
+AC_ARG_WITH(target-subdir,
+[  --with-target-subdir=SUBDIR      Configuring in a subdirectory for target])
+AC_ARG_WITH(build-subdir,
+[  --with-build-subdir=SUBDIR       Configuring in a subdirectory for build])
+AC_ARG_WITH(cross-host,
+[  --with-cross-host=HOST           Configuring with a cross compiler])
+AC_ARG_WITH(newlib,
+[  --with-newlib                    Configuring with newlib])
+
+if test "${srcdir}" = "."; then
+  if test -n "${with_build_subdir}"; then
+    libiberty_topdir="${srcdir}/../.."
+    with_target_subdir=
+  elif test -z "${with_target_subdir}"; then
+    libiberty_topdir="${srcdir}/.."
+  else
+    if test "${with_target_subdir}" != "."; then
+      libiberty_topdir="${srcdir}/${with_multisrctop}../.."
+    else
+      libiberty_topdir="${srcdir}/${with_multisrctop}.."
+    fi
+  fi
+else
+  libiberty_topdir="${srcdir}/.."
+fi
+AC_CONFIG_AUX_DIR($libiberty_topdir)
+
+dnl Very limited version of automake's enable-maintainer-mode
+
+AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
+  dnl maintainer-mode is disabled by default
+  AC_ARG_ENABLE(maintainer-mode,
+[  --enable-maintainer-mode
+                          enable make rules and dependencies not useful
+                          (and sometimes confusing) to the casual installer],
+      maintainer_mode=$enableval,
+      maintainer_mode=no)
+
+AC_MSG_RESULT($maintainer_mode)
+
+if test "$maintainer_mode" = "yes"; then
+  MAINT=''
+  NOTMAINT='#'
+else
+  MAINT='#'
+  NOTMAINT=''
+fi
+AC_SUBST(MAINT)dnl
+AC_SUBST(NOTMAINT)dnl
+
+# Do we have a single-tree copy of texinfo?  Even if we do, we can't
+# rely on it - libiberty is built before texinfo.
+AC_CHECK_PROG(MAKEINFO, makeinfo, makeinfo, )
+if test "x$MAKEINFO" = "x"; then
+    MAKEINFO="@echo makeinfo missing; true"
+    BUILD_INFO=
+else
+    BUILD_INFO=info
+    case x"`$MAKEINFO --version | grep 'GNU texinfo'`" in
+      x*\ [[1-3]].* )
+	MAKEINFO="@echo $MAKEINFO is too old, 4.0 or newer required; true"
+	BUILD_INFO=
+	AC_MSG_WARN([
+*** Makeinfo is too old. Info documentation will not be built.])
+	;;
+    esac
+fi
+AC_SUBST(MAKEINFO)
+AC_SUBST(BUILD_INFO)
+
+AC_CHECK_PROG(PERL, perl, perl, )
+if test x"$PERL" = x""; then
+  HAVE_PERL='#'
+else
+  HAVE_PERL=''
+fi
+AC_SUBST(HAVE_PERL)
+
+AC_CANONICAL_HOST
+
+dnl When we start using automake:
+dnl AM_INIT_AUTOMAKE(libiberty, 1.0)
+
+dnl These must be called before AM_PROG_LIBTOOL, because it may want
+dnl to call AC_CHECK_PROG.
+AC_CHECK_TOOL(AR, ar)
+AC_CHECK_TOOL(RANLIB, ranlib, :)
+
+LIB_AC_PROG_CC
+
+AC_PROG_CC_C_O
+# autoconf is lame and doesn't give us any substitution variable for this.
+if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = no"; then
+  NO_MINUS_C_MINUS_O=yes
+else
+  OUTPUT_OPTION='-o $@'
+fi
+AC_SUBST(NO_MINUS_C_MINUS_O)
+AC_SUBST(OUTPUT_OPTION)
+
+AC_ISC_POSIX
+AC_C_CONST
+AC_C_INLINE
+
+dnl When we start using libtool:
+dnl Default to a non shared library.  This may be overridden by the
+dnl configure option --enable-shared.
+dnl AM_DISABLE_SHARED
+
+dnl When we start using libtool:
+dnl AM_PROG_LIBTOOL
+
+dnl When we start using automake:
+dnl AM_CONFIG_HEADER(config.h:config.in)
+AC_CONFIG_HEADER(config.h:config.in)
+
+dnl When we start using automake:
+dnl AM_MAINTAINER_MODE
+dnl AC_EXEEXT
+
+dnl When we start using automake:
+dnl AM_PROG_INSTALL
+AC_PROG_INSTALL
+
+. ${srcdir}/config.table
+host_makefile_frag=${frag}
+AC_SUBST_FILE(host_makefile_frag)
+
+# It's OK to check for header files.  Although the compiler may not be
+# able to link anything, it had better be able to at least compile
+# something.
+AC_CHECK_HEADERS(sys/file.h sys/param.h limits.h stdlib.h string.h unistd.h strings.h sys/time.h time.h sys/resource.h sys/stat.h sys/mman.h fcntl.h alloca.h)
+AC_HEADER_SYS_WAIT
+AC_HEADER_TIME
+
+libiberty_AC_DECLARE_ERRNO
+
+AC_CHECK_TYPE(uintptr_t, unsigned long)
+
+if test $ac_cv_type_uintptr_t = yes
+then
+  AC_DEFINE(HAVE_UINTPTR_T, 1, [Define if you have the \`uintptr_t' type.])
+fi
+
+AC_TYPE_PID_T
+
+# This is the list of functions which libiberty will provide if they
+# are not available on the host.
+
+funcs="asprintf"
+funcs="$funcs atexit"
+funcs="$funcs basename"
+funcs="$funcs bcmp"
+funcs="$funcs bcopy"
+funcs="$funcs bsearch"
+funcs="$funcs bzero"
+funcs="$funcs calloc"
+funcs="$funcs clock"
+funcs="$funcs ffs"
+funcs="$funcs getcwd"
+funcs="$funcs getpagesize"
+funcs="$funcs index"
+funcs="$funcs insque"
+funcs="$funcs memchr"
+funcs="$funcs memcmp"
+funcs="$funcs memcpy"
+funcs="$funcs memmove"
+funcs="$funcs memset"
+funcs="$funcs mkstemps"
+funcs="$funcs putenv"
+funcs="$funcs random"
+funcs="$funcs rename"
+funcs="$funcs rindex"
+funcs="$funcs setenv"
+funcs="$funcs sigsetmask"
+funcs="$funcs strcasecmp"
+funcs="$funcs strchr"
+funcs="$funcs strdup"
+funcs="$funcs strncasecmp"
+funcs="$funcs strrchr"
+funcs="$funcs strstr"
+funcs="$funcs strtod"
+funcs="$funcs strtol"
+funcs="$funcs strtoul"
+funcs="$funcs tmpnam"
+funcs="$funcs vasprintf"
+funcs="$funcs vfprintf"
+funcs="$funcs vprintf"
+funcs="$funcs vsprintf"
+funcs="$funcs waitpid"
+
+# Also in the old function.def file: alloca, vfork, getopt.
+
+vars="sys_errlist sys_nerr sys_siglist"
+
+checkfuncs="getrusage on_exit psignal strerror strsignal sysconf times sbrk gettimeofday"
+
+# These are neither executed nor required, but they help keep
+# autoheader happy without adding a bunch of text to acconfig.h.
+if test "x" = "y"; then
+  AC_CHECK_FUNCS(asprintf atexit basename bcmp bcopy bsearch bzero calloc clock)
+  AC_CHECK_FUNCS(getcwd getpagesize index insque mkstemps memchr memcmp memcpy)
+  AC_CHECK_FUNCS(memmove memset putenv random rename rindex sigsetmask)
+  AC_CHECK_FUNCS(strcasecmp setenv strchr strdup strncasecmp strrchr strstr)
+  AC_CHECK_FUNCS(strtod strtol strtoul tmpnam vasprintf vfprintf vprintf)
+  AC_CHECK_FUNCS(vsprintf waitpid getrusage on_exit psignal strerror strsignal)
+  AC_CHECK_FUNCS(sysconf times sbrk gettimeofday ffs)
+  AC_DEFINE(HAVE_SYS_ERRLIST, 1, [Define if you have the sys_errlist variable.])
+  AC_DEFINE(HAVE_SYS_NERR,    1, [Define if you have the sys_nerr variable.])
+  AC_DEFINE(HAVE_SYS_SIGLIST, 1, [Define if you have the sys_siglist variable.])
+fi
+
+# For each of these functions, if the host does not provide the
+# function we want to put FN.o in LIBOBJS, and if the host does
+# provide the function, we want to define HAVE_FN in config.h.
+
+setobjs=
+CHECK=
+target_header_dir=
+if test -n "${with_target_subdir}"; then
+
+  # We are being configured as a target library.  AC_REPLACE_FUNCS
+  # may not work correctly, because the compiler may not be able to
+  # link executables.  Note that we may still be being configured
+  # native.
+
+  # If we are being configured for newlib, we know which functions
+  # newlib provide and which ones we will be expected to provide.
+
+  if test "x${with_newlib}" = "xyes"; then
+    LIBOBJS="asprintf.o basename.o insque.o random.o strdup.o vasprintf.o"
+
+    for f in $funcs; do
+      case "$f" in
+	asprintf | basename | insque | random | strdup | vasprintf)
+	  ;;
+	*)
+	  n=HAVE_`echo $f | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+	  AC_DEFINE_UNQUOTED($n)
+	  ;;
+      esac
+    done
+
+    # newlib doesnt provide any of the variables in $vars, so we
+    # dont have to check them here.
+
+    # Of the functions in $checkfuncs, newlib only has strerror.
+    AC_DEFINE_NOAUTOHEADER(HAVE_STRERROR)
+
+    setobjs=yes
+
+  fi
+
+  # We may wish to install the target headers somewhere.
+  AC_ARG_ENABLE(install-libiberty,
+  [  --enable-install-libiberty       Install headers for end users],
+  enable_install_libiberty=$enableval,
+  enable_install_libiberty=no)dnl
+  
+  # Option parsed, now set things appropriately.
+  case x"$enable_install_libiberty" in
+    xyes|x)
+      target_header_dir=libiberty
+      ;;
+    xno)   
+      target_header_dir=
+      ;;
+    *) 
+      # This could be sanity-checked in various ways...
+      target_header_dir="${enable_install_libiberty}"
+      ;;
+  esac
+
+
+else
+
+   # Not a target library, so we set things up to run the test suite.
+   CHECK=check-cplus-dem
+
+fi
+
+AC_SUBST(CHECK)
+AC_SUBST(target_header_dir)
+
+case "${host}" in
+  *-*-cygwin* | *-*-mingw*)
+    AC_DEFINE_NOAUTOHEADER(HAVE_SYS_ERRLIST)
+    AC_DEFINE_NOAUTOHEADER(HAVE_SYS_NERR)
+    ;;
+esac
+
+if test -z "${setobjs}"; then
+  case "${host}" in
+
+  *-*-vxworks*)
+    # Handle VxWorks configuration specially, since on VxWorks the
+    # libraries are actually on the target board, not in the file
+    # system.
+    LIBOBJS="basename.o getpagesize.o insque.o random.o strcasecmp.o"
+    LIBOBJS="$LIBOBJS strncasecmp.o strdup.o vfork.o waitpid.o vasprintf.o"
+    for f in $funcs; do
+      case "$f" in
+	basename | getpagesize | insque | random | strcasecmp)
+	  ;;
+	strncasecmp | strdup | vfork | waitpid | vasprintf)
+	  ;;
+	*)
+	  n=HAVE_`echo $f | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+	  AC_DEFINE_UNQUOTED($n)
+	  ;;
+      esac
+    done
+
+    # VxWorks doesn't provide any of the variables in $vars, so we
+    # don't have to check them here.
+
+    # Of the functions in $checkfuncs, VxWorks only has strerror.
+    AC_DEFINE_NOAUTOHEADER(HAVE_STRERROR)
+
+    setobjs=yes
+    ;;
+
+  esac
+fi
+
+if test -z "${setobjs}"; then
+
+  case "${host}" in
+
+  *-*-cygwin*)
+    # The Cygwin library actually uses a couple of files from
+    # libiberty when it is built.  If we are building a native
+    # Cygwin, and we run the tests, we will appear to have these
+    # files.  However, when we go on to build winsup, we will wind up
+    # with a library which does not have the files, since they should
+    # have come from libiberty.
+
+    # We handle this by removing the functions the winsup library
+    # provides from our shell variables, so that they appear to be
+    # missing.
+
+    # DJ - only if we're *building* cygwin, not just building *with* cygwin
+  
+    if test -n "${with_target_subdir}"
+    then
+      funcs="`echo $funcs | sed -e 's/random//'`"
+      LIBOBJS="$LIBOBJS random.o"
+      vars="`echo $vars | sed -e 's/sys_siglist//'`"
+      checkfuncs="`echo $checkfuncs | sed -e 's/strsignal//' -e 's/psignal//'`"
+    fi
+    ;;
+
+  *-*-mingw32*)
+    # Under mingw32, sys_nerr and sys_errlist exist, but they are
+    # macros, so the test below won't find them.
+    libiberty_cv_var_sys_nerr=yes
+    libiberty_cv_var_sys_errlist=yes
+    ;;
+
+  *-*-uwin*)
+    # Under some versions of uwin, vfork is notoriously buggy and the test 
+    # can hang configure; on other versions, vfork exists just as a stub.
+    # FIXME: This should be removed once vfork in uwin's runtime is fixed.
+    ac_cv_func_vfork_works=no
+    # Under uwin 2.0+, sys_nerr and sys_errlist exist, but they are
+    # macros (actually, these are imported from a DLL, but the end effect 
+    # is the same), so the test below won't find them.
+    libiberty_cv_var_sys_nerr=yes
+    libiberty_cv_var_sys_errlist=yes
+    ;;
+
+  *-*-*vms*)
+    # Under VMS, vfork works very different than on Unix. The standard test 
+    # won't work, and it isn't easily adaptable. It makes more sense to
+    # just force it.
+    ac_cv_func_vfork_works=yes
+    ;;
+
+  esac
+
+  # We haven't set the list of objects yet.  Use the standard autoconf
+  # tests.  This will only work if the compiler works.
+  AC_PROG_CC_WORKS
+  AC_REPLACE_FUNCS($funcs)
+  libiberty_AC_FUNC_C_ALLOCA
+  AC_FUNC_VFORK
+  if test $ac_cv_func_vfork_works = no; then
+    LIBOBJS="$LIBOBJS vfork.o"
+  fi
+  # We only need _doprnt if we might use it to implement v*printf.
+  if test $ac_cv_func_vprintf != yes \
+     || test $ac_cv_func_vfprintf != yes \
+     || test $ac_cv_func_vsprintf != yes; then
+    AC_REPLACE_FUNCS(_doprnt)
+  else
+    AC_CHECK_FUNCS(_doprnt)
+  fi
+
+  for v in $vars; do
+    AC_MSG_CHECKING([for $v])
+    AC_CACHE_VAL(libiberty_cv_var_$v,
+      [AC_TRY_LINK([int *p;], [extern int $v []; p = $v;],
+		   [eval "libiberty_cv_var_$v=yes"],
+		   [eval "libiberty_cv_var_$v=no"])])
+    if eval "test \"`echo '$libiberty_cv_var_'$v`\" = yes"; then
+      AC_MSG_RESULT(yes)
+      n=HAVE_`echo $v | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+      AC_DEFINE_UNQUOTED($n)
+    else
+      AC_MSG_RESULT(no)
+    fi
+  done
+  AC_CHECK_FUNCS($checkfuncs)
+fi
+
+libiberty_AC_FUNC_STRNCMP
+
+# Install a library built with a cross compiler in $(tooldir) rather
+# than $(libdir).
+if test -z "${with_cross_host}"; then
+  INSTALL_DEST=libdir
+else
+  INSTALL_DEST=tooldir
+fi
+AC_SUBST(INSTALL_DEST)
+
+# We need multilib support, but only if configuring for the target.
+AC_OUTPUT(Makefile testsuite/Makefile,
+[test -z "$CONFIG_HEADERS" || echo timestamp > stamp-h
+if test -n "$CONFIG_FILES"; then
+  if test -n "${with_build_subdir}" || test -n "${with_target_subdir}"; then
+    # FIXME: We shouldn't need to set ac_file
+    ac_file=Makefile
+    LD="${ORIGINAL_LD_FOR_MULTILIBS}"
+    . ${libiberty_topdir}/config-ml.in
+  fi
+fi],
+srcdir=${srcdir}
+host=${host}
+target=${target}
+with_target_subdir=${with_target_subdir}
+with_build_subdir=${with_build_subdir}
+with_multisubdir=${with_multisubdir}
+ac_configure_args="--enable-multilib ${ac_configure_args}"
+CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+libiberty_topdir=${libiberty_topdir}
+)
diff -urp --unidirectional-new-file binutils-2.15/libiberty/pexecute.c binutils-freebsd/libiberty/pexecute.c
--- binutils-2.15/libiberty/pexecute.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-freebsd/libiberty/pexecute.c	2002-01-27 06:59:55.000000000 -0500
@@ -0,0 +1,792 @@
+/* Utilities to execute a program in a subprocess (possibly linked by pipes
+   with other subprocesses), and wait for it.
+   Copyright (C) 1996-2000 Free Software Foundation, Inc.
+
+This file is part of the libiberty library.
+Libiberty is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+Libiberty is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with libiberty; see the file COPYING.LIB.  If not,
+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This file exports two functions: pexecute and pwait.  */
+
+/* This file lives in at least two places: libiberty and gcc.
+   Don't change one without the other.  */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#ifdef NEED_DECLARATION_ERRNO
+extern int errno;
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_SYS_WAIT_H
+#include <sys/wait.h>
+#endif
+
+#include "libiberty.h"
+#include "safe-ctype.h"
+
+/* stdin file number.  */
+#define STDIN_FILE_NO 0
+
+/* stdout file number.  */
+#define STDOUT_FILE_NO 1
+
+/* value of `pipe': port index for reading.  */
+#define READ_PORT 0
+
+/* value of `pipe': port index for writing.  */
+#define WRITE_PORT 1
+
+static char *install_error_msg = "installation problem, cannot exec `%s'";
+
+/* pexecute: execute a program.
+
+@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)
+
+Executes a program.
+
+@var{program} and @var{argv} are the arguments to
+@code{execv}/@code{execvp}.
+
+@var{this_pname} is name of the calling program (i.e., @code{argv[0]}).
+
+@var{temp_base} is the path name, sans suffix, of a temporary file to
+use if needed.  This is currently only needed for MS-DOS ports that
+don't use @code{go32} (do any still exist?).  Ports that don't need it
+can pass @code{NULL}.
+
+(@code{@var{flags} & PEXECUTE_SEARCH}) is non-zero if @env{PATH} should be searched
+(??? It's not clear that GCC passes this flag correctly).  (@code{@var{flags} &
+PEXECUTE_FIRST}) is nonzero for the first process in chain.
+(@code{@var{flags} & PEXECUTE_FIRST}) is nonzero for the last process
+in chain.  The first/last flags could be simplified to only mark the
+last of a chain of processes but that requires the caller to always
+mark the last one (and not give up early if some error occurs).
+It's more robust to require the caller to mark both ends of the chain.
+
+The result is the pid on systems like Unix where we
+@code{fork}/@code{exec} and on systems like WIN32 and OS/2 where we
+use @code{spawn}.  It is up to the caller to wait for the child.
+
+The result is the @code{WEXITSTATUS} on systems like MS-DOS where we
+@code{spawn} and wait for the child here.
+
+Upon failure, @var{errmsg_fmt} and @var{errmsg_arg} are set to the
+text of the error message with an optional argument (if not needed,
+@var{errmsg_arg} is set to @code{NULL}), and @minus{}1 is returned.
+@code{errno} is available to the caller to use.
+
+@end deftypefn
+
+@deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})
+
+Waits for a program started by @code{pexecute} to finish.
+
+@var{pid} is the process id of the task to wait for. @var{status} is
+the `status' argument to wait. @var{flags} is currently unused (allows
+future enhancement without breaking upward compatibility).  Pass 0 for now.
+
+The result is the pid of the child reaped, or -1 for failure
+(@code{errno} says why).
+
+On systems that don't support waiting for a particular child, @var{pid} is
+ignored.  On systems like MS-DOS that don't really multitask @code{pwait}
+is just a mechanism to provide a consistent interface for the caller.
+
+@end deftypefn
+
+@undocumented pfinish
+
+   pfinish: finish generation of script
+
+   pfinish is necessary for systems like MPW where a script is generated that
+   runs the requested programs.  */
+
+#ifdef __MSDOS__
+
+/* MSDOS doesn't multitask, but for the sake of a consistent interface
+   the code behaves like it does.  pexecute runs the program, tucks the
+   exit code away, and returns a "pid".  pwait must be called to fetch the
+   exit code.  */
+
+#include <process.h>
+
+/* For communicating information from pexecute to pwait.  */
+static int last_pid = 0;
+static int last_status = 0;
+static int last_reaped = 0;
+
+int
+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
+     const char *program;
+     char * const *argv;
+     const char *this_pname;
+     const char *temp_base;
+     char **errmsg_fmt, **errmsg_arg;
+     int flags;
+{
+  int rc;
+
+  last_pid++;
+  if (last_pid < 0)
+    last_pid = 1;
+
+  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)
+    abort ();
+
+#ifdef __DJGPP__
+  /* ??? What are the possible return values from spawnv?  */
+  rc = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (P_WAIT, program, argv);
+#else
+  char *scmd, *rf;
+  FILE *argfile;
+  int i, el = flags & PEXECUTE_SEARCH ? 4 : 0;
+
+  if (temp_base == 0)
+    temp_base = choose_temp_base ();
+  scmd = (char *) xmalloc (strlen (program) + strlen (temp_base) + 6 + el);
+  rf = scmd + strlen(program) + 2 + el;
+  sprintf (scmd, "%s%s @%s.gp", program,
+	   (flags & PEXECUTE_SEARCH ? ".exe" : ""), temp_base);
+  argfile = fopen (rf, "w");
+  if (argfile == 0)
+    {
+      int errno_save = errno;
+      free (scmd);
+      errno = errno_save;
+      *errmsg_fmt = "cannot open `%s.gp'";
+      *errmsg_arg = temp_base;
+      return -1;
+    }
+
+  for (i=1; argv[i]; i++)
+    {
+      char *cp;
+      for (cp = argv[i]; *cp; cp++)
+	{
+	  if (*cp == '"' || *cp == '\'' || *cp == '\\' || ISSPACE (*cp))
+	    fputc ('\\', argfile);
+	  fputc (*cp, argfile);
+	}
+      fputc ('\n', argfile);
+    }
+  fclose (argfile);
+
+  rc = system (scmd);
+
+  {
+    int errno_save = errno;
+    remove (rf);
+    free (scmd);
+    errno = errno_save;
+  }
+#endif
+
+  if (rc == -1)
+    {
+      *errmsg_fmt = install_error_msg;
+      *errmsg_arg = (char *)program;
+      return -1;
+    }
+
+  /* Tuck the status away for pwait, and return a "pid".  */
+  last_status = rc << 8;
+  return last_pid;
+}
+
+/* Use ECHILD if available, otherwise use EINVAL.  */
+#ifdef ECHILD
+#define PWAIT_ERROR ECHILD
+#else
+#define PWAIT_ERROR EINVAL
+#endif
+
+int
+pwait (pid, status, flags)
+     int pid;
+     int *status;
+     int flags;
+{
+  /* On MSDOS each pexecute must be followed by it's associated pwait.  */
+  if (pid != last_pid
+      /* Called twice for the same child?  */
+      || pid == last_reaped)
+    {
+      errno = PWAIT_ERROR;
+      return -1;
+    }
+  /* ??? Here's an opportunity to canonicalize the values in STATUS.
+     Needed?  */
+#ifdef __DJGPP__
+  *status = (last_status >> 8);
+#else
+  *status = last_status;
+#endif
+  last_reaped = last_pid;
+  return last_pid;
+}
+
+#endif /* MSDOS */
+
+#if defined (_WIN32) && ! defined (_UWIN)
+
+#include <process.h>
+
+#ifdef __CYGWIN__
+
+#define fix_argv(argvec) (argvec)
+
+extern int _spawnv ();
+extern int _spawnvp ();
+
+#else /* ! __CYGWIN__ */
+
+/* This is a kludge to get around the Microsoft C spawn functions' propensity
+   to remove the outermost set of double quotes from all arguments.  */
+
+static const char * const *
+fix_argv (argvec)
+     char **argvec;
+{
+  int i;
+
+  for (i = 1; argvec[i] != 0; i++)
+    {
+      int len, j;
+      char *temp, *newtemp;
+
+      temp = argvec[i];
+      len = strlen (temp);
+      for (j = 0; j < len; j++)
+        {
+          if (temp[j] == '"')
+            {
+              newtemp = xmalloc (len + 2);
+              strncpy (newtemp, temp, j);
+              newtemp [j] = '\\';
+              strncpy (&newtemp [j+1], &temp [j], len-j);
+              newtemp [len+1] = 0;
+              temp = newtemp;
+              len++;
+              j++;
+            }
+        }
+
+        argvec[i] = temp;
+      }
+
+  for (i = 0; argvec[i] != 0; i++)
+    {
+      if (strpbrk (argvec[i], " \t"))
+        {
+	  int len, trailing_backslash;
+	  char *temp;
+
+	  len = strlen (argvec[i]);
+	  trailing_backslash = 0;
+
+	  /* There is an added complication when an arg with embedded white
+	     space ends in a backslash (such as in the case of -iprefix arg
+	     passed to cpp). The resulting quoted strings gets misinterpreted
+	     by the command interpreter -- it thinks that the ending quote
+	     is escaped by the trailing backslash and things get confused. 
+	     We handle this case by escaping the trailing backslash, provided
+	     it was not escaped in the first place.  */
+	  if (len > 1 
+	      && argvec[i][len-1] == '\\' 
+	      && argvec[i][len-2] != '\\')
+	    {
+	      trailing_backslash = 1;
+	      ++len;			/* to escape the final backslash. */
+	    }
+
+	  len += 2;			/* and for the enclosing quotes. */
+
+	  temp = xmalloc (len + 1);
+	  temp[0] = '"';
+	  strcpy (temp + 1, argvec[i]);
+	  if (trailing_backslash)
+	    temp[len-2] = '\\';
+	  temp[len-1] = '"';
+	  temp[len] = '\0';
+
+	  argvec[i] = temp;
+	}
+    }
+
+  return (const char * const *) argvec;
+}
+#endif /* __CYGWIN__ */
+
+#include <io.h>
+#include <fcntl.h>
+#include <signal.h>
+
+/* mingw32 headers may not define the following.  */
+
+#ifndef _P_WAIT
+#  define _P_WAIT	0
+#  define _P_NOWAIT	1
+#  define _P_OVERLAY	2
+#  define _P_NOWAITO	3
+#  define _P_DETACH	4
+
+#  define WAIT_CHILD	0
+#  define WAIT_GRANDCHILD	1
+#endif
+
+/* Win32 supports pipes */
+int
+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
+     const char *program;
+     char * const *argv;
+     const char *this_pname;
+     const char *temp_base;
+     char **errmsg_fmt, **errmsg_arg;
+     int flags;
+{
+  int pid;
+  int pdes[2], org_stdin, org_stdout;
+  int input_desc, output_desc;
+  int retries, sleep_interval;
+
+  /* Pipe waiting from last process, to be used as input for the next one.
+     Value is STDIN_FILE_NO if no pipe is waiting
+     (i.e. the next command is the first of a group).  */
+  static int last_pipe_input;
+
+  /* If this is the first process, initialize.  */
+  if (flags & PEXECUTE_FIRST)
+    last_pipe_input = STDIN_FILE_NO;
+
+  input_desc = last_pipe_input;
+
+  /* If this isn't the last process, make a pipe for its output,
+     and record it as waiting to be the input to the next process.  */
+  if (! (flags & PEXECUTE_LAST))
+    {
+      if (_pipe (pdes, 256, O_BINARY) < 0)
+	{
+	  *errmsg_fmt = "pipe";
+	  *errmsg_arg = NULL;
+	  return -1;
+	}
+      output_desc = pdes[WRITE_PORT];
+      last_pipe_input = pdes[READ_PORT];
+    }
+  else
+    {
+      /* Last process.  */
+      output_desc = STDOUT_FILE_NO;
+      last_pipe_input = STDIN_FILE_NO;
+    }
+
+  if (input_desc != STDIN_FILE_NO)
+    {
+      org_stdin = dup (STDIN_FILE_NO);
+      dup2 (input_desc, STDIN_FILE_NO);
+      close (input_desc); 
+    }
+
+  if (output_desc != STDOUT_FILE_NO)
+    {
+      org_stdout = dup (STDOUT_FILE_NO);
+      dup2 (output_desc, STDOUT_FILE_NO);
+      close (output_desc);
+    }
+
+  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)
+    (_P_NOWAIT, program, fix_argv(argv));
+
+  if (input_desc != STDIN_FILE_NO)
+    {
+      dup2 (org_stdin, STDIN_FILE_NO);
+      close (org_stdin);
+    }
+
+  if (output_desc != STDOUT_FILE_NO)
+    {
+      dup2 (org_stdout, STDOUT_FILE_NO);
+      close (org_stdout);
+    }
+
+  if (pid == -1)
+    {
+      *errmsg_fmt = install_error_msg;
+      *errmsg_arg = program;
+      return -1;
+    }
+
+  return pid;
+}
+
+/* MS CRTDLL doesn't return enough information in status to decide if the
+   child exited due to a signal or not, rather it simply returns an
+   integer with the exit code of the child; eg., if the child exited with 
+   an abort() call and didn't have a handler for SIGABRT, it simply returns
+   with status = 3. We fix the status code to conform to the usual WIF*
+   macros. Note that WIFSIGNALED will never be true under CRTDLL. */
+
+int
+pwait (pid, status, flags)
+     int pid;
+     int *status;
+     int flags;
+{
+#ifdef __CYGWIN__
+  return wait (status);
+#else
+  int termstat;
+
+  pid = _cwait (&termstat, pid, WAIT_CHILD);
+
+  /* ??? Here's an opportunity to canonicalize the values in STATUS.
+     Needed?  */
+
+  /* cwait returns the child process exit code in termstat.
+     A value of 3 indicates that the child caught a signal, but not
+     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we
+     report SIGABRT.  */
+  if (termstat == 3)
+    *status = SIGABRT;
+  else
+    *status = (((termstat) & 0xff) << 8);
+
+  return pid;
+#endif /* __CYGWIN__ */
+}
+
+#endif /* _WIN32 && ! _UWIN */
+
+#ifdef OS2
+
+/* ??? Does OS2 have process.h?  */
+extern int spawnv ();
+extern int spawnvp ();
+
+int
+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
+     const char *program;
+     char * const *argv;
+     const char *this_pname;
+     const char *temp_base;
+     char **errmsg_fmt, **errmsg_arg;
+     int flags;
+{
+  int pid;
+
+  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)
+    abort ();
+  /* ??? Presumably 1 == _P_NOWAIT.  */
+  pid = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (1, program, argv);
+  if (pid == -1)
+    {
+      *errmsg_fmt = install_error_msg;
+      *errmsg_arg = program;
+      return -1;
+    }
+  return pid;
+}
+
+int
+pwait (pid, status, flags)
+     int pid;
+     int *status;
+     int flags;
+{
+  /* ??? Here's an opportunity to canonicalize the values in STATUS.
+     Needed?  */
+  int pid = wait (status);
+  return pid;
+}
+
+#endif /* OS2 */
+
+#ifdef MPW
+
+/* MPW pexecute doesn't actually run anything; instead, it writes out
+   script commands that, when run, will do the actual executing.
+
+   For example, in GCC's case, GCC will write out several script commands:
+
+   cpp ...
+   cc1 ...
+   as ...
+   ld ...
+
+   and then exit.  None of the above programs will have run yet.  The task
+   that called GCC will then execute the script and cause cpp,etc. to run.
+   The caller must invoke pfinish before calling exit.  This adds
+   the finishing touches to the generated script.  */
+
+static int first_time = 1;
+
+int
+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
+     const char *program;
+     char * const *argv;
+     const char *this_pname;
+     const char *temp_base;
+     char **errmsg_fmt, **errmsg_arg;
+     int flags;
+{
+  char tmpprogram[255];
+  char *cp, *tmpname;
+  int i;
+
+  mpwify_filename (program, tmpprogram);
+  if (first_time)
+    {
+      printf ("Set Failed 0\n");
+      first_time = 0;
+    }
+
+  fputs ("If {Failed} == 0\n", stdout);
+  /* If being verbose, output a copy of the command.  It should be
+     accurate enough and escaped enough to be "clickable".  */
+  if (flags & PEXECUTE_VERBOSE)
+    {
+      fputs ("\tEcho ", stdout);
+      fputc ('\'', stdout);
+      fputs (tmpprogram, stdout);
+      fputc ('\'', stdout);
+      fputc (' ', stdout);
+      for (i=1; argv[i]; i++)
+	{
+	  fputc ('\'', stdout);
+	  /* See if we have an argument that needs fixing.  */
+	  if (strchr(argv[i], '/'))
+	    {
+	      tmpname = (char *) xmalloc (256);
+	      mpwify_filename (argv[i], tmpname);
+	      argv[i] = tmpname;
+	    }
+	  for (cp = argv[i]; *cp; cp++)
+	    {
+	      /* Write an Option-d escape char in front of special chars.  */
+	      if (strchr("'+", *cp))
+		fputc ('\266', stdout);
+	      fputc (*cp, stdout);
+	    }
+	  fputc ('\'', stdout);
+	  fputc (' ', stdout);
+	}
+      fputs ("\n", stdout);
+    }
+  fputs ("\t", stdout);
+  fputs (tmpprogram, stdout);
+  fputc (' ', stdout);
+
+  for (i=1; argv[i]; i++)
+    {
+      /* See if we have an argument that needs fixing.  */
+      if (strchr(argv[i], '/'))
+	{
+	  tmpname = (char *) xmalloc (256);
+	  mpwify_filename (argv[i], tmpname);
+	  argv[i] = tmpname;
+	}
+      if (strchr (argv[i], ' '))
+	fputc ('\'', stdout);
+      for (cp = argv[i]; *cp; cp++)
+	{
+	  /* Write an Option-d escape char in front of special chars.  */
+	  if (strchr("'+", *cp))
+	    fputc ('\266', stdout);
+	  fputc (*cp, stdout);
+	}
+      if (strchr (argv[i], ' '))
+	fputc ('\'', stdout);
+      fputc (' ', stdout);
+    }
+
+  fputs ("\n", stdout);
+
+  /* Output commands that arrange to clean up and exit if a failure occurs.
+     We have to be careful to collect the status from the program that was
+     run, rather than some other script command.  Also, we don't exit
+     immediately, since necessary cleanups are at the end of the script.  */
+  fputs ("\tSet TmpStatus {Status}\n", stdout);
+  fputs ("\tIf {TmpStatus} != 0\n", stdout);
+  fputs ("\t\tSet Failed {TmpStatus}\n", stdout);
+  fputs ("\tEnd\n", stdout);
+  fputs ("End\n", stdout);
+
+  /* We're just composing a script, can't fail here.  */
+  return 0;
+}
+
+int
+pwait (pid, status, flags)
+     int pid;
+     int *status;
+     int flags;
+{
+  *status = 0;
+  return 0;
+}
+
+/* Write out commands that will exit with the correct error code
+   if something in the script failed.  */
+
+void
+pfinish ()
+{
+  printf ("\tExit \"{Failed}\"\n");
+}
+
+#endif /* MPW */
+
+/* include for Unix-like environments but not for Dos-like environments */
+#if ! defined (__MSDOS__) && ! defined (OS2) && ! defined (MPW) \
+    && ! (defined (_WIN32) && ! defined (_UWIN))
+
+extern int execv ();
+extern int execvp ();
+
+int
+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
+     const char *program;
+     char * const *argv;
+     const char *this_pname;
+     const char *temp_base ATTRIBUTE_UNUSED;
+     char **errmsg_fmt, **errmsg_arg;
+     int flags;
+{
+  int (*func)() = (flags & PEXECUTE_SEARCH ? execvp : execv);
+  int pid;
+  int pdes[2];
+  int input_desc, output_desc;
+  int retries, sleep_interval;
+  /* Pipe waiting from last process, to be used as input for the next one.
+     Value is STDIN_FILE_NO if no pipe is waiting
+     (i.e. the next command is the first of a group).  */
+  static int last_pipe_input;
+
+  /* If this is the first process, initialize.  */
+  if (flags & PEXECUTE_FIRST)
+    last_pipe_input = STDIN_FILE_NO;
+
+  input_desc = last_pipe_input;
+
+  /* If this isn't the last process, make a pipe for its output,
+     and record it as waiting to be the input to the next process.  */
+  if (! (flags & PEXECUTE_LAST))
+    {
+      if (pipe (pdes) < 0)
+	{
+	  *errmsg_fmt = "pipe";
+	  *errmsg_arg = NULL;
+	  return -1;
+	}
+      output_desc = pdes[WRITE_PORT];
+      last_pipe_input = pdes[READ_PORT];
+    }
+  else
+    {
+      /* Last process.  */
+      output_desc = STDOUT_FILE_NO;
+      last_pipe_input = STDIN_FILE_NO;
+    }
+
+  /* Fork a subprocess; wait and retry if it fails.  */
+  sleep_interval = 1;
+  pid = -1;
+  for (retries = 0; retries < 4; retries++)
+    {
+      pid = fork ();
+      if (pid >= 0)
+	break;
+      sleep (sleep_interval);
+      sleep_interval *= 2;
+    }
+
+  switch (pid)
+    {
+    case -1:
+      *errmsg_fmt = "fork";
+      *errmsg_arg = NULL;
+      return -1;
+
+    case 0: /* child */
+      /* Move the input and output pipes into place, if necessary.  */
+      if (input_desc != STDIN_FILE_NO)
+	{
+	  close (STDIN_FILE_NO);
+	  dup (input_desc);
+	  close (input_desc);
+	}
+      if (output_desc != STDOUT_FILE_NO)
+	{
+	  close (STDOUT_FILE_NO);
+	  dup (output_desc);
+	  close (output_desc);
+	}
+
+      /* Close the parent's descs that aren't wanted here.  */
+      if (last_pipe_input != STDIN_FILE_NO)
+	close (last_pipe_input);
+
+      /* Exec the program.  */
+      (*func) (program, argv);
+
+      fprintf (stderr, "%s: ", this_pname);
+      fprintf (stderr, install_error_msg, program);
+      fprintf (stderr, ": %s\n", xstrerror (errno));
+      exit (-1);
+      /* NOTREACHED */
+      return 0;
+
+    default:
+      /* In the parent, after forking.
+	 Close the descriptors that we made for this child.  */
+      if (input_desc != STDIN_FILE_NO)
+	close (input_desc);
+      if (output_desc != STDOUT_FILE_NO)
+	close (output_desc);
+
+      /* Return child's process number.  */
+      return pid;
+    }
+}
+
+int
+pwait (pid, status, flags)
+     int pid;
+     int *status;
+     int flags ATTRIBUTE_UNUSED;
+{
+  /* ??? Here's an opportunity to canonicalize the values in STATUS.
+     Needed?  */
+#ifdef VMS
+  pid = waitpid (-1, status, 0);
+#else
+  pid = wait (status);
+#endif
+  return pid;
+}
+
+#endif /* ! __MSDOS__ && ! OS2 && ! MPW && ! (_WIN32 && ! _UWIN) */

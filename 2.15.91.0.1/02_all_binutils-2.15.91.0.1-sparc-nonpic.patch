diff -Naurp binutils-2.15.91.0.1.orig/bfd/elf32-sparc.c binutils-2.15.91.0.1/bfd/elf32-sparc.c
--- binutils-2.15.91.0.1.orig/bfd/elf32-sparc.c	2004-05-27 14:26:02.000000000 -0400
+++ binutils-2.15.91.0.1/bfd/elf32-sparc.c	2004-05-28 01:14:24.129886000 -0400
@@ -2170,7 +2170,7 @@ elf32_sparc_relocate_section (output_bfd
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       asection *sec;
-      bfd_vma relocation, off;
+      bfd_vma relocation, off, orig_addend = 0;
       bfd_reloc_status_type r;
       bfd_boolean is_plt = FALSE;
       bfd_boolean unresolved_reloc;
@@ -2198,6 +2198,7 @@ elf32_sparc_relocate_section (output_bfd
 	{
 	  sym = local_syms + r_symndx;
 	  sec = local_sections[r_symndx];
+	  orig_addend = rel->r_addend;
 	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
 	}
       else
@@ -2488,6 +2489,23 @@ elf32_sparc_relocate_section (output_bfd
 			  asection *osec;
 
 			  osec = sec->output_section;
+			  /* FIXME: As soon as making sections zero size
+			     is possible, this if can go away.  */
+			  if (bfd_is_abs_section (osec)
+			      && h == NULL
+			      && (sec->flags & SEC_MERGE)
+			      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
+			      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
+			    {
+			      asection *msec;
+
+			      msec = sec;
+			      _bfd_merged_section_offset (output_bfd, &msec,
+					elf_section_data (sec)->sec_info,
+					sym->st_value + orig_addend);
+			      osec = msec->output_section;
+			     }
+
 			  indx = elf_section_data (osec)->dynindx;
 
 			  /* FIXME: we really should be able to link non-pic
diff -Naurp binutils-2.15.91.0.1.orig/bfd/elf64-sparc.c binutils-2.15.91.0.1/bfd/elf64-sparc.c
--- binutils-2.15.91.0.1.orig/bfd/elf64-sparc.c	2004-05-27 14:26:02.000000000 -0400
+++ binutils-2.15.91.0.1/bfd/elf64-sparc.c	2004-05-28 01:14:37.259886000 -0400
@@ -2041,7 +2041,7 @@ sparc64_elf_relocate_section (output_bfd
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       asection *sec;
-      bfd_vma relocation, off;
+      bfd_vma relocation, off, orig_addend = 0;
       bfd_reloc_status_type r;
       bfd_boolean is_plt = FALSE;
       bfd_boolean unresolved_reloc;
@@ -2064,6 +2064,7 @@ sparc64_elf_relocate_section (output_bfd
 	{
 	  sym = local_syms + r_symndx;
 	  sec = local_sections[r_symndx];
+	  orig_addend = rel->r_addend;
 	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
 	}
       else
@@ -2261,6 +2262,23 @@ sparc64_elf_relocate_section (output_bfd
 			    asection *osec;
 
 			    osec = sec->output_section;
+			    /* FIXME: As soon as making sections zero size
+			       is possible, this if can go away.  */
+			    if (bfd_is_abs_section (osec)
+				&& h == NULL
+				&& (sec->flags & SEC_MERGE)
+				&& ELF_ST_TYPE (sym->st_info) == STT_SECTION
+				&& sec->sec_info_type == ELF_INFO_TYPE_MERGE)
+			      {
+				asection *msec;
+
+				msec = sec;
+				_bfd_merged_section_offset (output_bfd, &msec,
+					elf_section_data (sec)->sec_info,
+					sym->st_value + orig_addend);
+				osec = msec->output_section;
+			      }
+
 			    indx = elf_section_data (osec)->dynindx;
 
 			    /* We are turning this relocation into one
